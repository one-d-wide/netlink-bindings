#![doc = "Netfilter nftables configuration over netlink.\n"]
#![allow(clippy::all)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(irrefutable_let_patterns)]
#![allow(unreachable_code)]
#![allow(unreachable_patterns)]
use crate::builtin::{PushBuiltinBitfield32, PushBuiltinNfgenmsg, PushDummy, PushNlmsghdr};
use crate::{
    consts,
    traits::{NetlinkRequest, Protocol},
    utils::*,
};
pub const PROTONAME: &CStr = c"nftables";
pub const PROTONUM: u16 = 12u16;
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum MetaKeys {
    Len = 0,
    Protocol = 1,
    Priority = 2,
    Mark = 3,
    Iif = 4,
    Oif = 5,
    Iifname = 6,
    Oifname = 7,
    Iftype = 8,
    Oiftype = 9,
    Skuid = 10,
    Skgid = 11,
    Nftrace = 12,
    Rtclassid = 13,
    Secmark = 14,
    Nfproto = 15,
    L4Proto = 16,
    BriIifname = 17,
    BriOifname = 18,
    Pkttype = 19,
    Cpu = 20,
    Iifgroup = 21,
    Oifgroup = 22,
    Cgroup = 23,
    Prandom = 24,
    Secpath = 25,
    Iifkind = 26,
    Oifkind = 27,
    BriIifpvid = 28,
    BriIifvproto = 29,
    TimeNs = 30,
    TimeDay = 31,
    TimeHour = 32,
    Sdif = 33,
    Sdifname = 34,
    BriBroute = 35,
}
impl MetaKeys {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Len,
            1 => Self::Protocol,
            2 => Self::Priority,
            3 => Self::Mark,
            4 => Self::Iif,
            5 => Self::Oif,
            6 => Self::Iifname,
            7 => Self::Oifname,
            8 => Self::Iftype,
            9 => Self::Oiftype,
            10 => Self::Skuid,
            11 => Self::Skgid,
            12 => Self::Nftrace,
            13 => Self::Rtclassid,
            14 => Self::Secmark,
            15 => Self::Nfproto,
            16 => Self::L4Proto,
            17 => Self::BriIifname,
            18 => Self::BriOifname,
            19 => Self::Pkttype,
            20 => Self::Cpu,
            21 => Self::Iifgroup,
            22 => Self::Oifgroup,
            23 => Self::Cgroup,
            24 => Self::Prandom,
            25 => Self::Secpath,
            26 => Self::Iifkind,
            27 => Self::Oifkind,
            28 => Self::BriIifpvid,
            29 => Self::BriIifvproto,
            30 => Self::TimeNs,
            31 => Self::TimeDay,
            32 => Self::TimeHour,
            33 => Self::Sdif,
            34 => Self::Sdifname,
            35 => Self::BriBroute,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum BitwiseOps {
    #[doc = "mask-and-xor operation used to implement NOT, AND, OR and XOR\n  dreg = (sreg & mask) ^ xor\nwith these mask and xor values:\n          mask    xor\n  NOT:    1       1\n  OR:     ~x      x\n  XOR:    1       x\n  AND:    x       0\n"]
    MaskXor = 0,
    Lshift = 1,
    Rshift = 2,
    And = 3,
    Or = 4,
    Xor = 5,
}
impl BitwiseOps {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::MaskXor,
            1 => Self::Lshift,
            2 => Self::Rshift,
            3 => Self::And,
            4 => Self::Or,
            5 => Self::Xor,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum CmpOps {
    Eq = 0,
    Neq = 1,
    Lt = 2,
    Lte = 3,
    Gt = 4,
    Gte = 5,
}
impl CmpOps {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Eq,
            1 => Self::Neq,
            2 => Self::Lt,
            3 => Self::Lte,
            4 => Self::Gt,
            5 => Self::Gte,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum ObjectType {
    Unspec = 0,
    Counter = 1,
    Quota = 2,
    CtHelper = 3,
    Limit = 4,
    Connlimit = 5,
    Tunnel = 6,
    CtTimeout = 7,
    Secmark = 8,
    CtExpect = 9,
    Synproxy = 10,
}
impl ObjectType {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Unspec,
            1 => Self::Counter,
            2 => Self::Quota,
            3 => Self::CtHelper,
            4 => Self::Limit,
            5 => Self::Connlimit,
            6 => Self::Tunnel,
            7 => Self::CtTimeout,
            8 => Self::Secmark,
            9 => Self::CtExpect,
            10 => Self::Synproxy,
            _ => return None,
        })
    }
}
#[doc = "Flags - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum NatRangeFlags {
    MapIps = 1 << 0,
    ProtoSpecified = 1 << 1,
    ProtoRandom = 1 << 2,
    Persistent = 1 << 3,
    ProtoRandomFully = 1 << 4,
    ProtoOffset = 1 << 5,
    Netmap = 1 << 6,
}
impl NatRangeFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::MapIps,
            n if n == 1 << 1 => Self::ProtoSpecified,
            n if n == 1 << 2 => Self::ProtoRandom,
            n if n == 1 << 3 => Self::Persistent,
            n if n == 1 << 4 => Self::ProtoRandomFully,
            n if n == 1 << 5 => Self::ProtoOffset,
            n if n == 1 << 6 => Self::Netmap,
            _ => return None,
        })
    }
}
#[doc = "Flags - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum TableFlags {
    Dormant = 1 << 0,
    Owner = 1 << 1,
    Persist = 1 << 2,
}
impl TableFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Dormant,
            n if n == 1 << 1 => Self::Owner,
            n if n == 1 << 2 => Self::Persist,
            _ => return None,
        })
    }
}
#[doc = "Flags - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum ChainFlags {
    Base = 1 << 0,
    HwOffload = 1 << 1,
    Binding = 1 << 2,
}
impl ChainFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Base,
            n if n == 1 << 1 => Self::HwOffload,
            n if n == 1 << 2 => Self::Binding,
            _ => return None,
        })
    }
}
#[doc = "Flags - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum SetFlags {
    Anonymous = 1 << 0,
    Constant = 1 << 1,
    Interval = 1 << 2,
    Map = 1 << 3,
    Timeout = 1 << 4,
    Eval = 1 << 5,
    Object = 1 << 6,
    Concat = 1 << 7,
    Expr = 1 << 8,
}
impl SetFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Anonymous,
            n if n == 1 << 1 => Self::Constant,
            n if n == 1 << 2 => Self::Interval,
            n if n == 1 << 3 => Self::Map,
            n if n == 1 << 4 => Self::Timeout,
            n if n == 1 << 5 => Self::Eval,
            n if n == 1 << 6 => Self::Object,
            n if n == 1 << 7 => Self::Concat,
            n if n == 1 << 8 => Self::Expr,
            _ => return None,
        })
    }
}
#[doc = "Flags - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum SetElemFlags {
    IntervalEnd = 1 << 0,
    Catchall = 1 << 1,
}
impl SetElemFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::IntervalEnd,
            n if n == 1 << 1 => Self::Catchall,
            _ => return None,
        })
    }
}
#[doc = "Flags - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum LookupFlags {
    Invert = 1 << 0,
}
impl LookupFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Invert,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum CtKeys {
    State = 0,
    Direction = 1,
    Status = 2,
    Mark = 3,
    Secmark = 4,
    Expiration = 5,
    Helper = 6,
    L3protocol = 7,
    Src = 8,
    Dst = 9,
    Protocol = 10,
    ProtoSrc = 11,
    ProtoDst = 12,
    Labels = 13,
    Pkts = 14,
    Bytes = 15,
    Avgpkt = 16,
    Zone = 17,
    Eventmask = 18,
    SrcIp = 19,
    DstIp = 20,
    SrcIp6 = 21,
    DstIp6 = 22,
    CtId = 23,
}
impl CtKeys {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::State,
            1 => Self::Direction,
            2 => Self::Status,
            3 => Self::Mark,
            4 => Self::Secmark,
            5 => Self::Expiration,
            6 => Self::Helper,
            7 => Self::L3protocol,
            8 => Self::Src,
            9 => Self::Dst,
            10 => Self::Protocol,
            11 => Self::ProtoSrc,
            12 => Self::ProtoDst,
            13 => Self::Labels,
            14 => Self::Pkts,
            15 => Self::Bytes,
            16 => Self::Avgpkt,
            17 => Self::Zone,
            18 => Self::Eventmask,
            19 => Self::SrcIp,
            20 => Self::DstIp,
            21 => Self::SrcIp6,
            22 => Self::DstIp6,
            23 => Self::CtId,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum CtDirection {
    Original = 0,
    Reply = 1,
}
impl CtDirection {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Original,
            1 => Self::Reply,
            _ => return None,
        })
    }
}
#[doc = "Flags - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum QuotaFlags {
    Invert = 1 << 0,
    Depleted = 1 << 1,
}
impl QuotaFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Invert,
            n if n == 1 << 1 => Self::Depleted,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum VerdictCode {
    Continue = 4294967295,
    Break = 4294967294,
    Jump = 4294967293,
    Goto = 4294967292,
    Return = 4294967291,
    Drop = 0,
    Accept = 1,
    Stolen = 2,
    Queue = 3,
    Repeat = 4,
}
impl VerdictCode {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            4294967295 => Self::Continue,
            4294967294 => Self::Break,
            4294967293 => Self::Jump,
            4294967292 => Self::Goto,
            4294967291 => Self::Return,
            0 => Self::Drop,
            1 => Self::Accept,
            2 => Self::Stolen,
            3 => Self::Queue,
            4 => Self::Repeat,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum FibResult {
    Oif = 0,
    Oifname = 1,
    Addrtype = 2,
}
impl FibResult {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Oif,
            1 => Self::Oifname,
            2 => Self::Addrtype,
            _ => return None,
        })
    }
}
#[doc = "Flags - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum FibFlags {
    Saddr = 1 << 0,
    Daddr = 1 << 1,
    Mark = 1 << 2,
    Iif = 1 << 3,
    Oif = 1 << 4,
    Present = 1 << 5,
}
impl FibFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Saddr,
            n if n == 1 << 1 => Self::Daddr,
            n if n == 1 << 2 => Self::Mark,
            n if n == 1 << 3 => Self::Iif,
            n if n == 1 << 4 => Self::Oif,
            n if n == 1 << 5 => Self::Present,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum RejectTypes {
    IcmpUnreach = 0,
    TcpRst = 1,
    IcmpxUnreach = 2,
}
impl RejectTypes {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::IcmpUnreach,
            1 => Self::TcpRst,
            2 => Self::IcmpxUnreach,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum PayloadBase {
    LinkLayerHeader = 0,
    NetworkHeader = 1,
    TransportHeader = 2,
    InnerHeader = 3,
    TunHeader = 4,
}
impl PayloadBase {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::LinkLayerHeader,
            1 => Self::NetworkHeader,
            2 => Self::TransportHeader,
            3 => Self::InnerHeader,
            4 => Self::TunHeader,
            _ => return None,
        })
    }
}
#[doc = "Range operator"]
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum RangeOps {
    Eq = 0,
    Neq = 1,
}
impl RangeOps {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Eq,
            1 => Self::Neq,
            _ => return None,
        })
    }
}
#[doc = "nf_tables registers.\nnf_tables used to have five registers: a verdict register and four data\nregisters of size 16. The data registers have been changed to 16 registers\nof size 4. For compatibility reasons, the NFT_REG_[1-4] registers still\nmap to areas of size 16, the 4 byte registers are addressed using\nNFT_REG32_00 - NFT_REG32_15.\n"]
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum Registers {
    RegVerdict = 0,
    Reg1 = 1,
    Reg2 = 2,
    Reg3 = 3,
    Reg4 = 4,
    Reg3200 = 8,
    Reg3201 = 9,
    Reg3202 = 10,
    Reg3203 = 11,
    Reg3204 = 12,
    Reg3205 = 13,
    Reg3206 = 14,
    Reg3207 = 15,
    Reg3208 = 16,
    Reg3209 = 17,
    Reg3210 = 18,
    Reg3211 = 19,
    Reg3212 = 20,
    Reg3213 = 21,
    Reg3214 = 22,
    Reg3215 = 23,
}
impl Registers {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::RegVerdict,
            1 => Self::Reg1,
            2 => Self::Reg2,
            3 => Self::Reg3,
            4 => Self::Reg4,
            8 => Self::Reg3200,
            9 => Self::Reg3201,
            10 => Self::Reg3202,
            11 => Self::Reg3203,
            12 => Self::Reg3204,
            13 => Self::Reg3205,
            14 => Self::Reg3206,
            15 => Self::Reg3207,
            16 => Self::Reg3208,
            17 => Self::Reg3209,
            18 => Self::Reg3210,
            19 => Self::Reg3211,
            20 => Self::Reg3212,
            21 => Self::Reg3213,
            22 => Self::Reg3214,
            23 => Self::Reg3215,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum NumgenTypes {
    Incremental = 0,
    Random = 1,
}
impl NumgenTypes {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Incremental,
            1 => Self::Random,
            _ => return None,
        })
    }
}
#[doc = "nf_tables log levels"]
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum LogLevel {
    #[doc = "system is unusable"]
    Emerg = 0,
    #[doc = "action must be taken immediately"]
    Alert = 1,
    #[doc = "critical conditions"]
    Crit = 2,
    #[doc = "error conditions"]
    Err = 3,
    #[doc = "warning conditions"]
    Warning = 4,
    #[doc = "normal but significant condition"]
    Notice = 5,
    #[doc = "informational"]
    Info = 6,
    #[doc = "debug-level messages"]
    Debug = 7,
    #[doc = "enabling audit logging"]
    Audit = 8,
}
impl LogLevel {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Emerg,
            1 => Self::Alert,
            2 => Self::Crit,
            3 => Self::Err,
            4 => Self::Warning,
            5 => Self::Notice,
            6 => Self::Info,
            7 => Self::Debug,
            8 => Self::Audit,
            _ => return None,
        })
    }
}
#[doc = "nf_tables log flags"]
#[doc = "Flags - defines an integer enumeration, with values for each entry occupying a bit, starting from bit 0, (e.g. 1, 2, 4, 8)"]
#[derive(Debug, Clone, Copy)]
pub enum LogFlags {
    #[doc = "Log TCP sequence numbers"]
    Tcpseq = 1 << 0,
    #[doc = "Log TCP options"]
    Tcpopt = 1 << 1,
    #[doc = "Log IP options"]
    Ipopt = 1 << 2,
    #[doc = "Log UID owning local socket"]
    Uid = 1 << 3,
    #[doc = "Unsupported, don't reuse"]
    Nflog = 1 << 4,
    #[doc = "Decode MAC header"]
    Macdecode = 1 << 5,
}
impl LogFlags {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            n if n == 1 << 0 => Self::Tcpseq,
            n if n == 1 << 1 => Self::Tcpopt,
            n if n == 1 << 2 => Self::Ipopt,
            n if n == 1 << 3 => Self::Uid,
            n if n == 1 << 4 => Self::Nflog,
            n if n == 1 << 5 => Self::Macdecode,
            _ => return None,
        })
    }
}
#[derive(Clone)]
pub enum LogAttrs<'a> {
    #[doc = "netlink group to send messages to"]
    Group(u16),
    #[doc = "prefix to prepend to log messages"]
    Prefix(&'a CStr),
    #[doc = "length of payload to include in netlink message"]
    Snaplen(u32),
    #[doc = "queue threshold"]
    Qthreshold(u16),
    #[doc = "log level\nAssociated type: \"LogLevel\" (enum)"]
    Level(u32),
    #[doc = "logging flags\nAssociated type: \"LogFlags\" (enum)"]
    Flags(u32),
}
impl<'a> IterableLogAttrs<'a> {
    #[doc = "netlink group to send messages to"]
    pub fn get_group(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Group(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "LogAttrs",
            "Group",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "prefix to prepend to log messages"]
    pub fn get_prefix(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Prefix(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "LogAttrs",
            "Prefix",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "length of payload to include in netlink message"]
    pub fn get_snaplen(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Snaplen(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "LogAttrs",
            "Snaplen",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "queue threshold"]
    pub fn get_qthreshold(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Qthreshold(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "LogAttrs",
            "Qthreshold",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "log level\nAssociated type: \"LogLevel\" (enum)"]
    pub fn get_level(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Level(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "LogAttrs",
            "Level",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "logging flags\nAssociated type: \"LogFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let LogAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "LogAttrs",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> LogAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableLogAttrs<'a> {
        IterableLogAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Group",
            2u16 => "Prefix",
            3u16 => "Snaplen",
            4u16 => "Qthreshold",
            5u16 => "Level",
            6u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableLogAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableLogAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableLogAttrs<'a> {
    type Item = Result<LogAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => LogAttrs::Group({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => LogAttrs::Prefix({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => LogAttrs::Snaplen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => LogAttrs::Qthreshold({
                    let res = parse_be_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => LogAttrs::Level({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => LogAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "LogAttrs",
            r#type.and_then(|t| LogAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableLogAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("LogAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                LogAttrs::Group(val) => fmt.field("Group", &val),
                LogAttrs::Prefix(val) => fmt.field("Prefix", &val),
                LogAttrs::Snaplen(val) => fmt.field("Snaplen", &val),
                LogAttrs::Qthreshold(val) => fmt.field("Qthreshold", &val),
                LogAttrs::Level(val) => {
                    fmt.field("Level", &FormatEnum(val.into(), LogLevel::from_value))
                }
                LogAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), LogFlags::from_value))
                }
            };
        }
        fmt.finish()
    }
}
impl IterableLogAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("LogAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| LogAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                LogAttrs::Group(val) => {
                    if last_off == offset {
                        stack.push(("Group", last_off));
                        break;
                    }
                }
                LogAttrs::Prefix(val) => {
                    if last_off == offset {
                        stack.push(("Prefix", last_off));
                        break;
                    }
                }
                LogAttrs::Snaplen(val) => {
                    if last_off == offset {
                        stack.push(("Snaplen", last_off));
                        break;
                    }
                }
                LogAttrs::Qthreshold(val) => {
                    if last_off == offset {
                        stack.push(("Qthreshold", last_off));
                        break;
                    }
                }
                LogAttrs::Level(val) => {
                    if last_off == offset {
                        stack.push(("Level", last_off));
                        break;
                    }
                }
                LogAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("LogAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum NumgenAttrs {
    #[doc = "destination register\nAssociated type: \"Registers\" (enum)"]
    Dreg(u32),
    #[doc = "maximum counter value"]
    Modulus(u32),
    #[doc = "operation type\nAssociated type: \"NumgenTypes\" (enum)"]
    Type(u32),
    #[doc = "offset to be added to the counter"]
    Offset(u32),
}
impl<'a> IterableNumgenAttrs<'a> {
    #[doc = "destination register\nAssociated type: \"Registers\" (enum)"]
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NumgenAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "NumgenAttrs",
            "Dreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "maximum counter value"]
    pub fn get_modulus(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NumgenAttrs::Modulus(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "NumgenAttrs",
            "Modulus",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "operation type\nAssociated type: \"NumgenTypes\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NumgenAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "NumgenAttrs",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "offset to be added to the counter"]
    pub fn get_offset(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NumgenAttrs::Offset(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "NumgenAttrs",
            "Offset",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl NumgenAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableNumgenAttrs<'_> {
        IterableNumgenAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Modulus",
            3u16 => "Type",
            4u16 => "Offset",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableNumgenAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableNumgenAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableNumgenAttrs<'a> {
    type Item = Result<NumgenAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => NumgenAttrs::Dreg({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => NumgenAttrs::Modulus({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => NumgenAttrs::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => NumgenAttrs::Offset({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "NumgenAttrs",
            r#type.and_then(|t| NumgenAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableNumgenAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("NumgenAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                NumgenAttrs::Dreg(val) => {
                    fmt.field("Dreg", &FormatEnum(val.into(), Registers::from_value))
                }
                NumgenAttrs::Modulus(val) => fmt.field("Modulus", &val),
                NumgenAttrs::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), NumgenTypes::from_value))
                }
                NumgenAttrs::Offset(val) => fmt.field("Offset", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableNumgenAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("NumgenAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| NumgenAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                NumgenAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                NumgenAttrs::Modulus(val) => {
                    if last_off == offset {
                        stack.push(("Modulus", last_off));
                        break;
                    }
                }
                NumgenAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                NumgenAttrs::Offset(val) => {
                    if last_off == offset {
                        stack.push(("Offset", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("NumgenAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum RangeAttrs<'a> {
    #[doc = "source register of data to compare\nAssociated type: \"Registers\" (enum)"]
    Sreg(u32),
    #[doc = "cmp operation\nAssociated type: \"RangeOps\" (enum)"]
    Op(u32),
    #[doc = "data range from"]
    FromData(IterableDataAttrs<'a>),
    #[doc = "data range to"]
    ToData(IterableDataAttrs<'a>),
}
impl<'a> IterableRangeAttrs<'a> {
    #[doc = "source register of data to compare\nAssociated type: \"Registers\" (enum)"]
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RangeAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RangeAttrs",
            "Sreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "cmp operation\nAssociated type: \"RangeOps\" (enum)"]
    pub fn get_op(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RangeAttrs::Op(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RangeAttrs",
            "Op",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "data range from"]
    pub fn get_from_data(&self) -> Result<IterableDataAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RangeAttrs::FromData(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RangeAttrs",
            "FromData",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "data range to"]
    pub fn get_to_data(&self) -> Result<IterableDataAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RangeAttrs::ToData(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RangeAttrs",
            "ToData",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> RangeAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableRangeAttrs<'a> {
        IterableRangeAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Sreg",
            2u16 => "Op",
            3u16 => "FromData",
            4u16 => "ToData",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableRangeAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableRangeAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableRangeAttrs<'a> {
    type Item = Result<RangeAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => RangeAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => RangeAttrs::Op({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => RangeAttrs::FromData({
                    let res = Some(IterableDataAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => RangeAttrs::ToData({
                    let res = Some(IterableDataAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "RangeAttrs",
            r#type.and_then(|t| RangeAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableRangeAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("RangeAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                RangeAttrs::Sreg(val) => {
                    fmt.field("Sreg", &FormatEnum(val.into(), Registers::from_value))
                }
                RangeAttrs::Op(val) => {
                    fmt.field("Op", &FormatEnum(val.into(), RangeOps::from_value))
                }
                RangeAttrs::FromData(val) => fmt.field("FromData", &val),
                RangeAttrs::ToData(val) => fmt.field("ToData", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableRangeAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("RangeAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| RangeAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                RangeAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                RangeAttrs::Op(val) => {
                    if last_off == offset {
                        stack.push(("Op", last_off));
                        break;
                    }
                }
                RangeAttrs::FromData(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                RangeAttrs::ToData(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("RangeAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum BatchAttrs {
    #[doc = "generation ID for this changeset"]
    Genid(u32),
}
impl<'a> IterableBatchAttrs<'a> {
    #[doc = "generation ID for this changeset"]
    pub fn get_genid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let BatchAttrs::Genid(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "BatchAttrs",
            "Genid",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl BatchAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableBatchAttrs<'_> {
        IterableBatchAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Genid",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableBatchAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableBatchAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableBatchAttrs<'a> {
    type Item = Result<BatchAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => BatchAttrs::Genid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "BatchAttrs",
            r#type.and_then(|t| BatchAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableBatchAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("BatchAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                BatchAttrs::Genid(val) => fmt.field("Genid", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableBatchAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("BatchAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| BatchAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                BatchAttrs::Genid(val) => {
                    if last_off == offset {
                        stack.push(("Genid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("BatchAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum TableAttrs<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "owner of this table through netlink portID"]
    Owner(u32),
}
impl<'a> IterableTableAttrs<'a> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "TableAttrs",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "TableAttrs",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "TableAttrs",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "TableAttrs",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "TableAttrs",
            "Pad",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "TableAttrs",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "owner of this table through netlink portID"]
    pub fn get_owner(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let TableAttrs::Owner(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "TableAttrs",
            "Owner",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> TableAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableTableAttrs<'a> {
        IterableTableAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Flags",
            3u16 => "Use",
            4u16 => "Handle",
            5u16 => "Pad",
            6u16 => "Userdata",
            7u16 => "Owner",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableTableAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableTableAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableTableAttrs<'a> {
    type Item = Result<TableAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => TableAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => TableAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => TableAttrs::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => TableAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => TableAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => TableAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => TableAttrs::Owner({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "TableAttrs",
            r#type.and_then(|t| TableAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableTableAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("TableAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                TableAttrs::Name(val) => fmt.field("Name", &val),
                TableAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                TableAttrs::Use(val) => fmt.field("Use", &val),
                TableAttrs::Handle(val) => fmt.field("Handle", &val),
                TableAttrs::Pad(val) => fmt.field("Pad", &val),
                TableAttrs::Userdata(val) => fmt.field("Userdata", &val),
                TableAttrs::Owner(val) => fmt.field("Owner", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableTableAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("TableAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| TableAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                TableAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                TableAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                TableAttrs::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                TableAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                TableAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                TableAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                TableAttrs::Owner(val) => {
                    if last_off == offset {
                        stack.push(("Owner", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("TableAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ChainAttrs<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(IterableNftHookAttrs<'a>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(IterableNftCounterAttrs<'a>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableChainAttrs<'a> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ChainAttrs",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ChainAttrs",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ChainAttrs",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<IterableNftHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ChainAttrs",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ChainAttrs",
            "Policy",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ChainAttrs",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ChainAttrs",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<IterableNftCounterAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ChainAttrs",
            "Counters",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ChainAttrs",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ChainAttrs",
            "Id",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ChainAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ChainAttrs",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> ChainAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableChainAttrs<'a> {
        IterableChainAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Handle",
            3u16 => "Name",
            4u16 => "Hook",
            5u16 => "Policy",
            6u16 => "Use",
            7u16 => "Type",
            8u16 => "Counters",
            9u16 => "Flags",
            10u16 => "Id",
            11u16 => "Userdata",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableChainAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableChainAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableChainAttrs<'a> {
    type Item = Result<ChainAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ChainAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ChainAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ChainAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ChainAttrs::Hook({
                    let res = Some(IterableNftHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ChainAttrs::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ChainAttrs::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ChainAttrs::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ChainAttrs::Counters({
                    let res = Some(IterableNftCounterAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => ChainAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => ChainAttrs::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => ChainAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ChainAttrs",
            r#type.and_then(|t| ChainAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableChainAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ChainAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ChainAttrs::Table(val) => fmt.field("Table", &val),
                ChainAttrs::Handle(val) => fmt.field("Handle", &val),
                ChainAttrs::Name(val) => fmt.field("Name", &val),
                ChainAttrs::Hook(val) => fmt.field("Hook", &val),
                ChainAttrs::Policy(val) => fmt.field("Policy", &val),
                ChainAttrs::Use(val) => fmt.field("Use", &val),
                ChainAttrs::Type(val) => fmt.field("Type", &val),
                ChainAttrs::Counters(val) => fmt.field("Counters", &val),
                ChainAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                ChainAttrs::Id(val) => fmt.field("Id", &val),
                ChainAttrs::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableChainAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ChainAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ChainAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ChainAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                ChainAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                ChainAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                ChainAttrs::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                ChainAttrs::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                ChainAttrs::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                ChainAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                ChainAttrs::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                ChainAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                ChainAttrs::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                ChainAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ChainAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum CounterAttrs<'a> {
    Bytes(u64),
    Packets(u64),
    Pad(&'a [u8]),
}
impl<'a> IterableCounterAttrs<'a> {
    pub fn get_bytes(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CounterAttrs::Bytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CounterAttrs",
            "Bytes",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_packets(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CounterAttrs::Packets(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CounterAttrs",
            "Packets",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CounterAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CounterAttrs",
            "Pad",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> CounterAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableCounterAttrs<'a> {
        IterableCounterAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Bytes",
            2u16 => "Packets",
            3u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableCounterAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableCounterAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableCounterAttrs<'a> {
    type Item = Result<CounterAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CounterAttrs::Bytes({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CounterAttrs::Packets({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CounterAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "CounterAttrs",
            r#type.and_then(|t| CounterAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableCounterAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CounterAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CounterAttrs::Bytes(val) => fmt.field("Bytes", &val),
                CounterAttrs::Packets(val) => fmt.field("Packets", &val),
                CounterAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableCounterAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CounterAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CounterAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CounterAttrs::Bytes(val) => {
                    if last_off == offset {
                        stack.push(("Bytes", last_off));
                        break;
                    }
                }
                CounterAttrs::Packets(val) => {
                    if last_off == offset {
                        stack.push(("Packets", last_off));
                        break;
                    }
                }
                CounterAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CounterAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum NftHookAttrs<'a> {
    Num(u32),
    Priority(i32),
    #[doc = "net device name"]
    Dev(&'a CStr),
    #[doc = "list of net devices"]
    Devs(IterableHookDevAttrs<'a>),
}
impl<'a> IterableNftHookAttrs<'a> {
    pub fn get_num(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftHookAttrs::Num(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "NftHookAttrs",
            "Num",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_priority(&self) -> Result<i32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftHookAttrs::Priority(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "NftHookAttrs",
            "Priority",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "net device name"]
    pub fn get_dev(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftHookAttrs::Dev(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "NftHookAttrs",
            "Dev",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "list of net devices"]
    pub fn get_devs(&self) -> Result<IterableHookDevAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftHookAttrs::Devs(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "NftHookAttrs",
            "Devs",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> NftHookAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableNftHookAttrs<'a> {
        IterableNftHookAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Num",
            2u16 => "Priority",
            3u16 => "Dev",
            4u16 => "Devs",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableNftHookAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableNftHookAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableNftHookAttrs<'a> {
    type Item = Result<NftHookAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => NftHookAttrs::Num({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => NftHookAttrs::Priority({
                    let res = parse_be_i32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => NftHookAttrs::Dev({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => NftHookAttrs::Devs({
                    let res = Some(IterableHookDevAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "NftHookAttrs",
            r#type.and_then(|t| NftHookAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableNftHookAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("NftHookAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                NftHookAttrs::Num(val) => fmt.field("Num", &val),
                NftHookAttrs::Priority(val) => fmt.field("Priority", &val),
                NftHookAttrs::Dev(val) => fmt.field("Dev", &val),
                NftHookAttrs::Devs(val) => fmt.field("Devs", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableNftHookAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("NftHookAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| NftHookAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                NftHookAttrs::Num(val) => {
                    if last_off == offset {
                        stack.push(("Num", last_off));
                        break;
                    }
                }
                NftHookAttrs::Priority(val) => {
                    if last_off == offset {
                        stack.push(("Priority", last_off));
                        break;
                    }
                }
                NftHookAttrs::Dev(val) => {
                    if last_off == offset {
                        stack.push(("Dev", last_off));
                        break;
                    }
                }
                NftHookAttrs::Devs(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("NftHookAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum HookDevAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Name(&'a CStr),
}
impl<'a> IterableHookDevAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_name(&self) -> MultiAttrIterable<Self, HookDevAttrs<'a>, &'a CStr> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let HookDevAttrs::Name(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> HookDevAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableHookDevAttrs<'a> {
        IterableHookDevAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableHookDevAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableHookDevAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableHookDevAttrs<'a> {
    type Item = Result<HookDevAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => HookDevAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "HookDevAttrs",
            r#type.and_then(|t| HookDevAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableHookDevAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("HookDevAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                HookDevAttrs::Name(val) => fmt.field("Name", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableHookDevAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("HookDevAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| HookDevAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                HookDevAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("HookDevAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum NftCounterAttrs {
    Bytes(u64),
    Packets(u64),
}
impl<'a> IterableNftCounterAttrs<'a> {
    pub fn get_bytes(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftCounterAttrs::Bytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "NftCounterAttrs",
            "Bytes",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_packets(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let NftCounterAttrs::Packets(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "NftCounterAttrs",
            "Packets",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl NftCounterAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableNftCounterAttrs<'_> {
        IterableNftCounterAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Bytes",
            2u16 => "Packets",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableNftCounterAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableNftCounterAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableNftCounterAttrs<'a> {
    type Item = Result<NftCounterAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => NftCounterAttrs::Bytes({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => NftCounterAttrs::Packets({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "NftCounterAttrs",
            r#type.and_then(|t| NftCounterAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableNftCounterAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("NftCounterAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                NftCounterAttrs::Bytes(val) => fmt.field("Bytes", &val),
                NftCounterAttrs::Packets(val) => fmt.field("Packets", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableNftCounterAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("NftCounterAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| NftCounterAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                NftCounterAttrs::Bytes(val) => {
                    if last_off == offset {
                        stack.push(("Bytes", last_off));
                        break;
                    }
                }
                NftCounterAttrs::Packets(val) => {
                    if last_off == offset {
                        stack.push(("Packets", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("NftCounterAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum RuleAttrs<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(IterableExprListAttrs<'a>),
    #[doc = "compatibility specifications of the rule"]
    Compat(IterableRuleCompatAttrs<'a>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> IterableRuleAttrs<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleAttrs",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleAttrs",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleAttrs",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableExprListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleAttrs",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<IterableRuleCompatAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleAttrs",
            "Compat",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleAttrs",
            "Position",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleAttrs",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleAttrs",
            "Id",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleAttrs",
            "PositionId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleAttrs::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleAttrs",
            "ChainId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> RuleAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableRuleAttrs<'a> {
        IterableRuleAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Chain",
            3u16 => "Handle",
            4u16 => "Expressions",
            5u16 => "Compat",
            6u16 => "Position",
            7u16 => "Userdata",
            8u16 => "Id",
            9u16 => "PositionId",
            10u16 => "ChainId",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableRuleAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableRuleAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableRuleAttrs<'a> {
    type Item = Result<RuleAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => RuleAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => RuleAttrs::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => RuleAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => RuleAttrs::Expressions({
                    let res = Some(IterableExprListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => RuleAttrs::Compat({
                    let res = Some(IterableRuleCompatAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => RuleAttrs::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => RuleAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => RuleAttrs::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => RuleAttrs::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => RuleAttrs::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "RuleAttrs",
            r#type.and_then(|t| RuleAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableRuleAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("RuleAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                RuleAttrs::Table(val) => fmt.field("Table", &val),
                RuleAttrs::Chain(val) => fmt.field("Chain", &val),
                RuleAttrs::Handle(val) => fmt.field("Handle", &val),
                RuleAttrs::Expressions(val) => fmt.field("Expressions", &val),
                RuleAttrs::Compat(val) => fmt.field("Compat", &val),
                RuleAttrs::Position(val) => fmt.field("Position", &val),
                RuleAttrs::Userdata(val) => fmt.field("Userdata", &val),
                RuleAttrs::Id(val) => fmt.field("Id", &val),
                RuleAttrs::PositionId(val) => fmt.field("PositionId", &val),
                RuleAttrs::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableRuleAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("RuleAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| RuleAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                RuleAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                RuleAttrs::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                RuleAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                RuleAttrs::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                RuleAttrs::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                RuleAttrs::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                RuleAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                RuleAttrs::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                RuleAttrs::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                RuleAttrs::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("RuleAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum ExprListAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Elem(IterableExprAttrs<'a>),
}
impl<'a> IterableExprListAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_elem(&self) -> MultiAttrIterable<Self, ExprListAttrs<'a>, IterableExprAttrs<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let ExprListAttrs::Elem(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> ExprListAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableExprListAttrs<'a> {
        IterableExprListAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Elem",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprListAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprListAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprListAttrs<'a> {
    type Item = Result<ExprListAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprListAttrs::Elem({
                    let res = Some(IterableExprAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprListAttrs",
            r#type.and_then(|t| ExprListAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableExprListAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprListAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprListAttrs::Elem(val) => fmt.field("Elem", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprListAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprListAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprListAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprListAttrs::Elem(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprListAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum ExprAttrs<'a> {
    #[doc = "name of the expression type"]
    Name(&'a CStr),
    #[doc = "type specific data"]
    Data(ExprOps<'a>),
}
impl<'a> IterableExprAttrs<'a> {
    #[doc = "name of the expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprAttrs",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "type specific data"]
    pub fn get_data(&self) -> Result<ExprOps<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprAttrs",
            "Data",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
#[derive(Debug, Clone)]
pub enum ExprOps<'a> {
    Bitwise(IterableExprBitwiseAttrs<'a>),
    Cmp(IterableExprCmpAttrs<'a>),
    Counter(IterableExprCounterAttrs<'a>),
    Ct(IterableExprCtAttrs<'a>),
    Fib(IterableExprFibAttrs<'a>),
    FlowOffload(IterableExprFlowOffloadAttrs<'a>),
    Immediate(IterableExprImmediateAttrs<'a>),
    Lookup(IterableExprLookupAttrs<'a>),
    Meta(IterableExprMetaAttrs<'a>),
    Nat(IterableExprNatAttrs<'a>),
    Objref(IterableExprObjrefAttrs<'a>),
    Payload(IterableExprPayloadAttrs<'a>),
    Quota(IterableQuotaAttrs<'a>),
    Reject(IterableExprRejectAttrs<'a>),
    Target(IterableExprTargetAttrs<'a>),
    Tproxy(IterableExprTproxyAttrs<'a>),
    Match(IterableCompatMatchAttrs<'a>),
    Range(IterableRangeAttrs<'a>),
    Numgen(IterableNumgenAttrs<'a>),
    Log(IterableLogAttrs<'a>),
}
impl<'a> ExprOps<'a> {
    fn select_with_loc(selector: &'a CStr, buf: &'a [u8], loc: usize) -> Option<Self> {
        match selector.to_bytes() {
            b"bitwise" => Some(ExprOps::Bitwise(IterableExprBitwiseAttrs::with_loc(
                buf, loc,
            ))),
            b"cmp" => Some(ExprOps::Cmp(IterableExprCmpAttrs::with_loc(buf, loc))),
            b"counter" => Some(ExprOps::Counter(IterableExprCounterAttrs::with_loc(
                buf, loc,
            ))),
            b"ct" => Some(ExprOps::Ct(IterableExprCtAttrs::with_loc(buf, loc))),
            b"fib" => Some(ExprOps::Fib(IterableExprFibAttrs::with_loc(buf, loc))),
            b"flow_offload" => Some(ExprOps::FlowOffload(
                IterableExprFlowOffloadAttrs::with_loc(buf, loc),
            )),
            b"immediate" => Some(ExprOps::Immediate(IterableExprImmediateAttrs::with_loc(
                buf, loc,
            ))),
            b"lookup" => Some(ExprOps::Lookup(IterableExprLookupAttrs::with_loc(buf, loc))),
            b"meta" => Some(ExprOps::Meta(IterableExprMetaAttrs::with_loc(buf, loc))),
            b"nat" => Some(ExprOps::Nat(IterableExprNatAttrs::with_loc(buf, loc))),
            b"objref" => Some(ExprOps::Objref(IterableExprObjrefAttrs::with_loc(buf, loc))),
            b"payload" => Some(ExprOps::Payload(IterableExprPayloadAttrs::with_loc(
                buf, loc,
            ))),
            b"quota" => Some(ExprOps::Quota(IterableQuotaAttrs::with_loc(buf, loc))),
            b"reject" => Some(ExprOps::Reject(IterableExprRejectAttrs::with_loc(buf, loc))),
            b"target" => Some(ExprOps::Target(IterableExprTargetAttrs::with_loc(buf, loc))),
            b"tproxy" => Some(ExprOps::Tproxy(IterableExprTproxyAttrs::with_loc(buf, loc))),
            b"match" => Some(ExprOps::Match(IterableCompatMatchAttrs::with_loc(buf, loc))),
            b"range" => Some(ExprOps::Range(IterableRangeAttrs::with_loc(buf, loc))),
            b"numgen" => Some(ExprOps::Numgen(IterableNumgenAttrs::with_loc(buf, loc))),
            b"log" => Some(ExprOps::Log(IterableLogAttrs::with_loc(buf, loc))),
            _ => None,
        }
    }
}
impl<'a> ExprAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableExprAttrs<'a> {
        IterableExprAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Data",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprAttrs<'a> {
    type Item = Result<ExprAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprAttrs::Data({
                    let res = {
                        let Ok(selector) = self.get_name() else { break };
                        ExprOps::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprAttrs",
            r#type.and_then(|t| ExprAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableExprAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprAttrs::Name(val) => fmt.field("Name", &val),
                ExprAttrs::Data(val) => fmt.field("Data", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                ExprAttrs::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum RuleCompatAttrs {
    #[doc = "numeric value of the handled protocol"]
    Proto(u32),
    #[doc = "bitmask of flags"]
    Flags(u32),
}
impl<'a> IterableRuleCompatAttrs<'a> {
    #[doc = "numeric value of the handled protocol"]
    pub fn get_proto(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleCompatAttrs::Proto(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleCompatAttrs",
            "Proto",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "bitmask of flags"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let RuleCompatAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "RuleCompatAttrs",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl RuleCompatAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableRuleCompatAttrs<'_> {
        IterableRuleCompatAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Proto",
            2u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableRuleCompatAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableRuleCompatAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableRuleCompatAttrs<'a> {
    type Item = Result<RuleCompatAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => RuleCompatAttrs::Proto({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => RuleCompatAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "RuleCompatAttrs",
            r#type.and_then(|t| RuleCompatAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableRuleCompatAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("RuleCompatAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                RuleCompatAttrs::Proto(val) => fmt.field("Proto", &val),
                RuleCompatAttrs::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableRuleCompatAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("RuleCompatAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| RuleCompatAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                RuleCompatAttrs::Proto(val) => {
                    if last_off == offset {
                        stack.push(("Proto", last_off));
                        break;
                    }
                }
                RuleCompatAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("RuleCompatAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum SetAttrs<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(IterableSetDescAttrs<'a>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    Pad(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(IterableExprAttrs<'a>),
    #[doc = "list of expressions"]
    Expressions(IterableSetListAttrs<'a>),
    #[doc = "set backend type"]
    Type(&'a CStr),
    #[doc = "number of set elements"]
    Count(u32),
}
impl<'a> IterableSetAttrs<'a> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "KeyType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "KeyLen",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "DataType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "DataLen",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Policy",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<IterableSetDescAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Desc",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Id",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Timeout",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "GcInterval",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Pad",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "ObjType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(&self) -> MultiAttrIterable<Self, SetAttrs<'a>, IterableExprAttrs<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let SetAttrs::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableSetListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set backend type"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "number of set elements"]
    pub fn get_count(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetAttrs::Count(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetAttrs",
            "Count",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> SetAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableSetAttrs<'a> {
        IterableSetAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Name",
            3u16 => "Flags",
            4u16 => "KeyType",
            5u16 => "KeyLen",
            6u16 => "DataType",
            7u16 => "DataLen",
            8u16 => "Policy",
            9u16 => "Desc",
            10u16 => "Id",
            11u16 => "Timeout",
            12u16 => "GcInterval",
            13u16 => "Userdata",
            14u16 => "Pad",
            15u16 => "ObjType",
            16u16 => "Handle",
            17u16 => "Expr",
            18u16 => "Expressions",
            19u16 => "Type",
            20u16 => "Count",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableSetAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableSetAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableSetAttrs<'a> {
    type Item = Result<SetAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => SetAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => SetAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => SetAttrs::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => SetAttrs::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => SetAttrs::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => SetAttrs::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => SetAttrs::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => SetAttrs::Desc({
                    let res = Some(IterableSetDescAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => SetAttrs::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => SetAttrs::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => SetAttrs::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => SetAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => SetAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => SetAttrs::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => SetAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => SetAttrs::Expr({
                    let res = Some(IterableExprAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => SetAttrs::Expressions({
                    let res = Some(IterableSetListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                19u16 => SetAttrs::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                20u16 => SetAttrs::Count({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "SetAttrs",
            r#type.and_then(|t| SetAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableSetAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetAttrs::Table(val) => fmt.field("Table", &val),
                SetAttrs::Name(val) => fmt.field("Name", &val),
                SetAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                SetAttrs::KeyType(val) => fmt.field("KeyType", &val),
                SetAttrs::KeyLen(val) => fmt.field("KeyLen", &val),
                SetAttrs::DataType(val) => fmt.field("DataType", &val),
                SetAttrs::DataLen(val) => fmt.field("DataLen", &val),
                SetAttrs::Policy(val) => fmt.field("Policy", &val),
                SetAttrs::Desc(val) => fmt.field("Desc", &val),
                SetAttrs::Id(val) => fmt.field("Id", &val),
                SetAttrs::Timeout(val) => fmt.field("Timeout", &val),
                SetAttrs::GcInterval(val) => fmt.field("GcInterval", &val),
                SetAttrs::Userdata(val) => fmt.field("Userdata", &val),
                SetAttrs::Pad(val) => fmt.field("Pad", &val),
                SetAttrs::ObjType(val) => fmt.field("ObjType", &val),
                SetAttrs::Handle(val) => fmt.field("Handle", &val),
                SetAttrs::Expr(val) => fmt.field("Expr", &val),
                SetAttrs::Expressions(val) => fmt.field("Expressions", &val),
                SetAttrs::Type(val) => fmt.field("Type", &val),
                SetAttrs::Count(val) => fmt.field("Count", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableSetAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                SetAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                SetAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                SetAttrs::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                SetAttrs::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                SetAttrs::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                SetAttrs::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                SetAttrs::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                SetAttrs::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetAttrs::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                SetAttrs::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                SetAttrs::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                SetAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                SetAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                SetAttrs::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                SetAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                SetAttrs::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetAttrs::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                SetAttrs::Count(val) => {
                    if last_off == offset {
                        stack.push(("Count", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum SetDescAttrs<'a> {
    #[doc = "number of elements in set"]
    Size(u32),
    #[doc = "description of field concatenation\nAttribute may repeat multiple times (treat it as array)"]
    Concat(IterableSetDescConcatAttrs<'a>),
}
impl<'a> IterableSetDescAttrs<'a> {
    #[doc = "number of elements in set"]
    pub fn get_size(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetDescAttrs::Size(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetDescAttrs",
            "Size",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "description of field concatenation\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_concat(
        &self,
    ) -> MultiAttrIterable<Self, SetDescAttrs<'a>, IterableSetDescConcatAttrs<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let SetDescAttrs::Concat(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> SetDescAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableSetDescAttrs<'a> {
        IterableSetDescAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Size",
            2u16 => "Concat",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableSetDescAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableSetDescAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableSetDescAttrs<'a> {
    type Item = Result<SetDescAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetDescAttrs::Size({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => SetDescAttrs::Concat({
                    let res = Some(IterableSetDescConcatAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "SetDescAttrs",
            r#type.and_then(|t| SetDescAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableSetDescAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetDescAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetDescAttrs::Size(val) => fmt.field("Size", &val),
                SetDescAttrs::Concat(val) => fmt.field("Concat", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableSetDescAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetDescAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetDescAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetDescAttrs::Size(val) => {
                    if last_off == offset {
                        stack.push(("Size", last_off));
                        break;
                    }
                }
                SetDescAttrs::Concat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetDescAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum SetDescConcatAttrs<'a> {
    Elem(IterableSetFieldAttrs<'a>),
}
impl<'a> IterableSetDescConcatAttrs<'a> {
    pub fn get_elem(&self) -> Result<IterableSetFieldAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetDescConcatAttrs::Elem(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetDescConcatAttrs",
            "Elem",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> SetDescConcatAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableSetDescConcatAttrs<'a> {
        IterableSetDescConcatAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Elem",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableSetDescConcatAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableSetDescConcatAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableSetDescConcatAttrs<'a> {
    type Item = Result<SetDescConcatAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetDescConcatAttrs::Elem({
                    let res = Some(IterableSetFieldAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "SetDescConcatAttrs",
            r#type.and_then(|t| SetDescConcatAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableSetDescConcatAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetDescConcatAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetDescConcatAttrs::Elem(val) => fmt.field("Elem", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableSetDescConcatAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetDescConcatAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetDescConcatAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetDescConcatAttrs::Elem(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetDescConcatAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum SetFieldAttrs {
    Len(u32),
}
impl<'a> IterableSetFieldAttrs<'a> {
    pub fn get_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetFieldAttrs::Len(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetFieldAttrs",
            "Len",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl SetFieldAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableSetFieldAttrs<'_> {
        IterableSetFieldAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Len",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableSetFieldAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableSetFieldAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableSetFieldAttrs<'a> {
    type Item = Result<SetFieldAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetFieldAttrs::Len({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "SetFieldAttrs",
            r#type.and_then(|t| SetFieldAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableSetFieldAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetFieldAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetFieldAttrs::Len(val) => fmt.field("Len", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableSetFieldAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetFieldAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetFieldAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetFieldAttrs::Len(val) => {
                    if last_off == offset {
                        stack.push(("Len", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetFieldAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum SetListAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Elem(IterableExprAttrs<'a>),
}
impl<'a> IterableSetListAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_elem(&self) -> MultiAttrIterable<Self, SetListAttrs<'a>, IterableExprAttrs<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let SetListAttrs::Elem(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> SetListAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableSetListAttrs<'a> {
        IterableSetListAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Elem",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableSetListAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableSetListAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableSetListAttrs<'a> {
    type Item = Result<SetListAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetListAttrs::Elem({
                    let res = Some(IterableExprAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "SetListAttrs",
            r#type.and_then(|t| SetListAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableSetListAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetListAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetListAttrs::Elem(val) => fmt.field("Elem", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableSetListAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetListAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetListAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetListAttrs::Elem(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetListAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum SetelemAttrs<'a> {
    #[doc = "key value"]
    Key(IterableDataAttrs<'a>),
    #[doc = "data value of mapping"]
    Data(IterableDataAttrs<'a>),
    #[doc = "bitmask of nft_set_elem_flags\nAssociated type: \"SetElemFlags\" (enum)"]
    Flags(u32),
    #[doc = "timeout value"]
    Timeout(u64),
    #[doc = "expiration time"]
    Expiration(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "expression"]
    Expr(IterableExprAttrs<'a>),
    #[doc = "stateful object reference"]
    Objref(&'a CStr),
    #[doc = "closing key value"]
    KeyEnd(IterableDataAttrs<'a>),
    #[doc = "list of expressions"]
    Expressions(IterableExprListAttrs<'a>),
}
impl<'a> IterableSetelemAttrs<'a> {
    #[doc = "key value"]
    pub fn get_key(&self) -> Result<IterableDataAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Key(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemAttrs",
            "Key",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "data value of mapping"]
    pub fn get_data(&self) -> Result<IterableDataAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemAttrs",
            "Data",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "bitmask of nft_set_elem_flags\nAssociated type: \"SetElemFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemAttrs",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemAttrs",
            "Timeout",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "expiration time"]
    pub fn get_expiration(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Expiration(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemAttrs",
            "Expiration",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemAttrs",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "expression"]
    pub fn get_expr(&self) -> Result<IterableExprAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Expr(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemAttrs",
            "Expr",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object reference"]
    pub fn get_objref(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Objref(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemAttrs",
            "Objref",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "closing key value"]
    pub fn get_key_end(&self) -> Result<IterableDataAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::KeyEnd(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemAttrs",
            "KeyEnd",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableExprListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemAttrs::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemAttrs",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> SetelemAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableSetelemAttrs<'a> {
        IterableSetelemAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Key",
            2u16 => "Data",
            3u16 => "Flags",
            4u16 => "Timeout",
            5u16 => "Expiration",
            6u16 => "Userdata",
            7u16 => "Expr",
            8u16 => "Objref",
            9u16 => "KeyEnd",
            10u16 => "Expressions",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableSetelemAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableSetelemAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableSetelemAttrs<'a> {
    type Item = Result<SetelemAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetelemAttrs::Key({
                    let res = Some(IterableDataAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => SetelemAttrs::Data({
                    let res = Some(IterableDataAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => SetelemAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => SetelemAttrs::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => SetelemAttrs::Expiration({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => SetelemAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => SetelemAttrs::Expr({
                    let res = Some(IterableExprAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => SetelemAttrs::Objref({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => SetelemAttrs::KeyEnd({
                    let res = Some(IterableDataAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => SetelemAttrs::Expressions({
                    let res = Some(IterableExprListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "SetelemAttrs",
            r#type.and_then(|t| SetelemAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableSetelemAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetelemAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetelemAttrs::Key(val) => fmt.field("Key", &val),
                SetelemAttrs::Data(val) => fmt.field("Data", &val),
                SetelemAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetElemFlags::from_value))
                }
                SetelemAttrs::Timeout(val) => fmt.field("Timeout", &val),
                SetelemAttrs::Expiration(val) => fmt.field("Expiration", &val),
                SetelemAttrs::Userdata(val) => fmt.field("Userdata", &val),
                SetelemAttrs::Expr(val) => fmt.field("Expr", &val),
                SetelemAttrs::Objref(val) => fmt.field("Objref", &val),
                SetelemAttrs::KeyEnd(val) => fmt.field("KeyEnd", &val),
                SetelemAttrs::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableSetelemAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetelemAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetelemAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetelemAttrs::Key(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetelemAttrs::Data(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetelemAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                SetelemAttrs::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                SetelemAttrs::Expiration(val) => {
                    if last_off == offset {
                        stack.push(("Expiration", last_off));
                        break;
                    }
                }
                SetelemAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                SetelemAttrs::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetelemAttrs::Objref(val) => {
                    if last_off == offset {
                        stack.push(("Objref", last_off));
                        break;
                    }
                }
                SetelemAttrs::KeyEnd(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetelemAttrs::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetelemAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum SetelemListElemAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Elem(IterableSetelemAttrs<'a>),
}
impl<'a> IterableSetelemListElemAttrs<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_elem(
        &self,
    ) -> MultiAttrIterable<Self, SetelemListElemAttrs<'a>, IterableSetelemAttrs<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let SetelemListElemAttrs::Elem(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl<'a> SetelemListElemAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableSetelemListElemAttrs<'a> {
        IterableSetelemListElemAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Elem",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableSetelemListElemAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableSetelemListElemAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableSetelemListElemAttrs<'a> {
    type Item = Result<SetelemListElemAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetelemListElemAttrs::Elem({
                    let res = Some(IterableSetelemAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "SetelemListElemAttrs",
            r#type.and_then(|t| SetelemListElemAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableSetelemListElemAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetelemListElemAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetelemListElemAttrs::Elem(val) => fmt.field("Elem", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableSetelemListElemAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetelemListElemAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetelemListElemAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetelemListElemAttrs::Elem(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetelemListElemAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum SetelemListAttrs<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(IterableSetelemListElemAttrs<'a>),
    SetId(u32),
}
impl<'a> IterableSetelemListAttrs<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemListAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemListAttrs",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemListAttrs::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemListAttrs",
            "Set",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_elements(&self) -> Result<IterableSetelemListElemAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemListAttrs::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemListAttrs",
            "Elements",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let SetelemListAttrs::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "SetelemListAttrs",
            "SetId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> SetelemListAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableSetelemListAttrs<'a> {
        IterableSetelemListAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Set",
            3u16 => "Elements",
            4u16 => "SetId",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableSetelemListAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableSetelemListAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableSetelemListAttrs<'a> {
    type Item = Result<SetelemListAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => SetelemListAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => SetelemListAttrs::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => SetelemListAttrs::Elements({
                    let res = Some(IterableSetelemListElemAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => SetelemListAttrs::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "SetelemListAttrs",
            r#type.and_then(|t| SetelemListAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableSetelemListAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("SetelemListAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                SetelemListAttrs::Table(val) => fmt.field("Table", &val),
                SetelemListAttrs::Set(val) => fmt.field("Set", &val),
                SetelemListAttrs::Elements(val) => fmt.field("Elements", &val),
                SetelemListAttrs::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableSetelemListAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("SetelemListAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| SetelemListAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                SetelemListAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                SetelemListAttrs::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                SetelemListAttrs::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                SetelemListAttrs::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("SetelemListAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum GenAttrs<'a> {
    #[doc = "ruleset generation id"]
    Id(u32),
    ProcPid(u32),
    ProcName(&'a CStr),
}
impl<'a> IterableGenAttrs<'a> {
    #[doc = "ruleset generation id"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GenAttrs::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "GenAttrs",
            "Id",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_proc_pid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GenAttrs::ProcPid(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "GenAttrs",
            "ProcPid",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_proc_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let GenAttrs::ProcName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "GenAttrs",
            "ProcName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> GenAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableGenAttrs<'a> {
        IterableGenAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Id",
            2u16 => "ProcPid",
            3u16 => "ProcName",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableGenAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableGenAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableGenAttrs<'a> {
    type Item = Result<GenAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => GenAttrs::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => GenAttrs::ProcPid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => GenAttrs::ProcName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "GenAttrs",
            r#type.and_then(|t| GenAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableGenAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("GenAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                GenAttrs::Id(val) => fmt.field("Id", &val),
                GenAttrs::ProcPid(val) => fmt.field("ProcPid", &val),
                GenAttrs::ProcName(val) => fmt.field("ProcName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableGenAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("GenAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| GenAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                GenAttrs::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                GenAttrs::ProcPid(val) => {
                    if last_off == offset {
                        stack.push(("ProcPid", last_off));
                        break;
                    }
                }
                GenAttrs::ProcName(val) => {
                    if last_off == offset {
                        stack.push(("ProcName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("GenAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ObjAttrs<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    Pad(&'a [u8]),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableObjAttrs<'a> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ObjAttrs",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ObjAttrs",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ObjAttrs",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ObjAttrs",
            "Data",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ObjAttrs",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ObjAttrs",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ObjAttrs",
            "Pad",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ObjAttrs::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ObjAttrs",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
#[derive(Debug, Clone)]
pub enum ObjData<'a> {
    Counter(IterableCounterAttrs<'a>),
    Quota(IterableQuotaAttrs<'a>),
}
impl<'a> ObjData<'a> {
    fn select_with_loc(selector: u32, buf: &'a [u8], loc: usize) -> Option<Self> {
        match selector {
            val if val == ObjectType::Counter as u32 => {
                Some(ObjData::Counter(IterableCounterAttrs::with_loc(buf, loc)))
            }
            val if val == ObjectType::Quota as u32 => {
                Some(ObjData::Quota(IterableQuotaAttrs::with_loc(buf, loc)))
            }
            _ => None,
        }
    }
}
impl<'a> ObjAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableObjAttrs<'a> {
        IterableObjAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Name",
            3u16 => "Type",
            4u16 => "Data",
            5u16 => "Use",
            6u16 => "Handle",
            7u16 => "Pad",
            8u16 => "Userdata",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableObjAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableObjAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableObjAttrs<'a> {
    type Item = Result<ObjAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ObjAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ObjAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ObjAttrs::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ObjAttrs::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ObjAttrs::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ObjAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ObjAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ObjAttrs::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ObjAttrs",
            r#type.and_then(|t| ObjAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableObjAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ObjAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ObjAttrs::Table(val) => fmt.field("Table", &val),
                ObjAttrs::Name(val) => fmt.field("Name", &val),
                ObjAttrs::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                ObjAttrs::Data(val) => fmt.field("Data", &val),
                ObjAttrs::Use(val) => fmt.field("Use", &val),
                ObjAttrs::Handle(val) => fmt.field("Handle", &val),
                ObjAttrs::Pad(val) => fmt.field("Pad", &val),
                ObjAttrs::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableObjAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ObjAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ObjAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ObjAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                ObjAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                ObjAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                ObjAttrs::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                ObjAttrs::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                ObjAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                ObjAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                ObjAttrs::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ObjAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum QuotaAttrs<'a> {
    Bytes(u64),
    #[doc = "Associated type: \"QuotaFlags\" (enum)"]
    Flags(u32),
    Pad(&'a [u8]),
    Consumed(u64),
}
impl<'a> IterableQuotaAttrs<'a> {
    pub fn get_bytes(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let QuotaAttrs::Bytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "QuotaAttrs",
            "Bytes",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"QuotaFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let QuotaAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "QuotaAttrs",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let QuotaAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "QuotaAttrs",
            "Pad",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_consumed(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let QuotaAttrs::Consumed(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "QuotaAttrs",
            "Consumed",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> QuotaAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableQuotaAttrs<'a> {
        IterableQuotaAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Bytes",
            2u16 => "Flags",
            3u16 => "Pad",
            4u16 => "Consumed",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableQuotaAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableQuotaAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableQuotaAttrs<'a> {
    type Item = Result<QuotaAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => QuotaAttrs::Bytes({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => QuotaAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => QuotaAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => QuotaAttrs::Consumed({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "QuotaAttrs",
            r#type.and_then(|t| QuotaAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableQuotaAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("QuotaAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                QuotaAttrs::Bytes(val) => fmt.field("Bytes", &val),
                QuotaAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), QuotaFlags::from_value))
                }
                QuotaAttrs::Pad(val) => fmt.field("Pad", &val),
                QuotaAttrs::Consumed(val) => fmt.field("Consumed", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableQuotaAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("QuotaAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| QuotaAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                QuotaAttrs::Bytes(val) => {
                    if last_off == offset {
                        stack.push(("Bytes", last_off));
                        break;
                    }
                }
                QuotaAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                QuotaAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                QuotaAttrs::Consumed(val) => {
                    if last_off == offset {
                        stack.push(("Consumed", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("QuotaAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum FlowtableAttrs<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(IterableFlowtableHookAttrs<'a>),
    Use(u32),
    Handle(u64),
    Pad(&'a [u8]),
    Flags(u32),
}
impl<'a> IterableFlowtableAttrs<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "FlowtableAttrs",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "FlowtableAttrs",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_hook(&self) -> Result<IterableFlowtableHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "FlowtableAttrs",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "FlowtableAttrs",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "FlowtableAttrs",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "FlowtableAttrs",
            "Pad",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "FlowtableAttrs",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> FlowtableAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableFlowtableAttrs<'a> {
        IterableFlowtableAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Table",
            2u16 => "Name",
            3u16 => "Hook",
            4u16 => "Use",
            5u16 => "Handle",
            6u16 => "Pad",
            7u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableFlowtableAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableFlowtableAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableFlowtableAttrs<'a> {
    type Item = Result<FlowtableAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowtableAttrs::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowtableAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FlowtableAttrs::Hook({
                    let res = Some(IterableFlowtableHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => FlowtableAttrs::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => FlowtableAttrs::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => FlowtableAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => FlowtableAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "FlowtableAttrs",
            r#type.and_then(|t| FlowtableAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableFlowtableAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowtableAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowtableAttrs::Table(val) => fmt.field("Table", &val),
                FlowtableAttrs::Name(val) => fmt.field("Name", &val),
                FlowtableAttrs::Hook(val) => fmt.field("Hook", &val),
                FlowtableAttrs::Use(val) => fmt.field("Use", &val),
                FlowtableAttrs::Handle(val) => fmt.field("Handle", &val),
                FlowtableAttrs::Pad(val) => fmt.field("Pad", &val),
                FlowtableAttrs::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableFlowtableAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowtableAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowtableAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowtableAttrs::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                FlowtableAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                FlowtableAttrs::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                FlowtableAttrs::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                FlowtableAttrs::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                FlowtableAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                FlowtableAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowtableAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum FlowtableHookAttrs<'a> {
    Num(u32),
    Priority(u32),
    Devs(IterableHookDevAttrs<'a>),
}
impl<'a> IterableFlowtableHookAttrs<'a> {
    pub fn get_num(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableHookAttrs::Num(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "FlowtableHookAttrs",
            "Num",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_priority(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableHookAttrs::Priority(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "FlowtableHookAttrs",
            "Priority",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_devs(&self) -> Result<IterableHookDevAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let FlowtableHookAttrs::Devs(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "FlowtableHookAttrs",
            "Devs",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> FlowtableHookAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableFlowtableHookAttrs<'a> {
        IterableFlowtableHookAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Num",
            2u16 => "Priority",
            3u16 => "Devs",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableFlowtableHookAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableFlowtableHookAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableFlowtableHookAttrs<'a> {
    type Item = Result<FlowtableHookAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => FlowtableHookAttrs::Num({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => FlowtableHookAttrs::Priority({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => FlowtableHookAttrs::Devs({
                    let res = Some(IterableHookDevAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "FlowtableHookAttrs",
            r#type.and_then(|t| FlowtableHookAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableFlowtableHookAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("FlowtableHookAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                FlowtableHookAttrs::Num(val) => fmt.field("Num", &val),
                FlowtableHookAttrs::Priority(val) => fmt.field("Priority", &val),
                FlowtableHookAttrs::Devs(val) => fmt.field("Devs", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableFlowtableHookAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("FlowtableHookAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| FlowtableHookAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                FlowtableHookAttrs::Num(val) => {
                    if last_off == offset {
                        stack.push(("Num", last_off));
                        break;
                    }
                }
                FlowtableHookAttrs::Priority(val) => {
                    if last_off == offset {
                        stack.push(("Priority", last_off));
                        break;
                    }
                }
                FlowtableHookAttrs::Devs(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("FlowtableHookAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum ExprBitwiseAttrs<'a> {
    Sreg(u32),
    Dreg(u32),
    Len(u32),
    Mask(IterableDataAttrs<'a>),
    Xor(IterableDataAttrs<'a>),
    #[doc = "Associated type: \"BitwiseOps\" (enum)"]
    Op(u32),
    Data(IterableDataAttrs<'a>),
    Sreg2(u32),
}
impl<'a> IterableExprBitwiseAttrs<'a> {
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprBitwiseAttrs",
            "Sreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprBitwiseAttrs",
            "Dreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Len(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprBitwiseAttrs",
            "Len",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_mask(&self) -> Result<IterableDataAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Mask(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprBitwiseAttrs",
            "Mask",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_xor(&self) -> Result<IterableDataAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Xor(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprBitwiseAttrs",
            "Xor",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"BitwiseOps\" (enum)"]
    pub fn get_op(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Op(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprBitwiseAttrs",
            "Op",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_data(&self) -> Result<IterableDataAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprBitwiseAttrs",
            "Data",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sreg2(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprBitwiseAttrs::Sreg2(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprBitwiseAttrs",
            "Sreg2",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> ExprBitwiseAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableExprBitwiseAttrs<'a> {
        IterableExprBitwiseAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Sreg",
            2u16 => "Dreg",
            3u16 => "Len",
            4u16 => "Mask",
            5u16 => "Xor",
            6u16 => "Op",
            7u16 => "Data",
            8u16 => "Sreg2",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprBitwiseAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprBitwiseAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprBitwiseAttrs<'a> {
    type Item = Result<ExprBitwiseAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprBitwiseAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprBitwiseAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprBitwiseAttrs::Len({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprBitwiseAttrs::Mask({
                    let res = Some(IterableDataAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ExprBitwiseAttrs::Xor({
                    let res = Some(IterableDataAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ExprBitwiseAttrs::Op({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ExprBitwiseAttrs::Data({
                    let res = Some(IterableDataAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ExprBitwiseAttrs::Sreg2({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprBitwiseAttrs",
            r#type.and_then(|t| ExprBitwiseAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableExprBitwiseAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprBitwiseAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprBitwiseAttrs::Sreg(val) => fmt.field("Sreg", &val),
                ExprBitwiseAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprBitwiseAttrs::Len(val) => fmt.field("Len", &val),
                ExprBitwiseAttrs::Mask(val) => fmt.field("Mask", &val),
                ExprBitwiseAttrs::Xor(val) => fmt.field("Xor", &val),
                ExprBitwiseAttrs::Op(val) => {
                    fmt.field("Op", &FormatEnum(val.into(), BitwiseOps::from_value))
                }
                ExprBitwiseAttrs::Data(val) => fmt.field("Data", &val),
                ExprBitwiseAttrs::Sreg2(val) => fmt.field("Sreg2", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprBitwiseAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprBitwiseAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprBitwiseAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprBitwiseAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                ExprBitwiseAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprBitwiseAttrs::Len(val) => {
                    if last_off == offset {
                        stack.push(("Len", last_off));
                        break;
                    }
                }
                ExprBitwiseAttrs::Mask(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                ExprBitwiseAttrs::Xor(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                ExprBitwiseAttrs::Op(val) => {
                    if last_off == offset {
                        stack.push(("Op", last_off));
                        break;
                    }
                }
                ExprBitwiseAttrs::Data(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                ExprBitwiseAttrs::Sreg2(val) => {
                    if last_off == offset {
                        stack.push(("Sreg2", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprBitwiseAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum ExprCmpAttrs<'a> {
    Sreg(u32),
    #[doc = "Associated type: \"CmpOps\" (enum)"]
    Op(u32),
    Data(IterableDataAttrs<'a>),
}
impl<'a> IterableExprCmpAttrs<'a> {
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCmpAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprCmpAttrs",
            "Sreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"CmpOps\" (enum)"]
    pub fn get_op(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCmpAttrs::Op(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprCmpAttrs",
            "Op",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_data(&self) -> Result<IterableDataAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCmpAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprCmpAttrs",
            "Data",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> ExprCmpAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableExprCmpAttrs<'a> {
        IterableExprCmpAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Sreg",
            2u16 => "Op",
            3u16 => "Data",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprCmpAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprCmpAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprCmpAttrs<'a> {
    type Item = Result<ExprCmpAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprCmpAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprCmpAttrs::Op({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprCmpAttrs::Data({
                    let res = Some(IterableDataAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprCmpAttrs",
            r#type.and_then(|t| ExprCmpAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableExprCmpAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprCmpAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprCmpAttrs::Sreg(val) => fmt.field("Sreg", &val),
                ExprCmpAttrs::Op(val) => {
                    fmt.field("Op", &FormatEnum(val.into(), CmpOps::from_value))
                }
                ExprCmpAttrs::Data(val) => fmt.field("Data", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprCmpAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprCmpAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprCmpAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprCmpAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                ExprCmpAttrs::Op(val) => {
                    if last_off == offset {
                        stack.push(("Op", last_off));
                        break;
                    }
                }
                ExprCmpAttrs::Data(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprCmpAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DataAttrs<'a> {
    Value(&'a [u8]),
    Verdict(IterableVerdictAttrs<'a>),
}
impl<'a> IterableDataAttrs<'a> {
    pub fn get_value(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DataAttrs::Value(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DataAttrs",
            "Value",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_verdict(&self) -> Result<IterableVerdictAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DataAttrs::Verdict(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DataAttrs",
            "Verdict",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> DataAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableDataAttrs<'a> {
        IterableDataAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Value",
            2u16 => "Verdict",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDataAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDataAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDataAttrs<'a> {
    type Item = Result<DataAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => DataAttrs::Value({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => DataAttrs::Verdict({
                    let res = Some(IterableVerdictAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DataAttrs",
            r#type.and_then(|t| DataAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDataAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DataAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DataAttrs::Value(val) => fmt.field("Value", &val),
                DataAttrs::Verdict(val) => fmt.field("Verdict", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDataAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DataAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| DataAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DataAttrs::Value(val) => {
                    if last_off == offset {
                        stack.push(("Value", last_off));
                        break;
                    }
                }
                DataAttrs::Verdict(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DataAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum VerdictAttrs<'a> {
    #[doc = "nf_tables verdict\nAssociated type: \"VerdictCode\" (enum)"]
    Code(u32),
    #[doc = "jump target chain name"]
    Chain(&'a CStr),
    #[doc = "jump target chain ID"]
    ChainId(u32),
}
impl<'a> IterableVerdictAttrs<'a> {
    #[doc = "nf_tables verdict\nAssociated type: \"VerdictCode\" (enum)"]
    pub fn get_code(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let VerdictAttrs::Code(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "VerdictAttrs",
            "Code",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "jump target chain name"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let VerdictAttrs::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "VerdictAttrs",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "jump target chain ID"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let VerdictAttrs::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "VerdictAttrs",
            "ChainId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> VerdictAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableVerdictAttrs<'a> {
        IterableVerdictAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Code",
            2u16 => "Chain",
            3u16 => "ChainId",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableVerdictAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableVerdictAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableVerdictAttrs<'a> {
    type Item = Result<VerdictAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => VerdictAttrs::Code({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => VerdictAttrs::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => VerdictAttrs::ChainId({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "VerdictAttrs",
            r#type.and_then(|t| VerdictAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableVerdictAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("VerdictAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                VerdictAttrs::Code(val) => {
                    fmt.field("Code", &FormatEnum(val.into(), VerdictCode::from_value))
                }
                VerdictAttrs::Chain(val) => fmt.field("Chain", &val),
                VerdictAttrs::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableVerdictAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("VerdictAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| VerdictAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                VerdictAttrs::Code(val) => {
                    if last_off == offset {
                        stack.push(("Code", last_off));
                        break;
                    }
                }
                VerdictAttrs::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                VerdictAttrs::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("VerdictAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprCounterAttrs<'a> {
    #[doc = "Number of bytes"]
    Bytes(u64),
    #[doc = "Number of packets"]
    Packets(u64),
    Pad(&'a [u8]),
}
impl<'a> IterableExprCounterAttrs<'a> {
    #[doc = "Number of bytes"]
    pub fn get_bytes(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCounterAttrs::Bytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprCounterAttrs",
            "Bytes",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Number of packets"]
    pub fn get_packets(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCounterAttrs::Packets(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprCounterAttrs",
            "Packets",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCounterAttrs::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprCounterAttrs",
            "Pad",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> ExprCounterAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableExprCounterAttrs<'a> {
        IterableExprCounterAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Bytes",
            2u16 => "Packets",
            3u16 => "Pad",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprCounterAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprCounterAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprCounterAttrs<'a> {
    type Item = Result<ExprCounterAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprCounterAttrs::Bytes({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprCounterAttrs::Packets({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprCounterAttrs::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprCounterAttrs",
            r#type.and_then(|t| ExprCounterAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableExprCounterAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprCounterAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprCounterAttrs::Bytes(val) => fmt.field("Bytes", &val),
                ExprCounterAttrs::Packets(val) => fmt.field("Packets", &val),
                ExprCounterAttrs::Pad(val) => fmt.field("Pad", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprCounterAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprCounterAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprCounterAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprCounterAttrs::Bytes(val) => {
                    if last_off == offset {
                        stack.push(("Bytes", last_off));
                        break;
                    }
                }
                ExprCounterAttrs::Packets(val) => {
                    if last_off == offset {
                        stack.push(("Packets", last_off));
                        break;
                    }
                }
                ExprCounterAttrs::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprCounterAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprFibAttrs {
    Dreg(u32),
    #[doc = "Associated type: \"FibResult\" (enum)"]
    Result(u32),
    #[doc = "Associated type: \"FibFlags\" (enum)"]
    Flags(u32),
}
impl<'a> IterableExprFibAttrs<'a> {
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprFibAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprFibAttrs",
            "Dreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"FibResult\" (enum)"]
    pub fn get_result(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprFibAttrs::Result(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprFibAttrs",
            "Result",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"FibFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprFibAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprFibAttrs",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl ExprFibAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableExprFibAttrs<'_> {
        IterableExprFibAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Result",
            3u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprFibAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprFibAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprFibAttrs<'a> {
    type Item = Result<ExprFibAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprFibAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprFibAttrs::Result({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprFibAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprFibAttrs",
            r#type.and_then(|t| ExprFibAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableExprFibAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprFibAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprFibAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprFibAttrs::Result(val) => {
                    fmt.field("Result", &FormatEnum(val.into(), FibResult::from_value))
                }
                ExprFibAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), FibFlags::from_value))
                }
            };
        }
        fmt.finish()
    }
}
impl IterableExprFibAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprFibAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprFibAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprFibAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprFibAttrs::Result(val) => {
                    if last_off == offset {
                        stack.push(("Result", last_off));
                        break;
                    }
                }
                ExprFibAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprFibAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprCtAttrs {
    Dreg(u32),
    #[doc = "Associated type: \"CtKeys\" (enum)"]
    Key(u32),
    #[doc = "Associated type: \"CtDirection\" (enum)"]
    Direction(u8),
    Sreg(u32),
}
impl<'a> IterableExprCtAttrs<'a> {
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCtAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprCtAttrs",
            "Dreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"CtKeys\" (enum)"]
    pub fn get_key(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCtAttrs::Key(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprCtAttrs",
            "Key",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"CtDirection\" (enum)"]
    pub fn get_direction(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCtAttrs::Direction(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprCtAttrs",
            "Direction",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprCtAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprCtAttrs",
            "Sreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl ExprCtAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableExprCtAttrs<'_> {
        IterableExprCtAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Key",
            3u16 => "Direction",
            4u16 => "Sreg",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprCtAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprCtAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprCtAttrs<'a> {
    type Item = Result<ExprCtAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprCtAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprCtAttrs::Key({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprCtAttrs::Direction({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprCtAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprCtAttrs",
            r#type.and_then(|t| ExprCtAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableExprCtAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprCtAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprCtAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprCtAttrs::Key(val) => {
                    fmt.field("Key", &FormatEnum(val.into(), CtKeys::from_value))
                }
                ExprCtAttrs::Direction(val) => fmt.field(
                    "Direction",
                    &FormatEnum(val.into(), CtDirection::from_value),
                ),
                ExprCtAttrs::Sreg(val) => fmt.field("Sreg", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprCtAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprCtAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprCtAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprCtAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprCtAttrs::Key(val) => {
                    if last_off == offset {
                        stack.push(("Key", last_off));
                        break;
                    }
                }
                ExprCtAttrs::Direction(val) => {
                    if last_off == offset {
                        stack.push(("Direction", last_off));
                        break;
                    }
                }
                ExprCtAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprCtAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprFlowOffloadAttrs<'a> {
    #[doc = "Flow offload table name"]
    Name(&'a CStr),
}
impl<'a> IterableExprFlowOffloadAttrs<'a> {
    #[doc = "Flow offload table name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprFlowOffloadAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprFlowOffloadAttrs",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> ExprFlowOffloadAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableExprFlowOffloadAttrs<'a> {
        IterableExprFlowOffloadAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprFlowOffloadAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprFlowOffloadAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprFlowOffloadAttrs<'a> {
    type Item = Result<ExprFlowOffloadAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprFlowOffloadAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprFlowOffloadAttrs",
            r#type.and_then(|t| ExprFlowOffloadAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableExprFlowOffloadAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprFlowOffloadAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprFlowOffloadAttrs::Name(val) => fmt.field("Name", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprFlowOffloadAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprFlowOffloadAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprFlowOffloadAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprFlowOffloadAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprFlowOffloadAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprImmediateAttrs<'a> {
    Dreg(u32),
    Data(IterableDataAttrs<'a>),
}
impl<'a> IterableExprImmediateAttrs<'a> {
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprImmediateAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprImmediateAttrs",
            "Dreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_data(&self) -> Result<IterableDataAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprImmediateAttrs::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprImmediateAttrs",
            "Data",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> ExprImmediateAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableExprImmediateAttrs<'a> {
        IterableExprImmediateAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Data",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprImmediateAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprImmediateAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprImmediateAttrs<'a> {
    type Item = Result<ExprImmediateAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprImmediateAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprImmediateAttrs::Data({
                    let res = Some(IterableDataAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprImmediateAttrs",
            r#type.and_then(|t| ExprImmediateAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableExprImmediateAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprImmediateAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprImmediateAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprImmediateAttrs::Data(val) => fmt.field("Data", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprImmediateAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprImmediateAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprImmediateAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprImmediateAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprImmediateAttrs::Data(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprImmediateAttrs", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum ExprLookupAttrs<'a> {
    #[doc = "Name of set to use"]
    Set(&'a CStr),
    #[doc = "ID of set to use"]
    SetId(u32),
    Sreg(u32),
    Dreg(u32),
    #[doc = "Associated type: \"LookupFlags\" (enum)"]
    Flags(u32),
}
impl<'a> IterableExprLookupAttrs<'a> {
    #[doc = "Name of set to use"]
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprLookupAttrs::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprLookupAttrs",
            "Set",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "ID of set to use"]
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprLookupAttrs::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprLookupAttrs",
            "SetId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprLookupAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprLookupAttrs",
            "Sreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprLookupAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprLookupAttrs",
            "Dreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"LookupFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprLookupAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprLookupAttrs",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> ExprLookupAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableExprLookupAttrs<'a> {
        IterableExprLookupAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Set",
            2u16 => "SetId",
            3u16 => "Sreg",
            4u16 => "Dreg",
            5u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprLookupAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprLookupAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprLookupAttrs<'a> {
    type Item = Result<ExprLookupAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprLookupAttrs::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprLookupAttrs::SetId({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprLookupAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprLookupAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ExprLookupAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprLookupAttrs",
            r#type.and_then(|t| ExprLookupAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableExprLookupAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprLookupAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprLookupAttrs::Set(val) => fmt.field("Set", &val),
                ExprLookupAttrs::SetId(val) => fmt.field("SetId", &val),
                ExprLookupAttrs::Sreg(val) => fmt.field("Sreg", &val),
                ExprLookupAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprLookupAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), LookupFlags::from_value))
                }
            };
        }
        fmt.finish()
    }
}
impl IterableExprLookupAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprLookupAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprLookupAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprLookupAttrs::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                ExprLookupAttrs::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                ExprLookupAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                ExprLookupAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprLookupAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprLookupAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprMetaAttrs {
    Dreg(u32),
    #[doc = "Associated type: \"MetaKeys\" (enum)"]
    Key(u32),
    Sreg(u32),
}
impl<'a> IterableExprMetaAttrs<'a> {
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprMetaAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprMetaAttrs",
            "Dreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"MetaKeys\" (enum)"]
    pub fn get_key(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprMetaAttrs::Key(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprMetaAttrs",
            "Key",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprMetaAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprMetaAttrs",
            "Sreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl ExprMetaAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableExprMetaAttrs<'_> {
        IterableExprMetaAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Key",
            3u16 => "Sreg",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprMetaAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprMetaAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprMetaAttrs<'a> {
    type Item = Result<ExprMetaAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprMetaAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprMetaAttrs::Key({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprMetaAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprMetaAttrs",
            r#type.and_then(|t| ExprMetaAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableExprMetaAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprMetaAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprMetaAttrs::Dreg(val) => fmt.field("Dreg", &val),
                ExprMetaAttrs::Key(val) => {
                    fmt.field("Key", &FormatEnum(val.into(), MetaKeys::from_value))
                }
                ExprMetaAttrs::Sreg(val) => fmt.field("Sreg", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprMetaAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprMetaAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprMetaAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprMetaAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprMetaAttrs::Key(val) => {
                    if last_off == offset {
                        stack.push(("Key", last_off));
                        break;
                    }
                }
                ExprMetaAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprMetaAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprNatAttrs {
    Type(u32),
    Family(u32),
    RegAddrMin(u32),
    RegAddrMax(u32),
    RegProtoMin(u32),
    RegProtoMax(u32),
    #[doc = "Associated type: \"NatRangeFlags\" (1 bit per enumeration)"]
    Flags(u32),
}
impl<'a> IterableExprNatAttrs<'a> {
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprNatAttrs",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_family(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::Family(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprNatAttrs",
            "Family",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reg_addr_min(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::RegAddrMin(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprNatAttrs",
            "RegAddrMin",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reg_addr_max(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::RegAddrMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprNatAttrs",
            "RegAddrMax",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reg_proto_min(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::RegProtoMin(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprNatAttrs",
            "RegProtoMin",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reg_proto_max(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::RegProtoMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprNatAttrs",
            "RegProtoMax",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"NatRangeFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprNatAttrs::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprNatAttrs",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl ExprNatAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableExprNatAttrs<'_> {
        IterableExprNatAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Type",
            2u16 => "Family",
            3u16 => "RegAddrMin",
            4u16 => "RegAddrMax",
            5u16 => "RegProtoMin",
            6u16 => "RegProtoMax",
            7u16 => "Flags",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprNatAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprNatAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprNatAttrs<'a> {
    type Item = Result<ExprNatAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprNatAttrs::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprNatAttrs::Family({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprNatAttrs::RegAddrMin({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprNatAttrs::RegAddrMax({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ExprNatAttrs::RegProtoMin({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ExprNatAttrs::RegProtoMax({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ExprNatAttrs::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprNatAttrs",
            r#type.and_then(|t| ExprNatAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableExprNatAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprNatAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprNatAttrs::Type(val) => fmt.field("Type", &val),
                ExprNatAttrs::Family(val) => fmt.field("Family", &val),
                ExprNatAttrs::RegAddrMin(val) => fmt.field("RegAddrMin", &val),
                ExprNatAttrs::RegAddrMax(val) => fmt.field("RegAddrMax", &val),
                ExprNatAttrs::RegProtoMin(val) => fmt.field("RegProtoMin", &val),
                ExprNatAttrs::RegProtoMax(val) => fmt.field("RegProtoMax", &val),
                ExprNatAttrs::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), NatRangeFlags::from_value))
                }
            };
        }
        fmt.finish()
    }
}
impl IterableExprNatAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprNatAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprNatAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprNatAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                ExprNatAttrs::Family(val) => {
                    if last_off == offset {
                        stack.push(("Family", last_off));
                        break;
                    }
                }
                ExprNatAttrs::RegAddrMin(val) => {
                    if last_off == offset {
                        stack.push(("RegAddrMin", last_off));
                        break;
                    }
                }
                ExprNatAttrs::RegAddrMax(val) => {
                    if last_off == offset {
                        stack.push(("RegAddrMax", last_off));
                        break;
                    }
                }
                ExprNatAttrs::RegProtoMin(val) => {
                    if last_off == offset {
                        stack.push(("RegProtoMin", last_off));
                        break;
                    }
                }
                ExprNatAttrs::RegProtoMax(val) => {
                    if last_off == offset {
                        stack.push(("RegProtoMax", last_off));
                        break;
                    }
                }
                ExprNatAttrs::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprNatAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprPayloadAttrs {
    #[doc = "destination register to load data into\nAssociated type: \"Registers\" (enum)"]
    Dreg(u32),
    #[doc = "payload base\nAssociated type: \"PayloadBase\" (enum)"]
    Base(u32),
    #[doc = "payload offset relative to base"]
    Offset(u32),
    #[doc = "payload length"]
    Len(u32),
    #[doc = "source register to load data from\nAssociated type: \"Registers\" (enum)"]
    Sreg(u32),
    #[doc = "checksum type"]
    CsumType(u32),
    #[doc = "checksum offset relative to base"]
    CsumOffset(u32),
    #[doc = "checksum flags"]
    CsumFlags(u32),
}
impl<'a> IterableExprPayloadAttrs<'a> {
    #[doc = "destination register to load data into\nAssociated type: \"Registers\" (enum)"]
    pub fn get_dreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::Dreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprPayloadAttrs",
            "Dreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "payload base\nAssociated type: \"PayloadBase\" (enum)"]
    pub fn get_base(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::Base(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprPayloadAttrs",
            "Base",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "payload offset relative to base"]
    pub fn get_offset(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::Offset(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprPayloadAttrs",
            "Offset",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "payload length"]
    pub fn get_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::Len(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprPayloadAttrs",
            "Len",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "source register to load data from\nAssociated type: \"Registers\" (enum)"]
    pub fn get_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::Sreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprPayloadAttrs",
            "Sreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "checksum type"]
    pub fn get_csum_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::CsumType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprPayloadAttrs",
            "CsumType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "checksum offset relative to base"]
    pub fn get_csum_offset(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::CsumOffset(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprPayloadAttrs",
            "CsumOffset",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "checksum flags"]
    pub fn get_csum_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprPayloadAttrs::CsumFlags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprPayloadAttrs",
            "CsumFlags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl ExprPayloadAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableExprPayloadAttrs<'_> {
        IterableExprPayloadAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Dreg",
            2u16 => "Base",
            3u16 => "Offset",
            4u16 => "Len",
            5u16 => "Sreg",
            6u16 => "CsumType",
            7u16 => "CsumOffset",
            8u16 => "CsumFlags",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprPayloadAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprPayloadAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprPayloadAttrs<'a> {
    type Item = Result<ExprPayloadAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprPayloadAttrs::Dreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprPayloadAttrs::Base({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprPayloadAttrs::Offset({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprPayloadAttrs::Len({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ExprPayloadAttrs::Sreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => ExprPayloadAttrs::CsumType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => ExprPayloadAttrs::CsumOffset({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => ExprPayloadAttrs::CsumFlags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprPayloadAttrs",
            r#type.and_then(|t| ExprPayloadAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableExprPayloadAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprPayloadAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprPayloadAttrs::Dreg(val) => {
                    fmt.field("Dreg", &FormatEnum(val.into(), Registers::from_value))
                }
                ExprPayloadAttrs::Base(val) => {
                    fmt.field("Base", &FormatEnum(val.into(), PayloadBase::from_value))
                }
                ExprPayloadAttrs::Offset(val) => fmt.field("Offset", &val),
                ExprPayloadAttrs::Len(val) => fmt.field("Len", &val),
                ExprPayloadAttrs::Sreg(val) => {
                    fmt.field("Sreg", &FormatEnum(val.into(), Registers::from_value))
                }
                ExprPayloadAttrs::CsumType(val) => fmt.field("CsumType", &val),
                ExprPayloadAttrs::CsumOffset(val) => fmt.field("CsumOffset", &val),
                ExprPayloadAttrs::CsumFlags(val) => fmt.field("CsumFlags", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprPayloadAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprPayloadAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprPayloadAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprPayloadAttrs::Dreg(val) => {
                    if last_off == offset {
                        stack.push(("Dreg", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::Base(val) => {
                    if last_off == offset {
                        stack.push(("Base", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::Offset(val) => {
                    if last_off == offset {
                        stack.push(("Offset", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::Len(val) => {
                    if last_off == offset {
                        stack.push(("Len", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::Sreg(val) => {
                    if last_off == offset {
                        stack.push(("Sreg", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::CsumType(val) => {
                    if last_off == offset {
                        stack.push(("CsumType", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::CsumOffset(val) => {
                    if last_off == offset {
                        stack.push(("CsumOffset", last_off));
                        break;
                    }
                }
                ExprPayloadAttrs::CsumFlags(val) => {
                    if last_off == offset {
                        stack.push(("CsumFlags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprPayloadAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprRejectAttrs {
    #[doc = "Associated type: \"RejectTypes\" (enum)"]
    Type(u32),
    IcmpCode(u8),
}
impl<'a> IterableExprRejectAttrs<'a> {
    #[doc = "Associated type: \"RejectTypes\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprRejectAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprRejectAttrs",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_icmp_code(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprRejectAttrs::IcmpCode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprRejectAttrs",
            "IcmpCode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl ExprRejectAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableExprRejectAttrs<'_> {
        IterableExprRejectAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Type",
            2u16 => "IcmpCode",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprRejectAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprRejectAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprRejectAttrs<'a> {
    type Item = Result<ExprRejectAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprRejectAttrs::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprRejectAttrs::IcmpCode({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprRejectAttrs",
            r#type.and_then(|t| ExprRejectAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableExprRejectAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprRejectAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprRejectAttrs::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), RejectTypes::from_value))
                }
                ExprRejectAttrs::IcmpCode(val) => fmt.field("IcmpCode", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprRejectAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprRejectAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprRejectAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprRejectAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                ExprRejectAttrs::IcmpCode(val) => {
                    if last_off == offset {
                        stack.push(("IcmpCode", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprRejectAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprTargetAttrs<'a> {
    Name(&'a CStr),
    Rev(u32),
    Info(&'a [u8]),
}
impl<'a> IterableExprTargetAttrs<'a> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTargetAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprTargetAttrs",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTargetAttrs::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprTargetAttrs",
            "Rev",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTargetAttrs::Info(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprTargetAttrs",
            "Info",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> ExprTargetAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableExprTargetAttrs<'a> {
        IterableExprTargetAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Rev",
            3u16 => "Info",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprTargetAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprTargetAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprTargetAttrs<'a> {
    type Item = Result<ExprTargetAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprTargetAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprTargetAttrs::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprTargetAttrs::Info({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprTargetAttrs",
            r#type.and_then(|t| ExprTargetAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableExprTargetAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprTargetAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprTargetAttrs::Name(val) => fmt.field("Name", &val),
                ExprTargetAttrs::Rev(val) => fmt.field("Rev", &val),
                ExprTargetAttrs::Info(val) => fmt.field("Info", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprTargetAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprTargetAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprTargetAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprTargetAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                ExprTargetAttrs::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                ExprTargetAttrs::Info(val) => {
                    if last_off == offset {
                        stack.push(("Info", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprTargetAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprTproxyAttrs {
    Family(u32),
    RegAddr(u32),
    RegPort(u32),
}
impl<'a> IterableExprTproxyAttrs<'a> {
    pub fn get_family(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTproxyAttrs::Family(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprTproxyAttrs",
            "Family",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reg_addr(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTproxyAttrs::RegAddr(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprTproxyAttrs",
            "RegAddr",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reg_port(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprTproxyAttrs::RegPort(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprTproxyAttrs",
            "RegPort",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl ExprTproxyAttrs {
    pub fn new(buf: &'_ [u8]) -> IterableExprTproxyAttrs<'_> {
        IterableExprTproxyAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Family",
            2u16 => "RegAddr",
            3u16 => "RegPort",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprTproxyAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprTproxyAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprTproxyAttrs<'a> {
    type Item = Result<ExprTproxyAttrs, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprTproxyAttrs::Family({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprTproxyAttrs::RegAddr({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprTproxyAttrs::RegPort({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprTproxyAttrs",
            r#type.and_then(|t| ExprTproxyAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableExprTproxyAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprTproxyAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprTproxyAttrs::Family(val) => fmt.field("Family", &val),
                ExprTproxyAttrs::RegAddr(val) => fmt.field("RegAddr", &val),
                ExprTproxyAttrs::RegPort(val) => fmt.field("RegPort", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprTproxyAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprTproxyAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprTproxyAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprTproxyAttrs::Family(val) => {
                    if last_off == offset {
                        stack.push(("Family", last_off));
                        break;
                    }
                }
                ExprTproxyAttrs::RegAddr(val) => {
                    if last_off == offset {
                        stack.push(("RegAddr", last_off));
                        break;
                    }
                }
                ExprTproxyAttrs::RegPort(val) => {
                    if last_off == offset {
                        stack.push(("RegPort", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprTproxyAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum ExprObjrefAttrs<'a> {
    ImmType(u32),
    #[doc = "object name"]
    ImmName(&'a CStr),
    SetSreg(u32),
    #[doc = "name of object map"]
    SetName(&'a CStr),
    #[doc = "id of object map"]
    SetId(u32),
}
impl<'a> IterableExprObjrefAttrs<'a> {
    pub fn get_imm_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprObjrefAttrs::ImmType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprObjrefAttrs",
            "ImmType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "object name"]
    pub fn get_imm_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprObjrefAttrs::ImmName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprObjrefAttrs",
            "ImmName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set_sreg(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprObjrefAttrs::SetSreg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprObjrefAttrs",
            "SetSreg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of object map"]
    pub fn get_set_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprObjrefAttrs::SetName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprObjrefAttrs",
            "SetName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "id of object map"]
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let ExprObjrefAttrs::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "ExprObjrefAttrs",
            "SetId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> ExprObjrefAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableExprObjrefAttrs<'a> {
        IterableExprObjrefAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "ImmType",
            2u16 => "ImmName",
            3u16 => "SetSreg",
            4u16 => "SetName",
            5u16 => "SetId",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableExprObjrefAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableExprObjrefAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableExprObjrefAttrs<'a> {
    type Item = Result<ExprObjrefAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => ExprObjrefAttrs::ImmType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => ExprObjrefAttrs::ImmName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => ExprObjrefAttrs::SetSreg({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => ExprObjrefAttrs::SetName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => ExprObjrefAttrs::SetId({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "ExprObjrefAttrs",
            r#type.and_then(|t| ExprObjrefAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableExprObjrefAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("ExprObjrefAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                ExprObjrefAttrs::ImmType(val) => fmt.field("ImmType", &val),
                ExprObjrefAttrs::ImmName(val) => fmt.field("ImmName", &val),
                ExprObjrefAttrs::SetSreg(val) => fmt.field("SetSreg", &val),
                ExprObjrefAttrs::SetName(val) => fmt.field("SetName", &val),
                ExprObjrefAttrs::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableExprObjrefAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("ExprObjrefAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| ExprObjrefAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                ExprObjrefAttrs::ImmType(val) => {
                    if last_off == offset {
                        stack.push(("ImmType", last_off));
                        break;
                    }
                }
                ExprObjrefAttrs::ImmName(val) => {
                    if last_off == offset {
                        stack.push(("ImmName", last_off));
                        break;
                    }
                }
                ExprObjrefAttrs::SetSreg(val) => {
                    if last_off == offset {
                        stack.push(("SetSreg", last_off));
                        break;
                    }
                }
                ExprObjrefAttrs::SetName(val) => {
                    if last_off == offset {
                        stack.push(("SetName", last_off));
                        break;
                    }
                }
                ExprObjrefAttrs::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("ExprObjrefAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum CompatTargetAttrs<'a> {
    Name(&'a CStr),
    Rev(u32),
    Info(&'a [u8]),
}
impl<'a> IterableCompatTargetAttrs<'a> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatTargetAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CompatTargetAttrs",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatTargetAttrs::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CompatTargetAttrs",
            "Rev",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatTargetAttrs::Info(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CompatTargetAttrs",
            "Info",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> CompatTargetAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableCompatTargetAttrs<'a> {
        IterableCompatTargetAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Rev",
            3u16 => "Info",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableCompatTargetAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableCompatTargetAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableCompatTargetAttrs<'a> {
    type Item = Result<CompatTargetAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CompatTargetAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CompatTargetAttrs::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CompatTargetAttrs::Info({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "CompatTargetAttrs",
            r#type.and_then(|t| CompatTargetAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableCompatTargetAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CompatTargetAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CompatTargetAttrs::Name(val) => fmt.field("Name", &val),
                CompatTargetAttrs::Rev(val) => fmt.field("Rev", &val),
                CompatTargetAttrs::Info(val) => fmt.field("Info", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableCompatTargetAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CompatTargetAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CompatTargetAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CompatTargetAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                CompatTargetAttrs::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                CompatTargetAttrs::Info(val) => {
                    if last_off == offset {
                        stack.push(("Info", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CompatTargetAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum CompatMatchAttrs<'a> {
    Name(&'a CStr),
    Rev(u32),
    Info(&'a [u8]),
}
impl<'a> IterableCompatMatchAttrs<'a> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatMatchAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CompatMatchAttrs",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatMatchAttrs::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CompatMatchAttrs",
            "Rev",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatMatchAttrs::Info(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CompatMatchAttrs",
            "Info",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> CompatMatchAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableCompatMatchAttrs<'a> {
        IterableCompatMatchAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Rev",
            3u16 => "Info",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableCompatMatchAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableCompatMatchAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableCompatMatchAttrs<'a> {
    type Item = Result<CompatMatchAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CompatMatchAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CompatMatchAttrs::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CompatMatchAttrs::Info({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "CompatMatchAttrs",
            r#type.and_then(|t| CompatMatchAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableCompatMatchAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CompatMatchAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CompatMatchAttrs::Name(val) => fmt.field("Name", &val),
                CompatMatchAttrs::Rev(val) => fmt.field("Rev", &val),
                CompatMatchAttrs::Info(val) => fmt.field("Info", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableCompatMatchAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CompatMatchAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CompatMatchAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CompatMatchAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                CompatMatchAttrs::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                CompatMatchAttrs::Info(val) => {
                    if last_off == offset {
                        stack.push(("Info", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CompatMatchAttrs", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum CompatAttrs<'a> {
    Name(&'a CStr),
    Rev(u32),
    Type(u32),
}
impl<'a> IterableCompatAttrs<'a> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatAttrs::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CompatAttrs",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatAttrs::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CompatAttrs",
            "Rev",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let CompatAttrs::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "CompatAttrs",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> CompatAttrs<'a> {
    pub fn new(buf: &'a [u8]) -> IterableCompatAttrs<'a> {
        IterableCompatAttrs::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Name",
            2u16 => "Rev",
            3u16 => "Type",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableCompatAttrs<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableCompatAttrs<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableCompatAttrs<'a> {
    type Item = Result<CompatAttrs<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => CompatAttrs::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => CompatAttrs::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => CompatAttrs::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "CompatAttrs",
            r#type.and_then(|t| CompatAttrs::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableCompatAttrs<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("CompatAttrs");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                CompatAttrs::Name(val) => fmt.field("Name", &val),
                CompatAttrs::Rev(val) => fmt.field("Rev", &val),
                CompatAttrs::Type(val) => fmt.field("Type", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableCompatAttrs<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("CompatAttrs", offset));
            return (
                stack,
                missing_type.and_then(|t| CompatAttrs::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                CompatAttrs::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                CompatAttrs::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                CompatAttrs::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("CompatAttrs", cur));
        }
        (stack, None)
    }
}
pub struct PushLogAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushLogAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushLogAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "netlink group to send messages to"]
    pub fn push_group(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 1u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "prefix to prepend to log messages"]
    pub fn push_prefix(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "prefix to prepend to log messages"]
    pub fn push_prefix_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "length of payload to include in netlink message"]
    pub fn push_snaplen(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "queue threshold"]
    pub fn push_qthreshold(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 4u16, 2 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "log level\nAssociated type: \"LogLevel\" (enum)"]
    pub fn push_level(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "logging flags\nAssociated type: \"LogFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushLogAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushNumgenAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushNumgenAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushNumgenAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "destination register\nAssociated type: \"Registers\" (enum)"]
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "maximum counter value"]
    pub fn push_modulus(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "operation type\nAssociated type: \"NumgenTypes\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "offset to be added to the counter"]
    pub fn push_offset(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushNumgenAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushRangeAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushRangeAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushRangeAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "source register of data to compare\nAssociated type: \"Registers\" (enum)"]
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "cmp operation\nAssociated type: \"RangeOps\" (enum)"]
    pub fn push_op(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "data range from"]
    pub fn nested_from_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "data range to"]
    pub fn nested_to_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushRangeAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushBatchAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushBatchAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushBatchAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "generation ID for this changeset"]
    pub fn push_genid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushBatchAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushTableAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushTableAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushTableAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 5u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "owner of this table through netlink portID"]
    pub fn push_owner(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushTableAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushChainAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushChainAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushChainAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushChainAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCounterAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCounterAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCounterAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bytes(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 1u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_packets(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushCounterAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushNftHookAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushNftHookAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushNftHookAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_num(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_priority(mut self, value: i32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "net device name"]
    pub fn push_dev(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "net device name"]
    pub fn push_dev_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "list of net devices"]
    pub fn nested_devs(mut self) -> PushHookDevAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushHookDevAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushNftHookAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushHookDevAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushHookDevAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushHookDevAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushHookDevAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushNftCounterAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushNftCounterAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushNftCounterAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bytes(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 1u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_packets(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushNftCounterAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushRuleAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushRuleAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushRuleAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushRuleAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprListAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprListAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprListAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_elem(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushExprListAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "type specific data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_bitwise(mut self) -> PushExprBitwiseAttrs<PushDummy<Prev>> {
        self = self.push_name(c"bitwise");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprBitwiseAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_cmp(mut self) -> PushExprCmpAttrs<PushDummy<Prev>> {
        self = self.push_name(c"cmp");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprCmpAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_counter(mut self) -> PushExprCounterAttrs<PushDummy<Prev>> {
        self = self.push_name(c"counter");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprCounterAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_ct(mut self) -> PushExprCtAttrs<PushDummy<Prev>> {
        self = self.push_name(c"ct");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprCtAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_fib(mut self) -> PushExprFibAttrs<PushDummy<Prev>> {
        self = self.push_name(c"fib");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprFibAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_flow_offload(mut self) -> PushExprFlowOffloadAttrs<PushDummy<Prev>> {
        self = self.push_name(c"flow_offload");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprFlowOffloadAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_immediate(mut self) -> PushExprImmediateAttrs<PushDummy<Prev>> {
        self = self.push_name(c"immediate");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprImmediateAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_lookup(mut self) -> PushExprLookupAttrs<PushDummy<Prev>> {
        self = self.push_name(c"lookup");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprLookupAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_meta(mut self) -> PushExprMetaAttrs<PushDummy<Prev>> {
        self = self.push_name(c"meta");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprMetaAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_nat(mut self) -> PushExprNatAttrs<PushDummy<Prev>> {
        self = self.push_name(c"nat");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprNatAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_objref(mut self) -> PushExprObjrefAttrs<PushDummy<Prev>> {
        self = self.push_name(c"objref");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprObjrefAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_payload(mut self) -> PushExprPayloadAttrs<PushDummy<Prev>> {
        self = self.push_name(c"payload");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprPayloadAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_quota(mut self) -> PushQuotaAttrs<PushDummy<Prev>> {
        self = self.push_name(c"quota");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQuotaAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_reject(mut self) -> PushExprRejectAttrs<PushDummy<Prev>> {
        self = self.push_name(c"reject");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprRejectAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_target(mut self) -> PushExprTargetAttrs<PushDummy<Prev>> {
        self = self.push_name(c"target");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprTargetAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_tproxy(mut self) -> PushExprTproxyAttrs<PushDummy<Prev>> {
        self = self.push_name(c"tproxy");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushExprTproxyAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_match(mut self) -> PushCompatMatchAttrs<PushDummy<Prev>> {
        self = self.push_name(c"match");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCompatMatchAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_range(mut self) -> PushRangeAttrs<PushDummy<Prev>> {
        self = self.push_name(c"range");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushRangeAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_numgen(mut self) -> PushNumgenAttrs<PushDummy<Prev>> {
        self = self.push_name(c"numgen");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushNumgenAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_log(mut self) -> PushLogAttrs<PushDummy<Prev>> {
        self = self.push_name(c"log");
        let new_header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushLogAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushExprAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushRuleCompatAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushRuleCompatAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushRuleCompatAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "numeric value of the handled protocol"]
    pub fn push_proto(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "bitmask of flags"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushRuleCompatAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 14u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "set backend type"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            19u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set backend type"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 19u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "number of set elements"]
    pub fn push_count(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 20u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushSetAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetDescAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetDescAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetDescAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "number of elements in set"]
    pub fn push_size(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "description of field concatenation\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_concat(mut self) -> PushSetDescConcatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushSetDescConcatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushSetDescAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetDescConcatAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetDescConcatAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetDescConcatAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn nested_elem(mut self) -> PushSetFieldAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushSetFieldAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushSetDescConcatAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetFieldAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetFieldAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetFieldAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushSetFieldAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetListAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetListAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetListAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_elem(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushSetListAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetelemAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetelemAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetelemAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "key value"]
    pub fn nested_key(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "data value of mapping"]
    pub fn nested_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "bitmask of nft_set_elem_flags\nAssociated type: \"SetElemFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "expiration time"]
    pub fn push_expiration(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "expression"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "stateful object reference"]
    pub fn push_objref(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            8u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "stateful object reference"]
    pub fn push_objref_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "closing key value"]
    pub fn nested_key_end(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 10u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushSetelemAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetelemListElemAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetelemListElemAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetelemListElemAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_elem(mut self) -> PushSetelemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 1u16);
        PushSetelemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushSetelemListElemAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushSetelemListAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushSetelemListAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushSetelemListAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushSetelemListAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushGenAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushGenAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushGenAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "ruleset generation id"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_pid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_proc_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushGenAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushObjAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushObjAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushObjAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_counter(mut self) -> PushCounterAttrs<PushDummy<Prev>> {
        self = self.push_type(ObjectType::Counter as u32);
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCounterAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_quota(mut self) -> PushQuotaAttrs<PushDummy<Prev>> {
        self = self.push_type(ObjectType::Quota as u32);
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQuotaAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushObjAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushQuotaAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushQuotaAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushQuotaAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bytes(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 1u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"QuotaFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_consumed(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushQuotaAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowtableAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowtableAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowtableAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushFlowtableAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushFlowtableHookAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushFlowtableHookAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushFlowtableHookAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_num(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_priority(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn nested_devs(mut self) -> PushHookDevAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushHookDevAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushFlowtableHookAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprBitwiseAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprBitwiseAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprBitwiseAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn nested_mask(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_xor(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Associated type: \"BitwiseOps\" (enum)"]
    pub fn push_op(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn nested_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 7u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_sreg2(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprBitwiseAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprCmpAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprCmpAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprCmpAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"CmpOps\" (enum)"]
    pub fn push_op(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn nested_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushExprCmpAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDataAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDataAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDataAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_value(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn nested_verdict(mut self) -> PushVerdictAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushVerdictAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDataAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushVerdictAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushVerdictAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushVerdictAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "nf_tables verdict\nAssociated type: \"VerdictCode\" (enum)"]
    pub fn push_code(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "jump target chain name"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "jump target chain name"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "jump target chain ID"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushVerdictAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprCounterAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprCounterAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprCounterAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Number of bytes"]
    pub fn push_bytes(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 1u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Number of packets"]
    pub fn push_packets(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushExprCounterAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprFibAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprFibAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprFibAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"FibResult\" (enum)"]
    pub fn push_result(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"FibFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprFibAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprCtAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprCtAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprCtAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"CtKeys\" (enum)"]
    pub fn push_key(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"CtDirection\" (enum)"]
    pub fn push_direction(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 3u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprCtAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprFlowOffloadAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprFlowOffloadAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprFlowOffloadAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Flow offload table name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "Flow offload table name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushExprFlowOffloadAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprImmediateAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprImmediateAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprImmediateAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn nested_data(mut self) -> PushDataAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 2u16);
        PushDataAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushExprImmediateAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprLookupAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprLookupAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprLookupAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Name of set to use"]
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "Name of set to use"]
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "ID of set to use"]
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"LookupFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprLookupAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprMetaAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprMetaAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprMetaAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"MetaKeys\" (enum)"]
    pub fn push_key(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprMetaAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprNatAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprNatAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprNatAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_family(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_addr_min(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_addr_max(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_proto_min(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_proto_max(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "Associated type: \"NatRangeFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprNatAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprPayloadAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprPayloadAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprPayloadAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "destination register to load data into\nAssociated type: \"Registers\" (enum)"]
    pub fn push_dreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "payload base\nAssociated type: \"PayloadBase\" (enum)"]
    pub fn push_base(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "payload offset relative to base"]
    pub fn push_offset(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "payload length"]
    pub fn push_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "source register to load data from\nAssociated type: \"Registers\" (enum)"]
    pub fn push_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "checksum type"]
    pub fn push_csum_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "checksum offset relative to base"]
    pub fn push_csum_offset(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "checksum flags"]
    pub fn push_csum_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprPayloadAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprRejectAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprRejectAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprRejectAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Associated type: \"RejectTypes\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_icmp_code(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 2u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprRejectAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprTargetAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprTargetAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprTargetAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_info(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushExprTargetAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprTproxyAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprTproxyAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprTproxyAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_family(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_addr(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_reg_port(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprTproxyAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushExprObjrefAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushExprObjrefAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushExprObjrefAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_imm_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object name"]
    pub fn push_imm_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "object name"]
    pub fn push_imm_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set_sreg(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of object map"]
    pub fn push_set_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            4u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of object map"]
    pub fn push_set_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 4u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "id of object map"]
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushExprObjrefAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCompatTargetAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCompatTargetAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCompatTargetAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_info(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushCompatTargetAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCompatMatchAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCompatMatchAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCompatMatchAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_info(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushCompatMatchAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushCompatAttrs<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushCompatAttrs<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushCompatAttrs<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushCompatAttrs<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[derive(Clone)]
pub struct PushNfgenmsg {
    pub(crate) buf: [u8; 4usize],
}
#[doc = "Create zero-initialized struct"]
impl Default for PushNfgenmsg {
    fn default() -> Self {
        Self { buf: [0u8; 4usize] }
    }
}
impl PushNfgenmsg {
    #[doc = "Create zero-initialized struct"]
    pub fn new() -> Self {
        Default::default()
    }
    #[doc = "Copy from contents from other slice"]
    pub fn new_from_slice(other: &[u8]) -> Option<Self> {
        if other.len() != Self::len() {
            return None;
        }
        let mut buf = [0u8; Self::len()];
        buf.clone_from_slice(other);
        Some(Self { buf })
    }
    pub fn as_slice(&self) -> &[u8] {
        &self.buf
    }
    pub fn as_mut_slice(&mut self) -> &mut [u8] {
        &mut self.buf
    }
    pub const fn len() -> usize {
        4usize
    }
    pub fn nfgen_family(&self) -> u8 {
        parse_u8(&self.buf[0usize..1usize]).unwrap()
    }
    pub fn set_nfgen_family(&mut self, value: u8) {
        self.buf[0usize..1usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn version(&self) -> u8 {
        parse_u8(&self.buf[1usize..2usize]).unwrap()
    }
    pub fn set_version(&mut self, value: u8) {
        self.buf[1usize..2usize].copy_from_slice(&value.to_ne_bytes())
    }
    pub fn res_id(&self) -> u16 {
        parse_be_u16(&self.buf[2usize..4usize]).unwrap()
    }
    pub fn set_res_id(&mut self, value: u16) {
        self.buf[2usize..4usize].copy_from_slice(&value.to_be_bytes())
    }
}
impl std::fmt::Debug for PushNfgenmsg {
    fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        fmt.debug_struct("Nfgenmsg")
            .field("nfgen_family", &self.nfgen_family())
            .field("version", &self.version())
            .field("res_id", &self.res_id())
            .finish()
    }
}
#[doc = "Get / dump nft_compat info"]
pub struct PushOpGetcompatDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetcompatDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetcompatDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpGetcompatDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump nft_compat info"]
#[derive(Clone)]
pub enum OpGetcompatDumpRequest {}
impl<'a> IterableOpGetcompatDumpRequest<'a> {}
impl OpGetcompatDumpRequest {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpGetcompatDumpRequest<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetcompatDumpRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        CompatAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetcompatDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetcompatDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetcompatDumpRequest<'a> {
    type Item = Result<OpGetcompatDumpRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetcompatDumpRequest",
            r#type.and_then(|t| OpGetcompatDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpGetcompatDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetcompatDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpGetcompatDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetcompatDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetcompatDumpRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get / dump nft_compat info"]
pub struct PushOpGetcompatDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetcompatDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetcompatDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetcompatDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump nft_compat info"]
#[derive(Clone)]
pub enum OpGetcompatDumpReply<'a> {
    Name(&'a CStr),
    Rev(u32),
    Type(u32),
}
impl<'a> IterableOpGetcompatDumpReply<'a> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetcompatDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetcompatDumpReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetcompatDumpReply::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetcompatDumpReply",
            "Rev",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetcompatDumpReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetcompatDumpReply",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetcompatDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetcompatDumpReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetcompatDumpReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        CompatAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetcompatDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetcompatDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetcompatDumpReply<'a> {
    type Item = Result<OpGetcompatDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetcompatDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetcompatDumpReply::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetcompatDumpReply::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetcompatDumpReply",
            r#type.and_then(|t| OpGetcompatDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetcompatDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetcompatDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetcompatDumpReply::Name(val) => fmt.field("Name", &val),
                OpGetcompatDumpReply::Rev(val) => fmt.field("Rev", &val),
                OpGetcompatDumpReply::Type(val) => fmt.field("Type", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetcompatDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetcompatDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetcompatDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetcompatDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetcompatDumpReply::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                OpGetcompatDumpReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetcompatDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGetcompatDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetcompatDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetcompatDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetcompatDumpRequest<&mut Vec<u8>> {
        PushOpGetcompatDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetcompatDumpRequest<RequestBuf<'r>> {
        PushOpGetcompatDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetcompatDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetcompatDumpReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2816u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetcompatDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetcompatDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump nft_compat info"]
pub struct PushOpGetcompatDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetcompatDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetcompatDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetcompatDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump nft_compat info"]
#[derive(Clone)]
pub enum OpGetcompatDoRequest<'a> {
    Name(&'a CStr),
    Rev(u32),
    Type(u32),
}
impl<'a> IterableOpGetcompatDoRequest<'a> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetcompatDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetcompatDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetcompatDoRequest::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetcompatDoRequest",
            "Rev",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetcompatDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetcompatDoRequest",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetcompatDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetcompatDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetcompatDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        CompatAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetcompatDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetcompatDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetcompatDoRequest<'a> {
    type Item = Result<OpGetcompatDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetcompatDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetcompatDoRequest::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetcompatDoRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetcompatDoRequest",
            r#type.and_then(|t| OpGetcompatDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetcompatDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetcompatDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetcompatDoRequest::Name(val) => fmt.field("Name", &val),
                OpGetcompatDoRequest::Rev(val) => fmt.field("Rev", &val),
                OpGetcompatDoRequest::Type(val) => fmt.field("Type", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetcompatDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetcompatDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetcompatDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetcompatDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetcompatDoRequest::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                OpGetcompatDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetcompatDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump nft_compat info"]
pub struct PushOpGetcompatDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetcompatDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetcompatDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rev(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetcompatDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump nft_compat info"]
#[derive(Clone)]
pub enum OpGetcompatDoReply<'a> {
    Name(&'a CStr),
    Rev(u32),
    Type(u32),
}
impl<'a> IterableOpGetcompatDoReply<'a> {
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetcompatDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetcompatDoReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rev(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetcompatDoReply::Rev(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetcompatDoReply",
            "Rev",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetcompatDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetcompatDoReply",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetcompatDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetcompatDoReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetcompatDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        CompatAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetcompatDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetcompatDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetcompatDoReply<'a> {
    type Item = Result<OpGetcompatDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetcompatDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetcompatDoReply::Rev({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetcompatDoReply::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetcompatDoReply",
            r#type.and_then(|t| OpGetcompatDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetcompatDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetcompatDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetcompatDoReply::Name(val) => fmt.field("Name", &val),
                OpGetcompatDoReply::Rev(val) => fmt.field("Rev", &val),
                OpGetcompatDoReply::Type(val) => fmt.field("Type", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetcompatDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetcompatDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetcompatDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetcompatDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetcompatDoReply::Rev(val) => {
                    if last_off == offset {
                        stack.push(("Rev", last_off));
                        break;
                    }
                }
                OpGetcompatDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetcompatDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGetcompatDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetcompatDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetcompatDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetcompatDoRequest<&mut Vec<u8>> {
        PushOpGetcompatDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetcompatDoRequest<RequestBuf<'r>> {
        PushOpGetcompatDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetcompatDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetcompatDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2816u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetcompatDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetcompatDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Start a batch of operations"]
pub struct PushOpBatchBeginDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpBatchBeginDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpBatchBeginDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "generation ID for this changeset"]
    pub fn push_genid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpBatchBeginDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Start a batch of operations"]
#[derive(Clone)]
pub enum OpBatchBeginDoRequest {
    #[doc = "generation ID for this changeset"]
    Genid(u32),
}
impl<'a> IterableOpBatchBeginDoRequest<'a> {
    #[doc = "generation ID for this changeset"]
    pub fn get_genid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpBatchBeginDoRequest::Genid(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpBatchBeginDoRequest",
            "Genid",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpBatchBeginDoRequest {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpBatchBeginDoRequest<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpBatchBeginDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        BatchAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpBatchBeginDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpBatchBeginDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpBatchBeginDoRequest<'a> {
    type Item = Result<OpBatchBeginDoRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpBatchBeginDoRequest::Genid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpBatchBeginDoRequest",
            r#type.and_then(|t| OpBatchBeginDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpBatchBeginDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpBatchBeginDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpBatchBeginDoRequest::Genid(val) => fmt.field("Genid", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpBatchBeginDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpBatchBeginDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpBatchBeginDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpBatchBeginDoRequest::Genid(val) => {
                    if last_off == offset {
                        stack.push(("Genid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpBatchBeginDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Start a batch of operations"]
pub struct PushOpBatchBeginDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpBatchBeginDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpBatchBeginDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "generation ID for this changeset"]
    pub fn push_genid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpBatchBeginDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Start a batch of operations"]
#[derive(Clone)]
pub enum OpBatchBeginDoReply {
    #[doc = "generation ID for this changeset"]
    Genid(u32),
}
impl<'a> IterableOpBatchBeginDoReply<'a> {
    #[doc = "generation ID for this changeset"]
    pub fn get_genid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpBatchBeginDoReply::Genid(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpBatchBeginDoReply",
            "Genid",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpBatchBeginDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpBatchBeginDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpBatchBeginDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        BatchAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpBatchBeginDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpBatchBeginDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpBatchBeginDoReply<'a> {
    type Item = Result<OpBatchBeginDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpBatchBeginDoReply::Genid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpBatchBeginDoReply",
            r#type.and_then(|t| OpBatchBeginDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpBatchBeginDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpBatchBeginDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpBatchBeginDoReply::Genid(val) => fmt.field("Genid", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpBatchBeginDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpBatchBeginDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpBatchBeginDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpBatchBeginDoReply::Genid(val) => {
                    if last_off == offset {
                        stack.push(("Genid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpBatchBeginDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpBatchBeginDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpBatchBeginDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpBatchBeginDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpBatchBeginDoRequest<&mut Vec<u8>> {
        PushOpBatchBeginDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpBatchBeginDoRequest<RequestBuf<'r>> {
        PushOpBatchBeginDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpBatchBeginDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpBatchBeginDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 16u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpBatchBeginDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpBatchBeginDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Finish a batch of operations"]
pub struct PushOpBatchEndDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpBatchEndDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpBatchEndDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "generation ID for this changeset"]
    pub fn push_genid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpBatchEndDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Finish a batch of operations"]
#[derive(Clone)]
pub enum OpBatchEndDoRequest {
    #[doc = "generation ID for this changeset"]
    Genid(u32),
}
impl<'a> IterableOpBatchEndDoRequest<'a> {
    #[doc = "generation ID for this changeset"]
    pub fn get_genid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpBatchEndDoRequest::Genid(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpBatchEndDoRequest",
            "Genid",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpBatchEndDoRequest {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpBatchEndDoRequest<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpBatchEndDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        BatchAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpBatchEndDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpBatchEndDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpBatchEndDoRequest<'a> {
    type Item = Result<OpBatchEndDoRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpBatchEndDoRequest::Genid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpBatchEndDoRequest",
            r#type.and_then(|t| OpBatchEndDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpBatchEndDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpBatchEndDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpBatchEndDoRequest::Genid(val) => fmt.field("Genid", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpBatchEndDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpBatchEndDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpBatchEndDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpBatchEndDoRequest::Genid(val) => {
                    if last_off == offset {
                        stack.push(("Genid", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpBatchEndDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Finish a batch of operations"]
pub struct PushOpBatchEndDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpBatchEndDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpBatchEndDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpBatchEndDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Finish a batch of operations"]
#[derive(Clone)]
pub enum OpBatchEndDoReply {}
impl<'a> IterableOpBatchEndDoReply<'a> {}
impl OpBatchEndDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpBatchEndDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpBatchEndDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        BatchAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpBatchEndDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpBatchEndDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpBatchEndDoReply<'a> {
    type Item = Result<OpBatchEndDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpBatchEndDoReply",
            r#type.and_then(|t| OpBatchEndDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpBatchEndDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpBatchEndDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpBatchEndDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpBatchEndDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpBatchEndDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpBatchEndDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpBatchEndDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpBatchEndDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpBatchEndDoRequest<&mut Vec<u8>> {
        PushOpBatchEndDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpBatchEndDoRequest<RequestBuf<'r>> {
        PushOpBatchEndDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpBatchEndDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpBatchEndDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 17u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpBatchEndDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpBatchEndDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new table."]
pub struct PushOpNewtableDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewtableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewtableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewtableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new table."]
#[derive(Clone)]
pub enum OpNewtableDoRequest<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableOpNewtableDoRequest<'a> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewtableDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewtableDoRequest",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewtableDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewtableDoRequest",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpNewtableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpNewtableDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewtableDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewtableDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewtableDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewtableDoRequest<'a> {
    type Item = Result<OpNewtableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewtableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewtableDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewtableDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewtableDoRequest",
            r#type.and_then(|t| OpNewtableDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpNewtableDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewtableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewtableDoRequest::Name(val) => fmt.field("Name", &val),
                OpNewtableDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpNewtableDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpNewtableDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewtableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewtableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewtableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewtableDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpNewtableDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewtableDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Create a new table."]
pub struct PushOpNewtableDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewtableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewtableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNewtableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new table."]
#[derive(Clone)]
pub enum OpNewtableDoReply {}
impl<'a> IterableOpNewtableDoReply<'a> {}
impl OpNewtableDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpNewtableDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewtableDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewtableDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewtableDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewtableDoReply<'a> {
    type Item = Result<OpNewtableDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewtableDoReply",
            r#type.and_then(|t| OpNewtableDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpNewtableDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewtableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpNewtableDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewtableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewtableDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewtableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewtableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewtableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewtableDoRequest<&mut Vec<u8>> {
        PushOpNewtableDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNewtableDoRequest<RequestBuf<'r>> {
        PushOpNewtableDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNewtableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpNewtableDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2560u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewtableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewtableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tables."]
pub struct PushOpGettableDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettableDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettableDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpGettableDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tables."]
#[derive(Clone)]
pub enum OpGettableDumpRequest {}
impl<'a> IterableOpGettableDumpRequest<'a> {}
impl OpGettableDumpRequest {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpGettableDumpRequest<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGettableDumpRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGettableDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGettableDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGettableDumpRequest<'a> {
    type Item = Result<OpGettableDumpRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGettableDumpRequest",
            r#type.and_then(|t| OpGettableDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpGettableDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettableDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpGettableDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGettableDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettableDumpRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get / dump tables."]
pub struct PushOpGettableDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettableDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettableDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "owner of this table through netlink portID"]
    pub fn push_owner(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettableDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tables."]
#[derive(Clone)]
pub enum OpGettableDumpReply<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "owner of this table through netlink portID"]
    Owner(u32),
}
impl<'a> IterableOpGettableDumpReply<'a> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDumpReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDumpReply",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDumpReply",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDumpReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDumpReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "owner of this table through netlink portID"]
    pub fn get_owner(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDumpReply::Owner(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDumpReply",
            "Owner",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGettableDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGettableDumpReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGettableDumpReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGettableDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGettableDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGettableDumpReply<'a> {
    type Item = Result<OpGettableDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGettableDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGettableDumpReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGettableDumpReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGettableDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGettableDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGettableDumpReply::Owner({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGettableDumpReply",
            r#type.and_then(|t| OpGettableDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGettableDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettableDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettableDumpReply::Name(val) => fmt.field("Name", &val),
                OpGettableDumpReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpGettableDumpReply::Use(val) => fmt.field("Use", &val),
                OpGettableDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGettableDumpReply::Userdata(val) => fmt.field("Userdata", &val),
                OpGettableDumpReply::Owner(val) => fmt.field("Owner", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGettableDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGettableDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettableDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettableDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGettableDumpReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGettableDumpReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGettableDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGettableDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGettableDumpReply::Owner(val) => {
                    if last_off == offset {
                        stack.push(("Owner", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettableDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGettableDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGettableDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGettableDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGettableDumpRequest<&mut Vec<u8>> {
        PushOpGettableDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGettableDumpRequest<RequestBuf<'r>> {
        PushOpGettableDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGettableDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGettableDumpReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2561u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGettableDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGettableDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump tables."]
pub struct PushOpGettableDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tables."]
#[derive(Clone)]
pub enum OpGettableDoRequest<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
}
impl<'a> IterableOpGettableDoRequest<'a> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGettableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGettableDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGettableDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGettableDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGettableDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGettableDoRequest<'a> {
    type Item = Result<OpGettableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGettableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGettableDoRequest",
            r#type.and_then(|t| OpGettableDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGettableDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettableDoRequest::Name(val) => fmt.field("Name", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGettableDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGettableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettableDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump tables."]
pub struct PushOpGettableDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGettableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGettableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of chains in this table"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 6u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "owner of this table through netlink portID"]
    pub fn push_owner(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGettableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump tables."]
#[derive(Clone)]
pub enum OpGettableDoReply<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "number of chains in this table"]
    Use(u32),
    #[doc = "numeric handle of the table"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "owner of this table through netlink portID"]
    Owner(u32),
}
impl<'a> IterableOpGettableDoReply<'a> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDoReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "bitmask of flags\nAssociated type: \"TableFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDoReply",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "number of chains in this table"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDoReply",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDoReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDoReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "owner of this table through netlink portID"]
    pub fn get_owner(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGettableDoReply::Owner(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGettableDoReply",
            "Owner",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGettableDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGettableDoReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGettableDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGettableDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGettableDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGettableDoReply<'a> {
    type Item = Result<OpGettableDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGettableDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGettableDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGettableDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGettableDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGettableDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGettableDoReply::Owner({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGettableDoReply",
            r#type.and_then(|t| OpGettableDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGettableDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGettableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGettableDoReply::Name(val) => fmt.field("Name", &val),
                OpGettableDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), TableFlags::from_value))
                }
                OpGettableDoReply::Use(val) => fmt.field("Use", &val),
                OpGettableDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGettableDoReply::Userdata(val) => fmt.field("Userdata", &val),
                OpGettableDoReply::Owner(val) => fmt.field("Owner", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGettableDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGettableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGettableDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGettableDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGettableDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGettableDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGettableDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGettableDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGettableDoReply::Owner(val) => {
                    if last_off == offset {
                        stack.push(("Owner", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGettableDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGettableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGettableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGettableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGettableDoRequest<&mut Vec<u8>> {
        PushOpGettableDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGettableDoRequest<RequestBuf<'r>> {
        PushOpGettableDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGettableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGettableDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2561u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGettableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGettableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing table."]
pub struct PushOpDeltableDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDeltableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDeltableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDeltableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing table."]
#[derive(Clone)]
pub enum OpDeltableDoRequest<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "numeric handle of the table"]
    Handle(u64),
}
impl<'a> IterableOpDeltableDoRequest<'a> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDeltableDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDeltableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDeltableDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDeltableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDeltableDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDeltableDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDeltableDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDeltableDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDeltableDoRequest<'a> {
    type Item = Result<OpDeltableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDeltableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDeltableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDeltableDoRequest",
            r#type.and_then(|t| OpDeltableDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDeltableDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDeltableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDeltableDoRequest::Name(val) => fmt.field("Name", &val),
                OpDeltableDoRequest::Handle(val) => fmt.field("Handle", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDeltableDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDeltableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDeltableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDeltableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDeltableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDeltableDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete an existing table."]
pub struct PushOpDeltableDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDeltableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDeltableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDeltableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing table."]
#[derive(Clone)]
pub enum OpDeltableDoReply {}
impl<'a> IterableOpDeltableDoReply<'a> {}
impl OpDeltableDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDeltableDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDeltableDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDeltableDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDeltableDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDeltableDoReply<'a> {
    type Item = Result<OpDeltableDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDeltableDoReply",
            r#type.and_then(|t| OpDeltableDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDeltableDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDeltableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDeltableDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDeltableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDeltableDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDeltableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDeltableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDeltableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDeltableDoRequest<&mut Vec<u8>> {
        PushOpDeltableDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDeltableDoRequest<RequestBuf<'r>> {
        PushOpDeltableDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDeltableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDeltableDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2562u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDeltableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDeltableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing table with destroy semantics (ignoring ENOENT\nerrors).\n"]
pub struct PushOpDestroytableDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroytableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroytableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the table"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 4u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroytableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing table with destroy semantics (ignoring ENOENT\nerrors).\n"]
#[derive(Clone)]
pub enum OpDestroytableDoRequest<'a> {
    #[doc = "name of the table"]
    Name(&'a CStr),
    #[doc = "numeric handle of the table"]
    Handle(u64),
}
impl<'a> IterableOpDestroytableDoRequest<'a> {
    #[doc = "name of the table"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroytableDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the table"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroytableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroytableDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDestroytableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDestroytableDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroytableDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroytableDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroytableDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroytableDoRequest<'a> {
    type Item = Result<OpDestroytableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroytableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroytableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroytableDoRequest",
            r#type.and_then(|t| OpDestroytableDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDestroytableDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroytableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroytableDoRequest::Name(val) => fmt.field("Name", &val),
                OpDestroytableDoRequest::Handle(val) => fmt.field("Handle", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDestroytableDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroytableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroytableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroytableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroytableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroytableDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete an existing table with destroy semantics (ignoring ENOENT\nerrors).\n"]
pub struct PushOpDestroytableDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroytableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroytableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDestroytableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing table with destroy semantics (ignoring ENOENT\nerrors).\n"]
#[derive(Clone)]
pub enum OpDestroytableDoReply {}
impl<'a> IterableOpDestroytableDoReply<'a> {}
impl OpDestroytableDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDestroytableDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroytableDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        TableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroytableDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroytableDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroytableDoReply<'a> {
    type Item = Result<OpDestroytableDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroytableDoReply",
            r#type.and_then(|t| OpDestroytableDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDestroytableDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroytableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDestroytableDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroytableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroytableDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroytableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroytableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroytableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroytableDoRequest<&mut Vec<u8>> {
        PushOpDestroytableDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDestroytableDoRequest<RequestBuf<'r>> {
        PushOpDestroytableDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDestroytableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDestroytableDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2586u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroytableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroytableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new chain."]
pub struct PushOpNewchainDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewchainDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewchainDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewchainDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new chain."]
#[derive(Clone)]
pub enum OpNewchainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(IterableNftHookAttrs<'a>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(IterableNftCounterAttrs<'a>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableOpNewchainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewchainDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewchainDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewchainDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<IterableNftHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewchainDoRequest",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewchainDoRequest",
            "Policy",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewchainDoRequest",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<IterableNftCounterAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewchainDoRequest",
            "Counters",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewchainDoRequest",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewchainDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewchainDoRequest",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpNewchainDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpNewchainDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewchainDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewchainDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewchainDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewchainDoRequest<'a> {
    type Item = Result<OpNewchainDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewchainDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewchainDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewchainDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewchainDoRequest::Hook({
                    let res = Some(IterableNftHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewchainDoRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewchainDoRequest::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpNewchainDoRequest::Counters({
                    let res = Some(IterableNftCounterAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpNewchainDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpNewchainDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewchainDoRequest",
            r#type.and_then(|t| OpNewchainDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpNewchainDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewchainDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewchainDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewchainDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpNewchainDoRequest::Name(val) => fmt.field("Name", &val),
                OpNewchainDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpNewchainDoRequest::Policy(val) => fmt.field("Policy", &val),
                OpNewchainDoRequest::Type(val) => fmt.field("Type", &val),
                OpNewchainDoRequest::Counters(val) => fmt.field("Counters", &val),
                OpNewchainDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpNewchainDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpNewchainDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewchainDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewchainDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewchainDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewchainDoRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewchainDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpNewchainDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewchainDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Create a new chain."]
pub struct PushOpNewchainDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewchainDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewchainDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNewchainDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new chain."]
#[derive(Clone)]
pub enum OpNewchainDoReply {}
impl<'a> IterableOpNewchainDoReply<'a> {}
impl OpNewchainDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpNewchainDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewchainDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewchainDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewchainDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewchainDoReply<'a> {
    type Item = Result<OpNewchainDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewchainDoReply",
            r#type.and_then(|t| OpNewchainDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpNewchainDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewchainDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpNewchainDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewchainDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewchainDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewchainDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewchainDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewchainDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewchainDoRequest<&mut Vec<u8>> {
        PushOpNewchainDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNewchainDoRequest<RequestBuf<'r>> {
        PushOpNewchainDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNewchainDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpNewchainDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2563u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewchainDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewchainDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump chains."]
pub struct PushOpGetchainDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetchainDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetchainDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpGetchainDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump chains."]
#[derive(Clone)]
pub enum OpGetchainDumpRequest {}
impl<'a> IterableOpGetchainDumpRequest<'a> {}
impl OpGetchainDumpRequest {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpGetchainDumpRequest<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetchainDumpRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetchainDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetchainDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetchainDumpRequest<'a> {
    type Item = Result<OpGetchainDumpRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetchainDumpRequest",
            r#type.and_then(|t| OpGetchainDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpGetchainDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetchainDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpGetchainDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetchainDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetchainDumpRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get / dump chains."]
pub struct PushOpGetchainDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetchainDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetchainDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetchainDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump chains."]
#[derive(Clone)]
pub enum OpGetchainDumpReply<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(IterableNftHookAttrs<'a>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(IterableNftCounterAttrs<'a>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableOpGetchainDumpReply<'a> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDumpReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDumpReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDumpReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<IterableNftHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDumpReply",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDumpReply",
            "Policy",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDumpReply",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDumpReply",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<IterableNftCounterAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDumpReply",
            "Counters",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDumpReply",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDumpReply",
            "Id",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDumpReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetchainDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetchainDumpReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetchainDumpReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetchainDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetchainDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetchainDumpReply<'a> {
    type Item = Result<OpGetchainDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetchainDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetchainDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetchainDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetchainDumpReply::Hook({
                    let res = Some(IterableNftHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetchainDumpReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetchainDumpReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetchainDumpReply::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetchainDumpReply::Counters({
                    let res = Some(IterableNftCounterAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetchainDumpReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetchainDumpReply::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetchainDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetchainDumpReply",
            r#type.and_then(|t| OpGetchainDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetchainDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetchainDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetchainDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetchainDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetchainDumpReply::Name(val) => fmt.field("Name", &val),
                OpGetchainDumpReply::Hook(val) => fmt.field("Hook", &val),
                OpGetchainDumpReply::Policy(val) => fmt.field("Policy", &val),
                OpGetchainDumpReply::Use(val) => fmt.field("Use", &val),
                OpGetchainDumpReply::Type(val) => fmt.field("Type", &val),
                OpGetchainDumpReply::Counters(val) => fmt.field("Counters", &val),
                OpGetchainDumpReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpGetchainDumpReply::Id(val) => fmt.field("Id", &val),
                OpGetchainDumpReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetchainDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetchainDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetchainDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetchainDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDumpReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDumpReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetchainDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetchainDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetchainDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetchainDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetchainDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetchainDumpRequest<&mut Vec<u8>> {
        PushOpGetchainDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetchainDumpRequest<RequestBuf<'r>> {
        PushOpGetchainDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetchainDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetchainDumpReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2564u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetchainDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetchainDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump chains."]
pub struct PushOpGetchainDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetchainDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetchainDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetchainDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump chains."]
#[derive(Clone)]
pub enum OpGetchainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "name of the chain"]
    Name(&'a CStr),
}
impl<'a> IterableOpGetchainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetchainDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetchainDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetchainDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetchainDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetchainDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetchainDoRequest<'a> {
    type Item = Result<OpGetchainDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetchainDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetchainDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetchainDoRequest",
            r#type.and_then(|t| OpGetchainDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetchainDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetchainDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetchainDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetchainDoRequest::Name(val) => fmt.field("Name", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetchainDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetchainDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetchainDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetchainDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetchainDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetchainDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump chains."]
pub struct PushOpGetchainDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetchainDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetchainDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric policy of the chain"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "number of references to this chain"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "type name of the chain"]
    pub fn push_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "counter specification of the chain"]
    pub fn nested_counters(mut self) -> PushNftCounterAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 8u16);
        PushNftCounterAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 11u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetchainDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump chains."]
#[derive(Clone)]
pub enum OpGetchainDoReply<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(IterableNftHookAttrs<'a>),
    #[doc = "numeric policy of the chain"]
    Policy(u32),
    #[doc = "number of references to this chain"]
    Use(u32),
    #[doc = "type name of the chain"]
    Type(&'a CStr),
    #[doc = "counter specification of the chain"]
    Counters(IterableNftCounterAttrs<'a>),
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    Flags(u32),
    #[doc = "uniquely identifies a chain in a transaction"]
    Id(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableOpGetchainDoReply<'a> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<IterableNftHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoReply",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric policy of the chain"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoReply",
            "Policy",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "number of references to this chain"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoReply",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "type name of the chain"]
    pub fn get_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoReply",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "counter specification of the chain"]
    pub fn get_counters(&self) -> Result<IterableNftCounterAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Counters(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoReply",
            "Counters",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "chain flags\nAssociated type: \"ChainFlags\" (1 bit per enumeration)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoReply",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "uniquely identifies a chain in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoReply",
            "Id",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetchainDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetchainDoReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetchainDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetchainDoReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetchainDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetchainDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetchainDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetchainDoReply<'a> {
    type Item = Result<OpGetchainDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetchainDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetchainDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetchainDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetchainDoReply::Hook({
                    let res = Some(IterableNftHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetchainDoReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetchainDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetchainDoReply::Type({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetchainDoReply::Counters({
                    let res = Some(IterableNftCounterAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetchainDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpGetchainDoReply::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpGetchainDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetchainDoReply",
            r#type.and_then(|t| OpGetchainDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetchainDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetchainDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetchainDoReply::Table(val) => fmt.field("Table", &val),
                OpGetchainDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetchainDoReply::Name(val) => fmt.field("Name", &val),
                OpGetchainDoReply::Hook(val) => fmt.field("Hook", &val),
                OpGetchainDoReply::Policy(val) => fmt.field("Policy", &val),
                OpGetchainDoReply::Use(val) => fmt.field("Use", &val),
                OpGetchainDoReply::Type(val) => fmt.field("Type", &val),
                OpGetchainDoReply::Counters(val) => fmt.field("Counters", &val),
                OpGetchainDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), ChainFlags::from_value))
                }
                OpGetchainDoReply::Id(val) => fmt.field("Id", &val),
                OpGetchainDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetchainDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetchainDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetchainDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetchainDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDoReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Counters(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetchainDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetchainDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetchainDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetchainDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetchainDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetchainDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetchainDoRequest<&mut Vec<u8>> {
        PushOpGetchainDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetchainDoRequest<RequestBuf<'r>> {
        PushOpGetchainDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetchainDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetchainDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2564u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetchainDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetchainDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing chain."]
pub struct PushOpDelchainDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelchainDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelchainDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpDelchainDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing chain."]
#[derive(Clone)]
pub enum OpDelchainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(IterableNftHookAttrs<'a>),
}
impl<'a> IterableOpDelchainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelchainDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelchainDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelchainDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<IterableNftHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelchainDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelchainDoRequest",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDelchainDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDelchainDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelchainDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelchainDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelchainDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelchainDoRequest<'a> {
    type Item = Result<OpDelchainDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelchainDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelchainDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelchainDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelchainDoRequest::Hook({
                    let res = Some(IterableNftHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelchainDoRequest",
            r#type.and_then(|t| OpDelchainDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDelchainDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelchainDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelchainDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelchainDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDelchainDoRequest::Name(val) => fmt.field("Name", &val),
                OpDelchainDoRequest::Hook(val) => fmt.field("Hook", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDelchainDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelchainDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelchainDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelchainDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelchainDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelchainDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelchainDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelchainDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing chain."]
pub struct PushOpDelchainDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelchainDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelchainDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDelchainDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing chain."]
#[derive(Clone)]
pub enum OpDelchainDoReply {}
impl<'a> IterableOpDelchainDoReply<'a> {}
impl OpDelchainDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDelchainDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelchainDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelchainDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelchainDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelchainDoReply<'a> {
    type Item = Result<OpDelchainDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelchainDoReply",
            r#type.and_then(|t| OpDelchainDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDelchainDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelchainDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDelchainDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelchainDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelchainDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDelchainDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelchainDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelchainDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelchainDoRequest<&mut Vec<u8>> {
        PushOpDelchainDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDelchainDoRequest<RequestBuf<'r>> {
        PushOpDelchainDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDelchainDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDelchainDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2565u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelchainDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelchainDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing chain with destroy semantics (ignoring ENOENT\nerrors).\n"]
pub struct PushOpDestroychainDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroychainDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroychainDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the chain"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the chain"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "hook specification for basechains"]
    pub fn nested_hook(mut self) -> PushNftHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushNftHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpDestroychainDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing chain with destroy semantics (ignoring ENOENT\nerrors).\n"]
#[derive(Clone)]
pub enum OpDestroychainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    Table(&'a CStr),
    #[doc = "numeric handle of the chain"]
    Handle(u64),
    #[doc = "name of the chain"]
    Name(&'a CStr),
    #[doc = "hook specification for basechains"]
    Hook(IterableNftHookAttrs<'a>),
}
impl<'a> IterableOpDestroychainDoRequest<'a> {
    #[doc = "name of the table containing the chain"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroychainDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the chain"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroychainDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroychainDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "hook specification for basechains"]
    pub fn get_hook(&self) -> Result<IterableNftHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroychainDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroychainDoRequest",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDestroychainDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDestroychainDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroychainDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroychainDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroychainDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroychainDoRequest<'a> {
    type Item = Result<OpDestroychainDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroychainDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroychainDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroychainDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroychainDoRequest::Hook({
                    let res = Some(IterableNftHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroychainDoRequest",
            r#type.and_then(|t| OpDestroychainDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDestroychainDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroychainDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroychainDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroychainDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDestroychainDoRequest::Name(val) => fmt.field("Name", &val),
                OpDestroychainDoRequest::Hook(val) => fmt.field("Hook", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDestroychainDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroychainDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroychainDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroychainDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroychainDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroychainDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroychainDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroychainDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing chain with destroy semantics (ignoring ENOENT\nerrors).\n"]
pub struct PushOpDestroychainDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroychainDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroychainDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDestroychainDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing chain with destroy semantics (ignoring ENOENT\nerrors).\n"]
#[derive(Clone)]
pub enum OpDestroychainDoReply {}
impl<'a> IterableOpDestroychainDoReply<'a> {}
impl OpDestroychainDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDestroychainDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroychainDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ChainAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroychainDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroychainDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroychainDoReply<'a> {
    type Item = Result<OpDestroychainDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroychainDoReply",
            r#type.and_then(|t| OpDestroychainDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDestroychainDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroychainDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDestroychainDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroychainDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroychainDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroychainDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroychainDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroychainDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroychainDoRequest<&mut Vec<u8>> {
        PushOpDestroychainDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDestroychainDoRequest<RequestBuf<'r>> {
        PushOpDestroychainDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDestroychainDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDestroychainDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2587u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroychainDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroychainDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new rule."]
pub struct PushOpNewruleDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewruleDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewruleDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn nested_compat(mut self) -> PushRuleCompatAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 5u16);
        PushRuleCompatAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn push_position_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn push_chain_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewruleDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new rule."]
#[derive(Clone)]
pub enum OpNewruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(IterableExprListAttrs<'a>),
    #[doc = "compatibility specifications of the rule"]
    Compat(IterableRuleCompatAttrs<'a>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "transaction unique identifier of the previous rule"]
    PositionId(u32),
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    ChainId(u32),
}
impl<'a> IterableOpNewruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewruleDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewruleDoRequest",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewruleDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableExprListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewruleDoRequest",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "compatibility specifications of the rule"]
    pub fn get_compat(&self) -> Result<IterableRuleCompatAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Compat(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewruleDoRequest",
            "Compat",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewruleDoRequest",
            "Position",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewruleDoRequest",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "transaction unique identifier of the previous rule"]
    pub fn get_position_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::PositionId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewruleDoRequest",
            "PositionId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "add the rule to chain by ID, alternative to chain name"]
    pub fn get_chain_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewruleDoRequest::ChainId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewruleDoRequest",
            "ChainId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpNewruleDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpNewruleDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewruleDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewruleDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewruleDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewruleDoRequest<'a> {
    type Item = Result<OpNewruleDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewruleDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewruleDoRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewruleDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewruleDoRequest::Expressions({
                    let res = Some(IterableExprListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewruleDoRequest::Compat({
                    let res = Some(IterableRuleCompatAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewruleDoRequest::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewruleDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpNewruleDoRequest::PositionId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpNewruleDoRequest::ChainId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewruleDoRequest",
            r#type.and_then(|t| OpNewruleDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpNewruleDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewruleDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewruleDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewruleDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpNewruleDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpNewruleDoRequest::Expressions(val) => fmt.field("Expressions", &val),
                OpNewruleDoRequest::Compat(val) => fmt.field("Compat", &val),
                OpNewruleDoRequest::Position(val) => fmt.field("Position", &val),
                OpNewruleDoRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpNewruleDoRequest::PositionId(val) => fmt.field("PositionId", &val),
                OpNewruleDoRequest::ChainId(val) => fmt.field("ChainId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpNewruleDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewruleDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewruleDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewruleDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewruleDoRequest::Compat(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewruleDoRequest::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::PositionId(val) => {
                    if last_off == offset {
                        stack.push(("PositionId", last_off));
                        break;
                    }
                }
                OpNewruleDoRequest::ChainId(val) => {
                    if last_off == offset {
                        stack.push(("ChainId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewruleDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Create a new rule."]
pub struct PushOpNewruleDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewruleDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewruleDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNewruleDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new rule."]
#[derive(Clone)]
pub enum OpNewruleDoReply {}
impl<'a> IterableOpNewruleDoReply<'a> {}
impl OpNewruleDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpNewruleDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewruleDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewruleDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewruleDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewruleDoReply<'a> {
    type Item = Result<OpNewruleDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewruleDoReply",
            r#type.and_then(|t| OpNewruleDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpNewruleDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewruleDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpNewruleDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewruleDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewruleDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewruleDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewruleDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewruleDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewruleDoRequest<&mut Vec<u8>> {
        PushOpNewruleDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNewruleDoRequest<RequestBuf<'r>> {
        PushOpNewruleDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNewruleDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpNewruleDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2566u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewruleDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewruleDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rules."]
pub struct PushOpGetruleDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules."]
#[derive(Clone)]
pub enum OpGetruleDumpRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
}
impl<'a> IterableOpGetruleDumpRequest<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDumpRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDumpRequest",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetruleDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetruleDumpRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetruleDumpRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetruleDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetruleDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetruleDumpRequest<'a> {
    type Item = Result<OpGetruleDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleDumpRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetruleDumpRequest",
            r#type.and_then(|t| OpGetruleDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetruleDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetruleDumpRequest::Chain(val) => fmt.field("Chain", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetruleDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleDumpRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump rules."]
pub struct PushOpGetruleDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules."]
#[derive(Clone)]
pub enum OpGetruleDumpReply<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(IterableExprListAttrs<'a>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableOpGetruleDumpReply<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDumpReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDumpReply",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDumpReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableExprListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDumpReply",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDumpReply",
            "Position",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDumpReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetruleDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetruleDumpReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetruleDumpReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetruleDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetruleDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetruleDumpReply<'a> {
    type Item = Result<OpGetruleDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleDumpReply::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleDumpReply::Expressions({
                    let res = Some(IterableExprListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleDumpReply::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetruleDumpReply",
            r#type.and_then(|t| OpGetruleDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetruleDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetruleDumpReply::Chain(val) => fmt.field("Chain", &val),
                OpGetruleDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetruleDumpReply::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleDumpReply::Position(val) => fmt.field("Position", &val),
                OpGetruleDumpReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetruleDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleDumpReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleDumpReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleDumpReply::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetruleDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetruleDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetruleDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetruleDumpRequest<&mut Vec<u8>> {
        PushOpGetruleDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetruleDumpRequest<RequestBuf<'r>> {
        PushOpGetruleDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetruleDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetruleDumpReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2567u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetruleDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetruleDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rules."]
pub struct PushOpGetruleDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules."]
#[derive(Clone)]
pub enum OpGetruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
}
impl<'a> IterableOpGetruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDoRequest",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetruleDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetruleDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetruleDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetruleDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetruleDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetruleDoRequest<'a> {
    type Item = Result<OpGetruleDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleDoRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetruleDoRequest",
            r#type.and_then(|t| OpGetruleDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetruleDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetruleDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpGetruleDoRequest::Handle(val) => fmt.field("Handle", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetruleDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump rules."]
pub struct PushOpGetruleDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules."]
#[derive(Clone)]
pub enum OpGetruleDoReply<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(IterableExprListAttrs<'a>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableOpGetruleDoReply<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDoReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDoReply",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDoReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableExprListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDoReply",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDoReply",
            "Position",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleDoReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetruleDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetruleDoReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetruleDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetruleDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetruleDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetruleDoReply<'a> {
    type Item = Result<OpGetruleDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleDoReply::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleDoReply::Expressions({
                    let res = Some(IterableExprListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleDoReply::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetruleDoReply",
            r#type.and_then(|t| OpGetruleDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetruleDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleDoReply::Table(val) => fmt.field("Table", &val),
                OpGetruleDoReply::Chain(val) => fmt.field("Chain", &val),
                OpGetruleDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetruleDoReply::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleDoReply::Position(val) => fmt.field("Position", &val),
                OpGetruleDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetruleDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleDoReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleDoReply::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetruleDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetruleDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetruleDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetruleDoRequest<&mut Vec<u8>> {
        PushOpGetruleDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetruleDoRequest<RequestBuf<'r>> {
        PushOpGetruleDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetruleDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetruleDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2567u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetruleDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetruleDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
pub struct PushOpGetruleResetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleResetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleResetDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleResetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
#[derive(Clone)]
pub enum OpGetruleResetDumpRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
}
impl<'a> IterableOpGetruleResetDumpRequest<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDumpRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDumpRequest",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDumpRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetruleResetDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetruleResetDumpRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetruleResetDumpRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetruleResetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetruleResetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetruleResetDumpRequest<'a> {
    type Item = Result<OpGetruleResetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleResetDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleResetDumpRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleResetDumpRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetruleResetDumpRequest",
            r#type.and_then(|t| OpGetruleResetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetruleResetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleResetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleResetDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetruleResetDumpRequest::Chain(val) => fmt.field("Chain", &val),
                OpGetruleResetDumpRequest::Handle(val) => fmt.field("Handle", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetruleResetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleResetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleResetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleResetDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleResetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
pub struct PushOpGetruleResetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleResetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleResetDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleResetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
#[derive(Clone)]
pub enum OpGetruleResetDumpReply<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(IterableExprListAttrs<'a>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableOpGetruleResetDumpReply<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDumpReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDumpReply",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDumpReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableExprListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDumpReply",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDumpReply",
            "Position",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDumpReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetruleResetDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetruleResetDumpReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetruleResetDumpReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetruleResetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetruleResetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetruleResetDumpReply<'a> {
    type Item = Result<OpGetruleResetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleResetDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleResetDumpReply::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleResetDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleResetDumpReply::Expressions({
                    let res = Some(IterableExprListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleResetDumpReply::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleResetDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetruleResetDumpReply",
            r#type.and_then(|t| OpGetruleResetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetruleResetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleResetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleResetDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetruleResetDumpReply::Chain(val) => fmt.field("Chain", &val),
                OpGetruleResetDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetruleResetDumpReply::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleResetDumpReply::Position(val) => fmt.field("Position", &val),
                OpGetruleResetDumpReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetruleResetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleResetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleResetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleResetDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleResetDumpReply::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleResetDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleResetDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetruleResetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetruleResetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetruleResetDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetruleResetDumpRequest<&mut Vec<u8>> {
        PushOpGetruleResetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetruleResetDumpRequest<RequestBuf<'r>> {
        PushOpGetruleResetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetruleResetDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetruleResetDumpReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2585u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetruleResetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetruleResetDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
pub struct PushOpGetruleResetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleResetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleResetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleResetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
#[derive(Clone)]
pub enum OpGetruleResetDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
}
impl<'a> IterableOpGetruleResetDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDoRequest",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetruleResetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetruleResetDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetruleResetDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetruleResetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetruleResetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetruleResetDoRequest<'a> {
    type Item = Result<OpGetruleResetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleResetDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleResetDoRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleResetDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetruleResetDoRequest",
            r#type.and_then(|t| OpGetruleResetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetruleResetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleResetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleResetDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetruleResetDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpGetruleResetDoRequest::Handle(val) => fmt.field("Handle", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetruleResetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleResetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleResetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleResetDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleResetDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleResetDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleResetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
pub struct PushOpGetruleResetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetruleResetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetruleResetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn push_position(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetruleResetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rules and reset stateful expressions."]
#[derive(Clone)]
pub enum OpGetruleResetDoReply<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(IterableExprListAttrs<'a>),
    #[doc = "numeric handle of the previous rule"]
    Position(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableOpGetruleResetDoReply<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDoReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDoReply",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDoReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableExprListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDoReply",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the previous rule"]
    pub fn get_position(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Position(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDoReply",
            "Position",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetruleResetDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetruleResetDoReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetruleResetDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetruleResetDoReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetruleResetDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetruleResetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetruleResetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetruleResetDoReply<'a> {
    type Item = Result<OpGetruleResetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetruleResetDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetruleResetDoReply::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetruleResetDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetruleResetDoReply::Expressions({
                    let res = Some(IterableExprListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetruleResetDoReply::Position({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetruleResetDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetruleResetDoReply",
            r#type.and_then(|t| OpGetruleResetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetruleResetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetruleResetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetruleResetDoReply::Table(val) => fmt.field("Table", &val),
                OpGetruleResetDoReply::Chain(val) => fmt.field("Chain", &val),
                OpGetruleResetDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetruleResetDoReply::Expressions(val) => fmt.field("Expressions", &val),
                OpGetruleResetDoReply::Position(val) => fmt.field("Position", &val),
                OpGetruleResetDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetruleResetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetruleResetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetruleResetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetruleResetDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetruleResetDoReply::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpGetruleResetDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetruleResetDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetruleResetDoReply::Position(val) => {
                    if last_off == offset {
                        stack.push(("Position", last_off));
                        break;
                    }
                }
                OpGetruleResetDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetruleResetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetruleResetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetruleResetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetruleResetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetruleResetDoRequest<&mut Vec<u8>> {
        PushOpGetruleResetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetruleResetDoRequest<RequestBuf<'r>> {
        PushOpGetruleResetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetruleResetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetruleResetDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2585u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetruleResetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetruleResetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing rule."]
pub struct PushOpDelruleDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelruleDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelruleDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelruleDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing rule."]
#[derive(Clone)]
pub enum OpDelruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(IterableExprListAttrs<'a>),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
}
impl<'a> IterableOpDelruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelruleDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelruleDoRequest",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelruleDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableExprListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelruleDoRequest",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelruleDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelruleDoRequest",
            "Id",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDelruleDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDelruleDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelruleDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelruleDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelruleDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelruleDoRequest<'a> {
    type Item = Result<OpDelruleDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelruleDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelruleDoRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelruleDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDelruleDoRequest::Expressions({
                    let res = Some(IterableExprListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDelruleDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelruleDoRequest",
            r#type.and_then(|t| OpDelruleDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDelruleDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelruleDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelruleDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelruleDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpDelruleDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDelruleDoRequest::Expressions(val) => fmt.field("Expressions", &val),
                OpDelruleDoRequest::Id(val) => fmt.field("Id", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDelruleDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelruleDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelruleDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelruleDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelruleDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpDelruleDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDelruleDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelruleDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelruleDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing rule."]
pub struct PushOpDelruleDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelruleDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelruleDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDelruleDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing rule."]
#[derive(Clone)]
pub enum OpDelruleDoReply {}
impl<'a> IterableOpDelruleDoReply<'a> {}
impl OpDelruleDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDelruleDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelruleDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelruleDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelruleDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelruleDoReply<'a> {
    type Item = Result<OpDelruleDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelruleDoReply",
            r#type.and_then(|t| OpDelruleDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDelruleDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelruleDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDelruleDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelruleDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelruleDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDelruleDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelruleDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelruleDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelruleDoRequest<&mut Vec<u8>> {
        PushOpDelruleDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDelruleDoRequest<RequestBuf<'r>> {
        PushOpDelruleDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDelruleDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDelruleDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2568u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelruleDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelruleDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing rule with destroy semantics (ignoring ENOENT errors).\n"]
pub struct PushOpDestroyruleDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyruleDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyruleDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the rule"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the chain containing the rule"]
    pub fn push_chain_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "numeric handle of the rule"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 3u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushExprListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        PushExprListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroyruleDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing rule with destroy semantics (ignoring ENOENT errors).\n"]
#[derive(Clone)]
pub enum OpDestroyruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    Table(&'a CStr),
    #[doc = "name of the chain containing the rule"]
    Chain(&'a CStr),
    #[doc = "numeric handle of the rule"]
    Handle(u64),
    #[doc = "list of expressions"]
    Expressions(IterableExprListAttrs<'a>),
    #[doc = "uniquely identifies a rule in a transaction"]
    Id(u32),
}
impl<'a> IterableOpDestroyruleDoRequest<'a> {
    #[doc = "name of the table containing the rule"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyruleDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of the chain containing the rule"]
    pub fn get_chain(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Chain(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyruleDoRequest",
            "Chain",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "numeric handle of the rule"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyruleDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableExprListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyruleDoRequest",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "uniquely identifies a rule in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyruleDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyruleDoRequest",
            "Id",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDestroyruleDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDestroyruleDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroyruleDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroyruleDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroyruleDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroyruleDoRequest<'a> {
    type Item = Result<OpDestroyruleDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroyruleDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroyruleDoRequest::Chain({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroyruleDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpDestroyruleDoRequest::Expressions({
                    let res = Some(IterableExprListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpDestroyruleDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroyruleDoRequest",
            r#type.and_then(|t| OpDestroyruleDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDestroyruleDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyruleDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroyruleDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroyruleDoRequest::Chain(val) => fmt.field("Chain", &val),
                OpDestroyruleDoRequest::Handle(val) => fmt.field("Handle", &val),
                OpDestroyruleDoRequest::Expressions(val) => fmt.field("Expressions", &val),
                OpDestroyruleDoRequest::Id(val) => fmt.field("Id", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDestroyruleDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyruleDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyruleDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroyruleDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroyruleDoRequest::Chain(val) => {
                    if last_off == offset {
                        stack.push(("Chain", last_off));
                        break;
                    }
                }
                OpDestroyruleDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpDestroyruleDoRequest::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroyruleDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroyruleDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing rule with destroy semantics (ignoring ENOENT errors).\n"]
pub struct PushOpDestroyruleDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyruleDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyruleDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDestroyruleDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing rule with destroy semantics (ignoring ENOENT errors).\n"]
#[derive(Clone)]
pub enum OpDestroyruleDoReply {}
impl<'a> IterableOpDestroyruleDoReply<'a> {}
impl OpDestroyruleDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDestroyruleDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroyruleDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        RuleAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroyruleDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroyruleDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroyruleDoReply<'a> {
    type Item = Result<OpDestroyruleDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroyruleDoReply",
            r#type.and_then(|t| OpDestroyruleDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDestroyruleDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyruleDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDestroyruleDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyruleDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyruleDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroyruleDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroyruleDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroyruleDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroyruleDoRequest<&mut Vec<u8>> {
        PushOpDestroyruleDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDestroyruleDoRequest<RequestBuf<'r>> {
        PushOpDestroyruleDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDestroyruleDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDestroyruleDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2588u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroyruleDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroyruleDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new set."]
pub struct PushOpNewsetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewsetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewsetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "default timeout value"]
    pub fn push_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 11u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewsetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new set."]
#[derive(Clone)]
pub enum OpNewsetDoRequest<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(IterableSetDescAttrs<'a>),
    #[doc = "uniquely identifies a set in a transaction"]
    Id(u32),
    #[doc = "default timeout value"]
    Timeout(u64),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
}
impl<'a> IterableOpNewsetDoRequest<'a> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "KeyType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "KeyLen",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "DataType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "DataLen",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "Policy",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<IterableSetDescAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "Desc",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "uniquely identifies a set in a transaction"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "Id",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "default timeout value"]
    pub fn get_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Timeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "Timeout",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "GcInterval",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetDoRequest::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetDoRequest",
            "ObjType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpNewsetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpNewsetDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewsetDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewsetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewsetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewsetDoRequest<'a> {
    type Item = Result<OpNewsetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewsetDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewsetDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewsetDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewsetDoRequest::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpNewsetDoRequest::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpNewsetDoRequest::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewsetDoRequest::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpNewsetDoRequest::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpNewsetDoRequest::Desc({
                    let res = Some(IterableSetDescAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => OpNewsetDoRequest::Id({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpNewsetDoRequest::Timeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpNewsetDoRequest::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpNewsetDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpNewsetDoRequest::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewsetDoRequest",
            r#type.and_then(|t| OpNewsetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpNewsetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewsetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewsetDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewsetDoRequest::Name(val) => fmt.field("Name", &val),
                OpNewsetDoRequest::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpNewsetDoRequest::KeyType(val) => fmt.field("KeyType", &val),
                OpNewsetDoRequest::KeyLen(val) => fmt.field("KeyLen", &val),
                OpNewsetDoRequest::DataType(val) => fmt.field("DataType", &val),
                OpNewsetDoRequest::DataLen(val) => fmt.field("DataLen", &val),
                OpNewsetDoRequest::Policy(val) => fmt.field("Policy", &val),
                OpNewsetDoRequest::Desc(val) => fmt.field("Desc", &val),
                OpNewsetDoRequest::Id(val) => fmt.field("Id", &val),
                OpNewsetDoRequest::Timeout(val) => fmt.field("Timeout", &val),
                OpNewsetDoRequest::GcInterval(val) => fmt.field("GcInterval", &val),
                OpNewsetDoRequest::Userdata(val) => fmt.field("Userdata", &val),
                OpNewsetDoRequest::ObjType(val) => fmt.field("ObjType", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpNewsetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewsetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewsetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewsetDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewsetDoRequest::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Timeout(val) => {
                    if last_off == offset {
                        stack.push(("Timeout", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpNewsetDoRequest::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewsetDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Create a new set."]
pub struct PushOpNewsetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewsetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewsetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNewsetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new set."]
#[derive(Clone)]
pub enum OpNewsetDoReply {}
impl<'a> IterableOpNewsetDoReply<'a> {}
impl OpNewsetDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpNewsetDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewsetDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewsetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewsetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewsetDoReply<'a> {
    type Item = Result<OpNewsetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewsetDoReply",
            r#type.and_then(|t| OpNewsetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpNewsetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewsetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpNewsetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewsetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewsetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewsetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewsetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewsetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewsetDoRequest<&mut Vec<u8>> {
        PushOpNewsetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNewsetDoRequest<RequestBuf<'r>> {
        PushOpNewsetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNewsetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpNewsetDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2569u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewsetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewsetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump sets."]
pub struct PushOpGetsetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump sets."]
#[derive(Clone)]
pub enum OpGetsetDumpRequest<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
}
impl<'a> IterableOpGetsetDumpRequest<'a> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetDumpRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetDumpRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetDumpRequest<'a> {
    type Item = Result<OpGetsetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetDumpRequest",
            r#type.and_then(|t| OpGetsetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetDumpRequest::Table(val) => fmt.field("Table", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump sets."]
pub struct PushOpGetsetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump sets."]
#[derive(Clone)]
pub enum OpGetsetDumpReply<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(IterableSetDescAttrs<'a>),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(IterableExprAttrs<'a>),
    #[doc = "list of expressions"]
    Expressions(IterableSetListAttrs<'a>),
}
impl<'a> IterableOpGetsetDumpReply<'a> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "KeyType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "KeyLen",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "DataType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "DataLen",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "Policy",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<IterableSetDescAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "Desc",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "GcInterval",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "ObjType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(
        &self,
    ) -> MultiAttrIterable<Self, OpGetsetDumpReply<'a>, IterableExprAttrs<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpGetsetDumpReply::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableSetListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDumpReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDumpReply",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetDumpReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetDumpReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetDumpReply<'a> {
    type Item = Result<OpGetsetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetDumpReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetDumpReply::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetsetDumpReply::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetsetDumpReply::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetsetDumpReply::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetsetDumpReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetsetDumpReply::Desc({
                    let res = Some(IterableSetDescAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpGetsetDumpReply::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGetsetDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpGetsetDumpReply::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpGetsetDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpGetsetDumpReply::Expr({
                    let res = Some(IterableExprAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpGetsetDumpReply::Expressions({
                    let res = Some(IterableSetListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetDumpReply",
            r#type.and_then(|t| OpGetsetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetsetDumpReply::Name(val) => fmt.field("Name", &val),
                OpGetsetDumpReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpGetsetDumpReply::KeyType(val) => fmt.field("KeyType", &val),
                OpGetsetDumpReply::KeyLen(val) => fmt.field("KeyLen", &val),
                OpGetsetDumpReply::DataType(val) => fmt.field("DataType", &val),
                OpGetsetDumpReply::DataLen(val) => fmt.field("DataLen", &val),
                OpGetsetDumpReply::Policy(val) => fmt.field("Policy", &val),
                OpGetsetDumpReply::Desc(val) => fmt.field("Desc", &val),
                OpGetsetDumpReply::GcInterval(val) => fmt.field("GcInterval", &val),
                OpGetsetDumpReply::Userdata(val) => fmt.field("Userdata", &val),
                OpGetsetDumpReply::ObjType(val) => fmt.field("ObjType", &val),
                OpGetsetDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetsetDumpReply::Expr(val) => fmt.field("Expr", &val),
                OpGetsetDumpReply::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDumpReply::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetsetDumpReply::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDumpReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetsetDumpRequest<&mut Vec<u8>> {
        PushOpGetsetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetsetDumpRequest<RequestBuf<'r>> {
        PushOpGetsetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetsetDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetsetDumpReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2570u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump sets."]
pub struct PushOpGetsetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump sets."]
#[derive(Clone)]
pub enum OpGetsetDoRequest<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
}
impl<'a> IterableOpGetsetDoRequest<'a> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetDoRequest<'a> {
    type Item = Result<OpGetsetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetDoRequest",
            r#type.and_then(|t| OpGetsetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetsetDoRequest::Name(val) => fmt.field("Name", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump sets."]
pub struct PushOpGetsetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data type, informational purpose only"]
    pub fn push_key_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "key data length"]
    pub fn push_key_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data type"]
    pub fn push_data_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "mapping data length"]
    pub fn push_data_len(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "selection policy"]
    pub fn push_policy(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 8u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set description"]
    pub fn nested_desc(mut self) -> PushSetDescAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 9u16);
        PushSetDescAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "garbage collection interval"]
    pub fn push_gc_interval(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 13u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "stateful object type"]
    pub fn push_obj_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 15u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn nested_expr(mut self) -> PushExprAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 17u16);
        PushExprAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "list of expressions"]
    pub fn nested_expressions(mut self) -> PushSetListAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 18u16);
        PushSetListAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump sets."]
#[derive(Clone)]
pub enum OpGetsetDoReply<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    Flags(u32),
    #[doc = "key data type, informational purpose only"]
    KeyType(u32),
    #[doc = "key data length"]
    KeyLen(u32),
    #[doc = "mapping data type"]
    DataType(u32),
    #[doc = "mapping data length"]
    DataLen(u32),
    #[doc = "selection policy"]
    Policy(u32),
    #[doc = "set description"]
    Desc(IterableSetDescAttrs<'a>),
    #[doc = "garbage collection interval"]
    GcInterval(u32),
    #[doc = "user data"]
    Userdata(&'a [u8]),
    #[doc = "stateful object type"]
    ObjType(u32),
    #[doc = "set handle"]
    Handle(u64),
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    Expr(IterableExprAttrs<'a>),
    #[doc = "list of expressions"]
    Expressions(IterableSetListAttrs<'a>),
}
impl<'a> IterableOpGetsetDoReply<'a> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "bitmask of enum nft_set_flags\nAssociated type: \"SetFlags\" (enum)"]
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "key data type, informational purpose only"]
    pub fn get_key_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::KeyType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "KeyType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "key data length"]
    pub fn get_key_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::KeyLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "KeyLen",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "mapping data type"]
    pub fn get_data_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::DataType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "DataType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "mapping data length"]
    pub fn get_data_len(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::DataLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "DataLen",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "selection policy"]
    pub fn get_policy(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Policy(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "Policy",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set description"]
    pub fn get_desc(&self) -> Result<IterableSetDescAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Desc(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "Desc",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "garbage collection interval"]
    pub fn get_gc_interval(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::GcInterval(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "GcInterval",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type"]
    pub fn get_obj_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::ObjType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "ObjType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set expression\nAttribute may repeat multiple times (treat it as array)"]
    pub fn get_expr(&self) -> MultiAttrIterable<Self, OpGetsetDoReply<'a>, IterableExprAttrs<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpGetsetDoReply::Expr(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "list of expressions"]
    pub fn get_expressions(&self) -> Result<IterableSetListAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetDoReply::Expressions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetDoReply",
            "Expressions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetDoReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetDoReply<'a> {
    type Item = Result<OpGetsetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetsetDoReply::KeyType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetsetDoReply::KeyLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetsetDoReply::DataType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetsetDoReply::DataLen({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetsetDoReply::Policy({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpGetsetDoReply::Desc({
                    let res = Some(IterableSetDescAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => OpGetsetDoReply::GcInterval({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => OpGetsetDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => OpGetsetDoReply::ObjType({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpGetsetDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpGetsetDoReply::Expr({
                    let res = Some(IterableExprAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpGetsetDoReply::Expressions({
                    let res = Some(IterableSetListAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetDoReply",
            r#type.and_then(|t| OpGetsetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetDoReply::Table(val) => fmt.field("Table", &val),
                OpGetsetDoReply::Name(val) => fmt.field("Name", &val),
                OpGetsetDoReply::Flags(val) => {
                    fmt.field("Flags", &FormatFlags(val.into(), SetFlags::from_value))
                }
                OpGetsetDoReply::KeyType(val) => fmt.field("KeyType", &val),
                OpGetsetDoReply::KeyLen(val) => fmt.field("KeyLen", &val),
                OpGetsetDoReply::DataType(val) => fmt.field("DataType", &val),
                OpGetsetDoReply::DataLen(val) => fmt.field("DataLen", &val),
                OpGetsetDoReply::Policy(val) => fmt.field("Policy", &val),
                OpGetsetDoReply::Desc(val) => fmt.field("Desc", &val),
                OpGetsetDoReply::GcInterval(val) => fmt.field("GcInterval", &val),
                OpGetsetDoReply::Userdata(val) => fmt.field("Userdata", &val),
                OpGetsetDoReply::ObjType(val) => fmt.field("ObjType", &val),
                OpGetsetDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetsetDoReply::Expr(val) => fmt.field("Expr", &val),
                OpGetsetDoReply::Expressions(val) => fmt.field("Expressions", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::KeyType(val) => {
                    if last_off == offset {
                        stack.push(("KeyType", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::KeyLen(val) => {
                    if last_off == offset {
                        stack.push(("KeyLen", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::DataType(val) => {
                    if last_off == offset {
                        stack.push(("DataType", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::DataLen(val) => {
                    if last_off == offset {
                        stack.push(("DataLen", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Policy(val) => {
                    if last_off == offset {
                        stack.push(("Policy", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Desc(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDoReply::GcInterval(val) => {
                    if last_off == offset {
                        stack.push(("GcInterval", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::ObjType(val) => {
                    if last_off == offset {
                        stack.push(("ObjType", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetsetDoReply::Expr(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetsetDoReply::Expressions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetsetDoRequest<&mut Vec<u8>> {
        PushOpGetsetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetsetDoRequest<RequestBuf<'r>> {
        PushOpGetsetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetsetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetsetDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2570u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing set."]
pub struct PushOpDelsetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelsetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelsetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelsetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set."]
#[derive(Clone)]
pub enum OpDelsetDoRequest<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "set handle"]
    Handle(u64),
}
impl<'a> IterableOpDelsetDoRequest<'a> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelsetDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelsetDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelsetDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDelsetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDelsetDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelsetDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelsetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelsetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelsetDoRequest<'a> {
    type Item = Result<OpDelsetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelsetDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelsetDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpDelsetDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelsetDoRequest",
            r#type.and_then(|t| OpDelsetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDelsetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelsetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelsetDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelsetDoRequest::Name(val) => fmt.field("Name", &val),
                OpDelsetDoRequest::Handle(val) => fmt.field("Handle", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDelsetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelsetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelsetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelsetDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelsetDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelsetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete an existing set."]
pub struct PushOpDelsetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelsetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelsetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDelsetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set."]
#[derive(Clone)]
pub enum OpDelsetDoReply {}
impl<'a> IterableOpDelsetDoReply<'a> {}
impl OpDelsetDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDelsetDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelsetDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelsetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelsetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelsetDoReply<'a> {
    type Item = Result<OpDelsetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelsetDoReply",
            r#type.and_then(|t| OpDelsetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDelsetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelsetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDelsetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelsetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelsetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDelsetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelsetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelsetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelsetDoRequest<&mut Vec<u8>> {
        PushOpDelsetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDelsetDoRequest<RequestBuf<'r>> {
        PushOpDelsetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDelsetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDelsetDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2571u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelsetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelsetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing set with destroy semantics (ignoring ENOENT errors).\n"]
pub struct PushOpDestroysetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroysetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroysetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "table name"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "table name"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set name"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "set name"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "set handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 16u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroysetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set with destroy semantics (ignoring ENOENT errors).\n"]
#[derive(Clone)]
pub enum OpDestroysetDoRequest<'a> {
    #[doc = "table name"]
    Table(&'a CStr),
    #[doc = "set name"]
    Name(&'a CStr),
    #[doc = "set handle"]
    Handle(u64),
}
impl<'a> IterableOpDestroysetDoRequest<'a> {
    #[doc = "table name"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroysetDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set name"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroysetDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "set handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroysetDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDestroysetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDestroysetDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroysetDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroysetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroysetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroysetDoRequest<'a> {
    type Item = Result<OpDestroysetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroysetDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroysetDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => OpDestroysetDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroysetDoRequest",
            r#type.and_then(|t| OpDestroysetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDestroysetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroysetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroysetDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroysetDoRequest::Name(val) => fmt.field("Name", &val),
                OpDestroysetDoRequest::Handle(val) => fmt.field("Handle", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDestroysetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroysetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroysetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroysetDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroysetDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroysetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete an existing set with destroy semantics (ignoring ENOENT errors).\n"]
pub struct PushOpDestroysetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroysetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroysetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDestroysetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set with destroy semantics (ignoring ENOENT errors).\n"]
#[derive(Clone)]
pub enum OpDestroysetDoReply {}
impl<'a> IterableOpDestroysetDoReply<'a> {}
impl OpDestroysetDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDestroysetDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroysetDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroysetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroysetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroysetDoReply<'a> {
    type Item = Result<OpDestroysetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroysetDoReply",
            r#type.and_then(|t| OpDestroysetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDestroysetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroysetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDestroysetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroysetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroysetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroysetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroysetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroysetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroysetDoRequest<&mut Vec<u8>> {
        PushOpDestroysetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDestroysetDoRequest<RequestBuf<'r>> {
        PushOpDestroysetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDestroysetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDestroysetDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2589u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroysetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroysetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new set element."]
pub struct PushOpNewsetelemDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewsetelemDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewsetelemDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_set_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewsetelemDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new set element."]
#[derive(Clone)]
pub enum OpNewsetelemDoRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(IterableSetelemListElemAttrs<'a>),
    SetId(u32),
}
impl<'a> IterableOpNewsetelemDoRequest<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetelemDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetelemDoRequest",
            "Set",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_elements(&self) -> Result<IterableSetelemListElemAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetelemDoRequest",
            "Elements",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewsetelemDoRequest::SetId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewsetelemDoRequest",
            "SetId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpNewsetelemDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpNewsetelemDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewsetelemDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewsetelemDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewsetelemDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewsetelemDoRequest<'a> {
    type Item = Result<OpNewsetelemDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewsetelemDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewsetelemDoRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewsetelemDoRequest::Elements({
                    let res = Some(IterableSetelemListElemAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewsetelemDoRequest::SetId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewsetelemDoRequest",
            r#type.and_then(|t| OpNewsetelemDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpNewsetelemDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewsetelemDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewsetelemDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewsetelemDoRequest::Set(val) => fmt.field("Set", &val),
                OpNewsetelemDoRequest::Elements(val) => fmt.field("Elements", &val),
                OpNewsetelemDoRequest::SetId(val) => fmt.field("SetId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpNewsetelemDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewsetelemDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewsetelemDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewsetelemDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewsetelemDoRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpNewsetelemDoRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewsetelemDoRequest::SetId(val) => {
                    if last_off == offset {
                        stack.push(("SetId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewsetelemDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Create a new set element."]
pub struct PushOpNewsetelemDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewsetelemDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewsetelemDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNewsetelemDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new set element."]
#[derive(Clone)]
pub enum OpNewsetelemDoReply {}
impl<'a> IterableOpNewsetelemDoReply<'a> {}
impl OpNewsetelemDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpNewsetelemDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewsetelemDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewsetelemDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewsetelemDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewsetelemDoReply<'a> {
    type Item = Result<OpNewsetelemDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewsetelemDoReply",
            r#type.and_then(|t| OpNewsetelemDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpNewsetelemDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewsetelemDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpNewsetelemDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewsetelemDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewsetelemDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewsetelemDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewsetelemDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewsetelemDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewsetelemDoRequest<&mut Vec<u8>> {
        PushOpNewsetelemDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNewsetelemDoRequest<RequestBuf<'r>> {
        PushOpNewsetelemDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNewsetelemDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpNewsetelemDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2572u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewsetelemDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewsetelemDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump set elements."]
pub struct PushOpGetsetelemDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements."]
#[derive(Clone)]
pub enum OpGetsetelemDumpRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
}
impl<'a> IterableOpGetsetelemDumpRequest<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemDumpRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemDumpRequest",
            "Set",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetelemDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetelemDumpRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetelemDumpRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetelemDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetelemDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetelemDumpRequest<'a> {
    type Item = Result<OpGetsetelemDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemDumpRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetelemDumpRequest",
            r#type.and_then(|t| OpGetsetelemDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetelemDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetsetelemDumpRequest::Set(val) => fmt.field("Set", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetelemDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemDumpRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump set elements."]
pub struct PushOpGetsetelemDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements."]
#[derive(Clone)]
pub enum OpGetsetelemDumpReply<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(IterableSetelemListElemAttrs<'a>),
}
impl<'a> IterableOpGetsetelemDumpReply<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemDumpReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpReply::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemDumpReply",
            "Set",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_elements(&self) -> Result<IterableSetelemListElemAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDumpReply::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemDumpReply",
            "Elements",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetelemDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetelemDumpReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetelemDumpReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetelemDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetelemDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetelemDumpReply<'a> {
    type Item = Result<OpGetsetelemDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemDumpReply::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemDumpReply::Elements({
                    let res = Some(IterableSetelemListElemAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetelemDumpReply",
            r#type.and_then(|t| OpGetsetelemDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetelemDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetsetelemDumpReply::Set(val) => fmt.field("Set", &val),
                OpGetsetelemDumpReply::Elements(val) => fmt.field("Elements", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetelemDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemDumpReply::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemDumpReply::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetelemDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetelemDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetelemDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetsetelemDumpRequest<&mut Vec<u8>> {
        PushOpGetsetelemDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetsetelemDumpRequest<RequestBuf<'r>> {
        PushOpGetsetelemDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetsetelemDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetsetelemDumpReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2573u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetelemDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetelemDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump set elements."]
pub struct PushOpGetsetelemDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements."]
#[derive(Clone)]
pub enum OpGetsetelemDoRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(IterableSetelemListElemAttrs<'a>),
}
impl<'a> IterableOpGetsetelemDoRequest<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemDoRequest",
            "Set",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_elements(&self) -> Result<IterableSetelemListElemAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemDoRequest",
            "Elements",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetelemDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetelemDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetelemDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetelemDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetelemDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetelemDoRequest<'a> {
    type Item = Result<OpGetsetelemDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemDoRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemDoRequest::Elements({
                    let res = Some(IterableSetelemListElemAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetelemDoRequest",
            r#type.and_then(|t| OpGetsetelemDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetelemDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetsetelemDoRequest::Set(val) => fmt.field("Set", &val),
                OpGetsetelemDoRequest::Elements(val) => fmt.field("Elements", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetelemDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemDoRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemDoRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump set elements."]
pub struct PushOpGetsetelemDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements."]
#[derive(Clone)]
pub enum OpGetsetelemDoReply<'a> {
    Elements(IterableSetelemListElemAttrs<'a>),
}
impl<'a> IterableOpGetsetelemDoReply<'a> {
    pub fn get_elements(&self) -> Result<IterableSetelemListElemAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemDoReply::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemDoReply",
            "Elements",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetelemDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetelemDoReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetelemDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetelemDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetelemDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetelemDoReply<'a> {
    type Item = Result<OpGetsetelemDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                3u16 => OpGetsetelemDoReply::Elements({
                    let res = Some(IterableSetelemListElemAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetelemDoReply",
            r#type.and_then(|t| OpGetsetelemDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetelemDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemDoReply::Elements(val) => fmt.field("Elements", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetelemDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemDoReply::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetelemDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetelemDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetelemDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetsetelemDoRequest<&mut Vec<u8>> {
        PushOpGetsetelemDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetsetelemDoRequest<RequestBuf<'r>> {
        PushOpGetsetelemDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetsetelemDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetsetelemDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2573u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetelemDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetelemDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
pub struct PushOpGetsetelemResetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemResetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemResetDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemResetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
#[derive(Clone)]
pub enum OpGetsetelemResetDumpRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
}
impl<'a> IterableOpGetsetelemResetDumpRequest<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemResetDumpRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemResetDumpRequest",
            "Set",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetelemResetDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetelemResetDumpRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetelemResetDumpRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetelemResetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetelemResetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetelemResetDumpRequest<'a> {
    type Item = Result<OpGetsetelemResetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemResetDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemResetDumpRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetelemResetDumpRequest",
            r#type.and_then(|t| OpGetsetelemResetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetelemResetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemResetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemResetDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetsetelemResetDumpRequest::Set(val) => fmt.field("Set", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetelemResetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemResetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemResetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemResetDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDumpRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemResetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
pub struct PushOpGetsetelemResetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemResetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemResetDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemResetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
#[derive(Clone)]
pub enum OpGetsetelemResetDumpReply<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(IterableSetelemListElemAttrs<'a>),
}
impl<'a> IterableOpGetsetelemResetDumpReply<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemResetDumpReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpReply::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemResetDumpReply",
            "Set",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_elements(&self) -> Result<IterableSetelemListElemAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDumpReply::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemResetDumpReply",
            "Elements",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetelemResetDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetelemResetDumpReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetelemResetDumpReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetelemResetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetelemResetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetelemResetDumpReply<'a> {
    type Item = Result<OpGetsetelemResetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemResetDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemResetDumpReply::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemResetDumpReply::Elements({
                    let res = Some(IterableSetelemListElemAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetelemResetDumpReply",
            r#type.and_then(|t| OpGetsetelemResetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetelemResetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemResetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemResetDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetsetelemResetDumpReply::Set(val) => fmt.field("Set", &val),
                OpGetsetelemResetDumpReply::Elements(val) => fmt.field("Elements", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetelemResetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemResetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemResetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemResetDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDumpReply::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDumpReply::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemResetDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetelemResetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetelemResetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetelemResetDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetsetelemResetDumpRequest<&mut Vec<u8>> {
        PushOpGetsetelemResetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetsetelemResetDumpRequest<RequestBuf<'r>> {
        PushOpGetsetelemResetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetsetelemResetDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetsetelemResetDumpReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2593u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetelemResetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetelemResetDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
pub struct PushOpGetsetelemResetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemResetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemResetDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemResetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
#[derive(Clone)]
pub enum OpGetsetelemResetDoRequest<'a> {
    Elements(IterableSetelemListElemAttrs<'a>),
}
impl<'a> IterableOpGetsetelemResetDoRequest<'a> {
    pub fn get_elements(&self) -> Result<IterableSetelemListElemAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemResetDoRequest",
            "Elements",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetelemResetDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetelemResetDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetelemResetDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetelemResetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetelemResetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetelemResetDoRequest<'a> {
    type Item = Result<OpGetsetelemResetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                3u16 => OpGetsetelemResetDoRequest::Elements({
                    let res = Some(IterableSetelemListElemAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetelemResetDoRequest",
            r#type.and_then(|t| OpGetsetelemResetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetelemResetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemResetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemResetDoRequest::Elements(val) => fmt.field("Elements", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetelemResetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemResetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemResetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemResetDoRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemResetDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
pub struct PushOpGetsetelemResetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetsetelemResetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetsetelemResetDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetsetelemResetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump set elements and reset stateful expressions."]
#[derive(Clone)]
pub enum OpGetsetelemResetDoReply<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(IterableSetelemListElemAttrs<'a>),
}
impl<'a> IterableOpGetsetelemResetDoReply<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemResetDoReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoReply::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemResetDoReply",
            "Set",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_elements(&self) -> Result<IterableSetelemListElemAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetsetelemResetDoReply::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetsetelemResetDoReply",
            "Elements",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetsetelemResetDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetsetelemResetDoReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetsetelemResetDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetsetelemResetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetsetelemResetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetsetelemResetDoReply<'a> {
    type Item = Result<OpGetsetelemResetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetsetelemResetDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetsetelemResetDoReply::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetsetelemResetDoReply::Elements({
                    let res = Some(IterableSetelemListElemAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetsetelemResetDoReply",
            r#type.and_then(|t| OpGetsetelemResetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetsetelemResetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetsetelemResetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetsetelemResetDoReply::Table(val) => fmt.field("Table", &val),
                OpGetsetelemResetDoReply::Set(val) => fmt.field("Set", &val),
                OpGetsetelemResetDoReply::Elements(val) => fmt.field("Elements", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetsetelemResetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetsetelemResetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetsetelemResetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetsetelemResetDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDoReply::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpGetsetelemResetDoReply::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetsetelemResetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetsetelemResetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetsetelemResetDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetsetelemResetDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetsetelemResetDoRequest<&mut Vec<u8>> {
        PushOpGetsetelemResetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetsetelemResetDoRequest<RequestBuf<'r>> {
        PushOpGetsetelemResetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetsetelemResetDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetsetelemResetDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2593u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetsetelemResetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetsetelemResetDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing set element."]
pub struct PushOpDelsetelemDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelsetelemDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelsetelemDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpDelsetelemDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set element."]
#[derive(Clone)]
pub enum OpDelsetelemDoRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(IterableSetelemListElemAttrs<'a>),
}
impl<'a> IterableOpDelsetelemDoRequest<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetelemDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelsetelemDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetelemDoRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelsetelemDoRequest",
            "Set",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_elements(&self) -> Result<IterableSetelemListElemAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelsetelemDoRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelsetelemDoRequest",
            "Elements",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDelsetelemDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDelsetelemDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelsetelemDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelsetelemDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelsetelemDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelsetelemDoRequest<'a> {
    type Item = Result<OpDelsetelemDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelsetelemDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelsetelemDoRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelsetelemDoRequest::Elements({
                    let res = Some(IterableSetelemListElemAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelsetelemDoRequest",
            r#type.and_then(|t| OpDelsetelemDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDelsetelemDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelsetelemDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelsetelemDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelsetelemDoRequest::Set(val) => fmt.field("Set", &val),
                OpDelsetelemDoRequest::Elements(val) => fmt.field("Elements", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDelsetelemDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelsetelemDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelsetelemDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelsetelemDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelsetelemDoRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpDelsetelemDoRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelsetelemDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing set element."]
pub struct PushOpDelsetelemDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelsetelemDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelsetelemDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDelsetelemDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set element."]
#[derive(Clone)]
pub enum OpDelsetelemDoReply {}
impl<'a> IterableOpDelsetelemDoReply<'a> {}
impl OpDelsetelemDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDelsetelemDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelsetelemDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelsetelemDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelsetelemDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelsetelemDoReply<'a> {
    type Item = Result<OpDelsetelemDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelsetelemDoReply",
            r#type.and_then(|t| OpDelsetelemDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDelsetelemDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelsetelemDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDelsetelemDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelsetelemDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelsetelemDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDelsetelemDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelsetelemDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelsetelemDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelsetelemDoRequest<&mut Vec<u8>> {
        PushOpDelsetelemDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDelsetelemDoRequest<RequestBuf<'r>> {
        PushOpDelsetelemDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDelsetelemDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDelsetelemDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2574u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelsetelemDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelsetelemDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing set element with destroy semantics."]
pub struct PushOpDestroysetelemDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroysetelemDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroysetelemDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_set(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_set_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_elements(mut self) -> PushSetelemListElemAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushSetelemListElemAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpDestroysetelemDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set element with destroy semantics."]
#[derive(Clone)]
pub enum OpDestroysetelemDoRequest<'a> {
    Table(&'a CStr),
    Set(&'a CStr),
    Elements(IterableSetelemListElemAttrs<'a>),
}
impl<'a> IterableOpDestroysetelemDoRequest<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetelemDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroysetelemDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_set(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetelemDoRequest::Set(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroysetelemDoRequest",
            "Set",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_elements(&self) -> Result<IterableSetelemListElemAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroysetelemDoRequest::Elements(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroysetelemDoRequest",
            "Elements",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDestroysetelemDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDestroysetelemDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroysetelemDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroysetelemDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroysetelemDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroysetelemDoRequest<'a> {
    type Item = Result<OpDestroysetelemDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroysetelemDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroysetelemDoRequest::Set({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroysetelemDoRequest::Elements({
                    let res = Some(IterableSetelemListElemAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroysetelemDoRequest",
            r#type.and_then(|t| OpDestroysetelemDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDestroysetelemDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroysetelemDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroysetelemDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroysetelemDoRequest::Set(val) => fmt.field("Set", &val),
                OpDestroysetelemDoRequest::Elements(val) => fmt.field("Elements", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDestroysetelemDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroysetelemDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroysetelemDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroysetelemDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroysetelemDoRequest::Set(val) => {
                    if last_off == offset {
                        stack.push(("Set", last_off));
                        break;
                    }
                }
                OpDestroysetelemDoRequest::Elements(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroysetelemDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing set element with destroy semantics."]
pub struct PushOpDestroysetelemDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroysetelemDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroysetelemDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDestroysetelemDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing set element with destroy semantics."]
#[derive(Clone)]
pub enum OpDestroysetelemDoReply {}
impl<'a> IterableOpDestroysetelemDoReply<'a> {}
impl OpDestroysetelemDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDestroysetelemDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroysetelemDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        SetelemListAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroysetelemDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroysetelemDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroysetelemDoReply<'a> {
    type Item = Result<OpDestroysetelemDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroysetelemDoReply",
            r#type.and_then(|t| OpDestroysetelemDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDestroysetelemDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroysetelemDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDestroysetelemDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroysetelemDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroysetelemDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroysetelemDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroysetelemDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroysetelemDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroysetelemDoRequest<&mut Vec<u8>> {
        PushOpDestroysetelemDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDestroysetelemDoRequest<RequestBuf<'r>> {
        PushOpDestroysetelemDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDestroysetelemDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDestroysetelemDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2590u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroysetelemDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroysetelemDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rule-set generation."]
pub struct PushOpGetgenDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetgenDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetgenDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpGetgenDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rule-set generation."]
#[derive(Clone)]
pub enum OpGetgenDumpRequest {}
impl<'a> IterableOpGetgenDumpRequest<'a> {}
impl OpGetgenDumpRequest {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpGetgenDumpRequest<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetgenDumpRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        GenAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetgenDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetgenDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetgenDumpRequest<'a> {
    type Item = Result<OpGetgenDumpRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetgenDumpRequest",
            r#type.and_then(|t| OpGetgenDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpGetgenDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetgenDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpGetgenDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetgenDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetgenDumpRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get / dump rule-set generation."]
pub struct PushOpGetgenDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetgenDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetgenDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "ruleset generation id"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_pid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_proc_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetgenDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rule-set generation."]
#[derive(Clone)]
pub enum OpGetgenDumpReply<'a> {
    #[doc = "ruleset generation id"]
    Id(u32),
    ProcPid(u32),
    ProcName(&'a CStr),
}
impl<'a> IterableOpGetgenDumpReply<'a> {
    #[doc = "ruleset generation id"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDumpReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetgenDumpReply",
            "Id",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_proc_pid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDumpReply::ProcPid(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetgenDumpReply",
            "ProcPid",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_proc_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDumpReply::ProcName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetgenDumpReply",
            "ProcName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetgenDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetgenDumpReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetgenDumpReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        GenAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetgenDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetgenDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetgenDumpReply<'a> {
    type Item = Result<OpGetgenDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetgenDumpReply::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetgenDumpReply::ProcPid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetgenDumpReply::ProcName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetgenDumpReply",
            r#type.and_then(|t| OpGetgenDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetgenDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetgenDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetgenDumpReply::Id(val) => fmt.field("Id", &val),
                OpGetgenDumpReply::ProcPid(val) => fmt.field("ProcPid", &val),
                OpGetgenDumpReply::ProcName(val) => fmt.field("ProcName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetgenDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetgenDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetgenDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetgenDumpReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetgenDumpReply::ProcPid(val) => {
                    if last_off == offset {
                        stack.push(("ProcPid", last_off));
                        break;
                    }
                }
                OpGetgenDumpReply::ProcName(val) => {
                    if last_off == offset {
                        stack.push(("ProcName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetgenDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGetgenDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetgenDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetgenDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetgenDumpRequest<&mut Vec<u8>> {
        PushOpGetgenDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetgenDumpRequest<RequestBuf<'r>> {
        PushOpGetgenDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetgenDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetgenDumpReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2576u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetgenDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetgenDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump rule-set generation."]
pub struct PushOpGetgenDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetgenDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetgenDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpGetgenDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rule-set generation."]
#[derive(Clone)]
pub enum OpGetgenDoRequest {}
impl<'a> IterableOpGetgenDoRequest<'a> {}
impl OpGetgenDoRequest {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpGetgenDoRequest<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetgenDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        GenAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetgenDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetgenDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetgenDoRequest<'a> {
    type Item = Result<OpGetgenDoRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetgenDoRequest",
            r#type.and_then(|t| OpGetgenDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpGetgenDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetgenDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpGetgenDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetgenDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetgenDoRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get / dump rule-set generation."]
pub struct PushOpGetgenDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetgenDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetgenDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "ruleset generation id"]
    pub fn push_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 1u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_pid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_proc_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            3u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_proc_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 3u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetgenDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump rule-set generation."]
#[derive(Clone)]
pub enum OpGetgenDoReply<'a> {
    #[doc = "ruleset generation id"]
    Id(u32),
    ProcPid(u32),
    ProcName(&'a CStr),
}
impl<'a> IterableOpGetgenDoReply<'a> {
    #[doc = "ruleset generation id"]
    pub fn get_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDoReply::Id(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetgenDoReply",
            "Id",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_proc_pid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDoReply::ProcPid(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetgenDoReply",
            "ProcPid",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_proc_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetgenDoReply::ProcName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetgenDoReply",
            "ProcName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetgenDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetgenDoReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetgenDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        GenAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetgenDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetgenDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetgenDoReply<'a> {
    type Item = Result<OpGetgenDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetgenDoReply::Id({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetgenDoReply::ProcPid({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetgenDoReply::ProcName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetgenDoReply",
            r#type.and_then(|t| OpGetgenDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetgenDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetgenDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetgenDoReply::Id(val) => fmt.field("Id", &val),
                OpGetgenDoReply::ProcPid(val) => fmt.field("ProcPid", &val),
                OpGetgenDoReply::ProcName(val) => fmt.field("ProcName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetgenDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetgenDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetgenDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetgenDoReply::Id(val) => {
                    if last_off == offset {
                        stack.push(("Id", last_off));
                        break;
                    }
                }
                OpGetgenDoReply::ProcPid(val) => {
                    if last_off == offset {
                        stack.push(("ProcPid", last_off));
                        break;
                    }
                }
                OpGetgenDoReply::ProcName(val) => {
                    if last_off == offset {
                        stack.push(("ProcName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetgenDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGetgenDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetgenDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetgenDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetgenDoRequest<&mut Vec<u8>> {
        PushOpGetgenDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetgenDoRequest<RequestBuf<'r>> {
        PushOpGetgenDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetgenDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetgenDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2576u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetgenDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetgenDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new stateful object."]
pub struct PushOpNewobjDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewobjDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewobjDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_counter(mut self) -> PushCounterAttrs<PushDummy<Prev>> {
        self = self.push_type(ObjectType::Counter as u32);
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCounterAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_quota(mut self) -> PushQuotaAttrs<PushDummy<Prev>> {
        self = self.push_type(ObjectType::Quota as u32);
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQuotaAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewobjDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new stateful object."]
#[derive(Clone)]
pub enum OpNewobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableOpNewobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewobjDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewobjDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewobjDoRequest",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewobjDoRequest",
            "Data",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewobjDoRequest::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewobjDoRequest",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpNewobjDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpNewobjDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewobjDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewobjDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewobjDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewobjDoRequest<'a> {
    type Item = Result<OpNewobjDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewobjDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewobjDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewobjDoRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpNewobjDoRequest::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpNewobjDoRequest::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewobjDoRequest",
            r#type.and_then(|t| OpNewobjDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpNewobjDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewobjDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewobjDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewobjDoRequest::Name(val) => fmt.field("Name", &val),
                OpNewobjDoRequest::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpNewobjDoRequest::Data(val) => fmt.field("Data", &val),
                OpNewobjDoRequest::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpNewobjDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewobjDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewobjDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewobjDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewobjDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewobjDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpNewobjDoRequest::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpNewobjDoRequest::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewobjDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Create a new stateful object."]
pub struct PushOpNewobjDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewobjDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewobjDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNewobjDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new stateful object."]
#[derive(Clone)]
pub enum OpNewobjDoReply {}
impl<'a> IterableOpNewobjDoReply<'a> {}
impl OpNewobjDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpNewobjDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewobjDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewobjDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewobjDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewobjDoReply<'a> {
    type Item = Result<OpNewobjDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewobjDoReply",
            r#type.and_then(|t| OpNewobjDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpNewobjDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewobjDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpNewobjDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewobjDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewobjDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewobjDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewobjDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewobjDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewobjDoRequest<&mut Vec<u8>> {
        PushOpNewobjDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNewobjDoRequest<RequestBuf<'r>> {
        PushOpNewobjDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNewobjDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpNewobjDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2578u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewobjDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewobjDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump stateful objects."]
pub struct PushOpGetobjDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetobjDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetobjDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetobjDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump stateful objects."]
#[derive(Clone)]
pub enum OpGetobjDumpRequest<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
}
impl<'a> IterableOpGetobjDumpRequest<'a> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDumpRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDumpRequest",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetobjDumpRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetobjDumpRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetobjDumpRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetobjDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetobjDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetobjDumpRequest<'a> {
    type Item = Result<OpGetobjDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetobjDumpRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetobjDumpRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetobjDumpRequest",
            r#type.and_then(|t| OpGetobjDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetobjDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetobjDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetobjDumpRequest::Table(val) => fmt.field("Table", &val),
                OpGetobjDumpRequest::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetobjDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetobjDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetobjDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetobjDumpRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetobjDumpRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetobjDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump stateful objects."]
pub struct PushOpGetobjDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetobjDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetobjDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_counter(mut self) -> PushCounterAttrs<PushDummy<Prev>> {
        self = self.push_type(ObjectType::Counter as u32);
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCounterAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_quota(mut self) -> PushQuotaAttrs<PushDummy<Prev>> {
        self = self.push_type(ObjectType::Quota as u32);
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQuotaAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetobjDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump stateful objects."]
#[derive(Clone)]
pub enum OpGetobjDumpReply<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableOpGetobjDumpReply<'a> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDumpReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDumpReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDumpReply",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDumpReply",
            "Data",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDumpReply",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDumpReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDumpReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDumpReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetobjDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetobjDumpReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetobjDumpReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetobjDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetobjDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetobjDumpReply<'a> {
    type Item = Result<OpGetobjDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetobjDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetobjDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetobjDumpReply::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetobjDumpReply::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetobjDumpReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetobjDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetobjDumpReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetobjDumpReply",
            r#type.and_then(|t| OpGetobjDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetobjDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetobjDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetobjDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetobjDumpReply::Name(val) => fmt.field("Name", &val),
                OpGetobjDumpReply::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpGetobjDumpReply::Data(val) => fmt.field("Data", &val),
                OpGetobjDumpReply::Use(val) => fmt.field("Use", &val),
                OpGetobjDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetobjDumpReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetobjDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetobjDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetobjDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetobjDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetobjDumpReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetobjDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGetobjDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetobjDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetobjDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetobjDumpRequest<&mut Vec<u8>> {
        PushOpGetobjDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetobjDumpRequest<RequestBuf<'r>> {
        PushOpGetobjDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetobjDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetobjDumpReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2579u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetobjDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetobjDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump stateful objects."]
pub struct PushOpGetobjDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetobjDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetobjDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetobjDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump stateful objects."]
#[derive(Clone)]
pub enum OpGetobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
}
impl<'a> IterableOpGetobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDoRequest",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetobjDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetobjDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetobjDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetobjDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetobjDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetobjDoRequest<'a> {
    type Item = Result<OpGetobjDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetobjDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetobjDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetobjDoRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetobjDoRequest",
            r#type.and_then(|t| OpGetobjDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetobjDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetobjDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetobjDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetobjDoRequest::Name(val) => fmt.field("Name", &val),
                OpGetobjDoRequest::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetobjDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetobjDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetobjDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetobjDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetobjDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetobjDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetobjDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump stateful objects."]
pub struct PushOpGetobjDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetobjDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetobjDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "stateful object data"]
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_counter(mut self) -> PushCounterAttrs<PushDummy<Prev>> {
        self = self.push_type(ObjectType::Counter as u32);
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushCounterAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "Selector attribute is inserted automatically."]
    #[doc = "At most one sub-message attribute is expected per attribute set."]
    pub fn nested_data_quota(mut self) -> PushQuotaAttrs<PushDummy<Prev>> {
        self = self.push_type(ObjectType::Quota as u32);
        let new_header_offset = push_nested_header(self.as_rec_mut(), 4u16);
        let dummy = PushDummy {
            prev: self.prev.take(),
            header_offset: self.header_offset.take(),
        };
        PushQuotaAttrs {
            prev: Some(dummy),
            header_offset: Some(new_header_offset),
        }
    }
    #[doc = "number of references to this expression"]
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 5u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "user data"]
    pub fn push_userdata(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetobjDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump stateful objects."]
#[derive(Clone)]
pub enum OpGetobjDoReply<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "stateful object data"]
    Data(ObjData<'a>),
    #[doc = "number of references to this expression"]
    Use(u32),
    #[doc = "object handle"]
    Handle(u64),
    #[doc = "user data"]
    Userdata(&'a [u8]),
}
impl<'a> IterableOpGetobjDoReply<'a> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDoReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDoReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDoReply",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object data"]
    pub fn get_data(&self) -> Result<ObjData<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Data(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDoReply",
            "Data",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "number of references to this expression"]
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDoReply",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDoReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "user data"]
    pub fn get_userdata(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetobjDoReply::Userdata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetobjDoReply",
            "Userdata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetobjDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetobjDoReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetobjDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetobjDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetobjDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetobjDoReply<'a> {
    type Item = Result<OpGetobjDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetobjDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetobjDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetobjDoReply::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetobjDoReply::Data({
                    let res = {
                        let Ok(selector) = self.get_type() else { break };
                        ObjData::select_with_loc(selector, next, self.orig_loc)
                    };
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetobjDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpGetobjDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => OpGetobjDoReply::Userdata({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetobjDoReply",
            r#type.and_then(|t| OpGetobjDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetobjDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetobjDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetobjDoReply::Table(val) => fmt.field("Table", &val),
                OpGetobjDoReply::Name(val) => fmt.field("Name", &val),
                OpGetobjDoReply::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpGetobjDoReply::Data(val) => fmt.field("Data", &val),
                OpGetobjDoReply::Use(val) => fmt.field("Use", &val),
                OpGetobjDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetobjDoReply::Userdata(val) => fmt.field("Userdata", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetobjDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetobjDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetobjDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetobjDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Data(val) => {
                    if last_off == offset {
                        stack.push(("Data", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetobjDoReply::Userdata(val) => {
                    if last_off == offset {
                        stack.push(("Userdata", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetobjDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpGetobjDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetobjDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetobjDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetobjDoRequest<&mut Vec<u8>> {
        PushOpGetobjDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetobjDoRequest<RequestBuf<'r>> {
        PushOpGetobjDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetobjDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetobjDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2579u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetobjDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetobjDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing stateful object."]
pub struct PushOpDelobjDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelobjDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelobjDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelobjDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing stateful object."]
#[derive(Clone)]
pub enum OpDelobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "object handle"]
    Handle(u64),
}
impl<'a> IterableOpDelobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelobjDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelobjDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelobjDoRequest",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelobjDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelobjDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDelobjDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDelobjDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelobjDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelobjDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelobjDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelobjDoRequest<'a> {
    type Item = Result<OpDelobjDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelobjDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelobjDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelobjDoRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDelobjDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelobjDoRequest",
            r#type.and_then(|t| OpDelobjDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDelobjDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelobjDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelobjDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelobjDoRequest::Name(val) => fmt.field("Name", &val),
                OpDelobjDoRequest::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpDelobjDoRequest::Handle(val) => fmt.field("Handle", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDelobjDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelobjDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelobjDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelobjDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelobjDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelobjDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpDelobjDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelobjDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete an existing stateful object."]
pub struct PushOpDelobjDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelobjDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelobjDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDelobjDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing stateful object."]
#[derive(Clone)]
pub enum OpDelobjDoReply {}
impl<'a> IterableOpDelobjDoReply<'a> {}
impl OpDelobjDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDelobjDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelobjDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelobjDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelobjDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelobjDoReply<'a> {
    type Item = Result<OpDelobjDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelobjDoReply",
            r#type.and_then(|t| OpDelobjDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDelobjDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelobjDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDelobjDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelobjDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelobjDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDelobjDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelobjDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelobjDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelobjDoRequest<&mut Vec<u8>> {
        PushOpDelobjDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDelobjDoRequest<RequestBuf<'r>> {
        PushOpDelobjDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDelobjDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDelobjDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2580u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelobjDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelobjDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing stateful object with destroy semantics."]
pub struct PushOpDestroyobjDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyobjDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyobjDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of the table containing the expression"]
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    #[doc = "name of this expression type"]
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn push_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    #[doc = "object handle"]
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 6u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroyobjDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing stateful object with destroy semantics."]
#[derive(Clone)]
pub enum OpDestroyobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    Table(&'a CStr),
    #[doc = "name of this expression type"]
    Name(&'a CStr),
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    Type(u32),
    #[doc = "object handle"]
    Handle(u64),
}
impl<'a> IterableOpDestroyobjDoRequest<'a> {
    #[doc = "name of the table containing the expression"]
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyobjDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "name of this expression type"]
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyobjDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "stateful object type\nAssociated type: \"ObjectType\" (enum)"]
    pub fn get_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Type(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyobjDoRequest",
            "Type",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "object handle"]
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyobjDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyobjDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDestroyobjDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDestroyobjDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroyobjDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroyobjDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroyobjDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroyobjDoRequest<'a> {
    type Item = Result<OpDestroyobjDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroyobjDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroyobjDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroyobjDoRequest::Type({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => OpDestroyobjDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroyobjDoRequest",
            r#type.and_then(|t| OpDestroyobjDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDestroyobjDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyobjDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroyobjDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroyobjDoRequest::Name(val) => fmt.field("Name", &val),
                OpDestroyobjDoRequest::Type(val) => {
                    fmt.field("Type", &FormatEnum(val.into(), ObjectType::from_value))
                }
                OpDestroyobjDoRequest::Handle(val) => fmt.field("Handle", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDestroyobjDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyobjDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyobjDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroyobjDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroyobjDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroyobjDoRequest::Type(val) => {
                    if last_off == offset {
                        stack.push(("Type", last_off));
                        break;
                    }
                }
                OpDestroyobjDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroyobjDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete an existing stateful object with destroy semantics."]
pub struct PushOpDestroyobjDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyobjDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyobjDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDestroyobjDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing stateful object with destroy semantics."]
#[derive(Clone)]
pub enum OpDestroyobjDoReply {}
impl<'a> IterableOpDestroyobjDoReply<'a> {}
impl OpDestroyobjDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDestroyobjDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroyobjDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        ObjAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroyobjDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroyobjDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroyobjDoReply<'a> {
    type Item = Result<OpDestroyobjDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroyobjDoReply",
            r#type.and_then(|t| OpDestroyobjDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDestroyobjDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyobjDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDestroyobjDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyobjDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyobjDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroyobjDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroyobjDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroyobjDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroyobjDoRequest<&mut Vec<u8>> {
        PushOpDestroyobjDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDestroyobjDoRequest<RequestBuf<'r>> {
        PushOpDestroyobjDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDestroyobjDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDestroyobjDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2591u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroyobjDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroyobjDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Create a new flow table."]
pub struct PushOpNewflowtableDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewflowtableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewflowtableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNewflowtableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new flow table."]
#[derive(Clone)]
pub enum OpNewflowtableDoRequest<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(IterableFlowtableHookAttrs<'a>),
    Flags(u32),
}
impl<'a> IterableOpNewflowtableDoRequest<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewflowtableDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewflowtableDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_hook(&self) -> Result<IterableFlowtableHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewflowtableDoRequest",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNewflowtableDoRequest::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNewflowtableDoRequest",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpNewflowtableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpNewflowtableDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewflowtableDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewflowtableDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewflowtableDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewflowtableDoRequest<'a> {
    type Item = Result<OpNewflowtableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNewflowtableDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNewflowtableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNewflowtableDoRequest::Hook({
                    let res = Some(IterableFlowtableHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpNewflowtableDoRequest::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewflowtableDoRequest",
            r#type.and_then(|t| OpNewflowtableDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpNewflowtableDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewflowtableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNewflowtableDoRequest::Table(val) => fmt.field("Table", &val),
                OpNewflowtableDoRequest::Name(val) => fmt.field("Name", &val),
                OpNewflowtableDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpNewflowtableDoRequest::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpNewflowtableDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewflowtableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewflowtableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNewflowtableDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpNewflowtableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpNewflowtableDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpNewflowtableDoRequest::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNewflowtableDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Create a new flow table."]
pub struct PushOpNewflowtableDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNewflowtableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNewflowtableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNewflowtableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create a new flow table."]
#[derive(Clone)]
pub enum OpNewflowtableDoReply {}
impl<'a> IterableOpNewflowtableDoReply<'a> {}
impl OpNewflowtableDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpNewflowtableDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpNewflowtableDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNewflowtableDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNewflowtableDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNewflowtableDoReply<'a> {
    type Item = Result<OpNewflowtableDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNewflowtableDoReply",
            r#type.and_then(|t| OpNewflowtableDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpNewflowtableDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNewflowtableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpNewflowtableDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpNewflowtableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNewflowtableDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNewflowtableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNewflowtableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpNewflowtableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNewflowtableDoRequest<&mut Vec<u8>> {
        PushOpNewflowtableDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNewflowtableDoRequest<RequestBuf<'r>> {
        PushOpNewflowtableDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNewflowtableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpNewflowtableDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2582u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNewflowtableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNewflowtableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump flow tables."]
pub struct PushOpGetflowtableDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetflowtableDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetflowtableDumpRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpGetflowtableDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump flow tables."]
#[derive(Clone)]
pub enum OpGetflowtableDumpRequest {}
impl<'a> IterableOpGetflowtableDumpRequest<'a> {}
impl OpGetflowtableDumpRequest {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpGetflowtableDumpRequest<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetflowtableDumpRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetflowtableDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetflowtableDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetflowtableDumpRequest<'a> {
    type Item = Result<OpGetflowtableDumpRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetflowtableDumpRequest",
            r#type.and_then(|t| OpGetflowtableDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpGetflowtableDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetflowtableDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpGetflowtableDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetflowtableDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetflowtableDumpRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get / dump flow tables."]
pub struct PushOpGetflowtableDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetflowtableDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetflowtableDumpReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetflowtableDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump flow tables."]
#[derive(Clone)]
pub enum OpGetflowtableDumpReply<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(IterableFlowtableHookAttrs<'a>),
    Use(u32),
    Handle(u64),
    Flags(u32),
}
impl<'a> IterableOpGetflowtableDumpReply<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDumpReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDumpReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_hook(&self) -> Result<IterableFlowtableHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDumpReply",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDumpReply",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDumpReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDumpReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDumpReply",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetflowtableDumpReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetflowtableDumpReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetflowtableDumpReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetflowtableDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetflowtableDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetflowtableDumpReply<'a> {
    type Item = Result<OpGetflowtableDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetflowtableDumpReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetflowtableDumpReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetflowtableDumpReply::Hook({
                    let res = Some(IterableFlowtableHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetflowtableDumpReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetflowtableDumpReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetflowtableDumpReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetflowtableDumpReply",
            r#type.and_then(|t| OpGetflowtableDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetflowtableDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetflowtableDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetflowtableDumpReply::Table(val) => fmt.field("Table", &val),
                OpGetflowtableDumpReply::Name(val) => fmt.field("Name", &val),
                OpGetflowtableDumpReply::Hook(val) => fmt.field("Hook", &val),
                OpGetflowtableDumpReply::Use(val) => fmt.field("Use", &val),
                OpGetflowtableDumpReply::Handle(val) => fmt.field("Handle", &val),
                OpGetflowtableDumpReply::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetflowtableDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetflowtableDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetflowtableDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetflowtableDumpReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetflowtableDumpReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetflowtableDumpReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetflowtableDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetflowtableDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetflowtableDumpRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetflowtableDumpRequest::write_header(&mut request.buf_mut(), header);
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetflowtableDumpRequest<&mut Vec<u8>> {
        PushOpGetflowtableDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetflowtableDumpRequest<RequestBuf<'r>> {
        PushOpGetflowtableDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetflowtableDumpRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetflowtableDumpReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2583u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetflowtableDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetflowtableDumpRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Get / dump flow tables."]
pub struct PushOpGetflowtableDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetflowtableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetflowtableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetflowtableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump flow tables."]
#[derive(Clone)]
pub enum OpGetflowtableDoRequest<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
}
impl<'a> IterableOpGetflowtableDoRequest<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetflowtableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetflowtableDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetflowtableDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetflowtableDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetflowtableDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetflowtableDoRequest<'a> {
    type Item = Result<OpGetflowtableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetflowtableDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetflowtableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetflowtableDoRequest",
            r#type.and_then(|t| OpGetflowtableDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetflowtableDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetflowtableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetflowtableDoRequest::Table(val) => fmt.field("Table", &val),
                OpGetflowtableDoRequest::Name(val) => fmt.field("Name", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetflowtableDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetflowtableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetflowtableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetflowtableDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetflowtableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetflowtableDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get / dump flow tables."]
pub struct PushOpGetflowtableDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetflowtableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetflowtableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_use(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 4u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
    pub fn push_flags(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 7u16, 4 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetflowtableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get / dump flow tables."]
#[derive(Clone)]
pub enum OpGetflowtableDoReply<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(IterableFlowtableHookAttrs<'a>),
    Use(u32),
    Handle(u64),
    Flags(u32),
}
impl<'a> IterableOpGetflowtableDoReply<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDoReply",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDoReply",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_hook(&self) -> Result<IterableFlowtableHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDoReply",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_use(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Use(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDoReply",
            "Use",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDoReply",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flags(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetflowtableDoReply::Flags(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetflowtableDoReply",
            "Flags",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpGetflowtableDoReply<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpGetflowtableDoReply<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpGetflowtableDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetflowtableDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetflowtableDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetflowtableDoReply<'a> {
    type Item = Result<OpGetflowtableDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetflowtableDoReply::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetflowtableDoReply::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpGetflowtableDoReply::Hook({
                    let res = Some(IterableFlowtableHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpGetflowtableDoReply::Use({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpGetflowtableDoReply::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => OpGetflowtableDoReply::Flags({
                    let res = parse_be_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetflowtableDoReply",
            r#type.and_then(|t| OpGetflowtableDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetflowtableDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetflowtableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetflowtableDoReply::Table(val) => fmt.field("Table", &val),
                OpGetflowtableDoReply::Name(val) => fmt.field("Name", &val),
                OpGetflowtableDoReply::Hook(val) => fmt.field("Hook", &val),
                OpGetflowtableDoReply::Use(val) => fmt.field("Use", &val),
                OpGetflowtableDoReply::Handle(val) => fmt.field("Handle", &val),
                OpGetflowtableDoReply::Flags(val) => fmt.field("Flags", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetflowtableDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpGetflowtableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetflowtableDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetflowtableDoReply::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpGetflowtableDoReply::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpGetflowtableDoReply::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpGetflowtableDoReply::Use(val) => {
                    if last_off == offset {
                        stack.push(("Use", last_off));
                        break;
                    }
                }
                OpGetflowtableDoReply::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                OpGetflowtableDoReply::Flags(val) => {
                    if last_off == offset {
                        stack.push(("Flags", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetflowtableDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetflowtableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetflowtableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpGetflowtableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetflowtableDoRequest<&mut Vec<u8>> {
        PushOpGetflowtableDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetflowtableDoRequest<RequestBuf<'r>> {
        PushOpGetflowtableDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetflowtableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpGetflowtableDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2583u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetflowtableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetflowtableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing flow table."]
pub struct PushOpDelflowtableDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelflowtableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelflowtableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDelflowtableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing flow table."]
#[derive(Clone)]
pub enum OpDelflowtableDoRequest<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(IterableFlowtableHookAttrs<'a>),
    Handle(u64),
}
impl<'a> IterableOpDelflowtableDoRequest<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelflowtableDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelflowtableDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_hook(&self) -> Result<IterableFlowtableHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelflowtableDoRequest",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDelflowtableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDelflowtableDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDelflowtableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDelflowtableDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelflowtableDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelflowtableDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelflowtableDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelflowtableDoRequest<'a> {
    type Item = Result<OpDelflowtableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDelflowtableDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDelflowtableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDelflowtableDoRequest::Hook({
                    let res = Some(IterableFlowtableHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDelflowtableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelflowtableDoRequest",
            r#type.and_then(|t| OpDelflowtableDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDelflowtableDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelflowtableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDelflowtableDoRequest::Table(val) => fmt.field("Table", &val),
                OpDelflowtableDoRequest::Name(val) => fmt.field("Name", &val),
                OpDelflowtableDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpDelflowtableDoRequest::Handle(val) => fmt.field("Handle", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDelflowtableDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelflowtableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelflowtableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDelflowtableDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDelflowtableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDelflowtableDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDelflowtableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDelflowtableDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing flow table."]
pub struct PushOpDelflowtableDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDelflowtableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDelflowtableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDelflowtableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing flow table."]
#[derive(Clone)]
pub enum OpDelflowtableDoReply {}
impl<'a> IterableOpDelflowtableDoReply<'a> {}
impl OpDelflowtableDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDelflowtableDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDelflowtableDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDelflowtableDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDelflowtableDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDelflowtableDoReply<'a> {
    type Item = Result<OpDelflowtableDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDelflowtableDoReply",
            r#type.and_then(|t| OpDelflowtableDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDelflowtableDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDelflowtableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDelflowtableDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDelflowtableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDelflowtableDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDelflowtableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDelflowtableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDelflowtableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDelflowtableDoRequest<&mut Vec<u8>> {
        PushOpDelflowtableDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDelflowtableDoRequest<RequestBuf<'r>> {
        PushOpDelflowtableDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDelflowtableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDelflowtableDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2584u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDelflowtableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDelflowtableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete an existing flow table with destroy semantics."]
pub struct PushOpDestroyflowtableDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyflowtableDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyflowtableDoRequest<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_table(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_table_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_hook(mut self) -> PushFlowtableHookAttrs<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 3u16);
        PushFlowtableHookAttrs {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_handle(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 5u16, 8 as u16);
        self.as_rec_mut().extend(value.to_be_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDestroyflowtableDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing flow table with destroy semantics."]
#[derive(Clone)]
pub enum OpDestroyflowtableDoRequest<'a> {
    Table(&'a CStr),
    Name(&'a CStr),
    Hook(IterableFlowtableHookAttrs<'a>),
    Handle(u64),
}
impl<'a> IterableOpDestroyflowtableDoRequest<'a> {
    pub fn get_table(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoRequest::Table(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyflowtableDoRequest",
            "Table",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoRequest::Name(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyflowtableDoRequest",
            "Name",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_hook(&self) -> Result<IterableFlowtableHookAttrs<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoRequest::Hook(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyflowtableDoRequest",
            "Hook",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_handle(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDestroyflowtableDoRequest::Handle(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDestroyflowtableDoRequest",
            "Handle",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl<'a> OpDestroyflowtableDoRequest<'a> {
    pub fn new(buf: &'a [u8]) -> (PushNfgenmsg, IterableOpDestroyflowtableDoRequest<'a>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroyflowtableDoRequest::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroyflowtableDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroyflowtableDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroyflowtableDoRequest<'a> {
    type Item = Result<OpDestroyflowtableDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDestroyflowtableDoRequest::Table({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDestroyflowtableDoRequest::Name({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpDestroyflowtableDoRequest::Hook({
                    let res = Some(IterableFlowtableHookAttrs::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => OpDestroyflowtableDoRequest::Handle({
                    let res = parse_be_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroyflowtableDoRequest",
            r#type.and_then(|t| OpDestroyflowtableDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDestroyflowtableDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyflowtableDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDestroyflowtableDoRequest::Table(val) => fmt.field("Table", &val),
                OpDestroyflowtableDoRequest::Name(val) => fmt.field("Name", &val),
                OpDestroyflowtableDoRequest::Hook(val) => fmt.field("Hook", &val),
                OpDestroyflowtableDoRequest::Handle(val) => fmt.field("Handle", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDestroyflowtableDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyflowtableDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyflowtableDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDestroyflowtableDoRequest::Table(val) => {
                    if last_off == offset {
                        stack.push(("Table", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoRequest::Name(val) => {
                    if last_off == offset {
                        stack.push(("Name", last_off));
                        break;
                    }
                }
                OpDestroyflowtableDoRequest::Hook(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpDestroyflowtableDoRequest::Handle(val) => {
                    if last_off == offset {
                        stack.push(("Handle", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDestroyflowtableDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Delete an existing flow table with destroy semantics."]
pub struct PushOpDestroyflowtableDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDestroyflowtableDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDestroyflowtableDoReply<Prev> {
    pub fn new(mut prev: Prev, header: &PushNfgenmsg) -> Self {
        Self::write_header(&mut prev, header);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev, header: &PushNfgenmsg) {
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDestroyflowtableDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete an existing flow table with destroy semantics."]
#[derive(Clone)]
pub enum OpDestroyflowtableDoReply {}
impl<'a> IterableOpDestroyflowtableDoReply<'a> {}
impl OpDestroyflowtableDoReply {
    pub fn new(buf: &'_ [u8]) -> (PushNfgenmsg, IterableOpDestroyflowtableDoReply<'_>) {
        let (header, attrs) = buf.split_at(buf.len().min(PushNfgenmsg::len()));
        (
            PushNfgenmsg::new_from_slice(header).unwrap_or_default(),
            IterableOpDestroyflowtableDoReply::with_loc(attrs, buf.as_ptr() as usize),
        )
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        FlowtableAttrs::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDestroyflowtableDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDestroyflowtableDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDestroyflowtableDoReply<'a> {
    type Item = Result<OpDestroyflowtableDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDestroyflowtableDoReply",
            r#type.and_then(|t| OpDestroyflowtableDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDestroyflowtableDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDestroyflowtableDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDestroyflowtableDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushNfgenmsg::len() {
            stack.push(("OpDestroyflowtableDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDestroyflowtableDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDestroyflowtableDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDestroyflowtableDoRequest<'r> {
    pub fn new(mut request: Request<'r>, header: &PushNfgenmsg) -> Self {
        PushOpDestroyflowtableDoRequest::write_header(&mut request.buf_mut(), header);
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDestroyflowtableDoRequest<&mut Vec<u8>> {
        PushOpDestroyflowtableDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDestroyflowtableDoRequest<RequestBuf<'r>> {
        PushOpDestroyflowtableDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDestroyflowtableDoRequest<'_> {
    type ReplyType<'buf> = (PushNfgenmsg, IterableOpDestroyflowtableDoReply<'buf>);
    fn protocol(&self) -> Protocol {
        Protocol::Raw {
            protonum: 12u16,
            request_type: 2592u16,
        }
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDestroyflowtableDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDestroyflowtableDoRequest::new(buf)
            .1
            .lookup_attr(offset, missing_type)
    }
}
#[derive(Debug)]
pub struct ChainedFinal<'a> {
    inner: Chained<'a>,
}
#[derive(Debug)]
pub struct Chained<'a> {
    buf: RequestBuf<'a>,
    first_seq: u32,
    lookups: Vec<(&'static str, LookupFn)>,
    last_header_offset: usize,
    last_kind: Option<RequestInfo>,
}
impl<'a> ChainedFinal<'a> {
    pub fn into_chained(self) -> Chained<'a> {
        self.inner
    }
    pub fn buf(&self) -> &Vec<u8> {
        self.inner.buf()
    }
    pub fn buf_mut(&mut self) -> &mut Vec<u8> {
        self.inner.buf_mut()
    }
    fn get_index(&self, seq: u32) -> Option<u32> {
        let min = self.inner.first_seq;
        let max = min.wrapping_add(self.inner.lookups.len() as u32);
        return if min <= max {
            (min..max).contains(&seq).then(|| seq - min)
        } else if min <= seq {
            Some(seq - min)
        } else if seq < max {
            Some(u32::MAX - min + seq)
        } else {
            None
        };
    }
}
impl crate::traits::NetlinkChained for ChainedFinal<'_> {
    fn protonum(&self) -> u16 {
        PROTONUM
    }
    fn payload(&self) -> &[u8] {
        self.buf()
    }
    fn chain_len(&self) -> usize {
        self.inner.lookups.len()
    }
    fn get_index(&self, seq: u32) -> Option<usize> {
        self.get_index(seq).map(|n| n as usize)
    }
    fn name(&self, index: usize) -> &'static str {
        self.inner.lookups[index].0
    }
    fn lookup(&self, index: usize) -> LookupFn {
        self.inner.lookups[index].1
    }
}
impl Chained<'static> {
    pub fn new(first_seq: u32) -> Self {
        Self::new_from_buf(Vec::new(), first_seq)
    }
    pub fn new_from_buf(buf: Vec<u8>, first_seq: u32) -> Self {
        Self {
            buf: RequestBuf::Own(buf),
            first_seq,
            lookups: Vec::new(),
            last_header_offset: 0,
            last_kind: None,
        }
    }
    pub fn into_buf(self) -> Vec<u8> {
        match self.buf {
            RequestBuf::Own(buf) => buf,
            _ => unreachable!(),
        }
    }
}
impl<'a> Chained<'a> {
    pub fn new_with_buf(buf: &'a mut Vec<u8>, first_seq: u32) -> Self {
        Self {
            buf: RequestBuf::Ref(buf),
            first_seq,
            lookups: Vec::new(),
            last_header_offset: 0,
            last_kind: None,
        }
    }
    pub fn finalize(mut self) -> ChainedFinal<'a> {
        self.update_header();
        ChainedFinal { inner: self }
    }
    pub fn request(&mut self) -> Request<'_> {
        self.update_header();
        self.last_header_offset = self.buf().len();
        self.buf_mut()
            .extend_from_slice(PushNlmsghdr::new().as_slice());
        let mut request = Request::new_extend(self.buf.buf_mut());
        self.last_kind = None;
        request.writeback = Some(&mut self.last_kind);
        request
    }
    pub fn buf(&self) -> &Vec<u8> {
        self.buf.buf()
    }
    pub fn buf_mut(&mut self) -> &mut Vec<u8> {
        self.buf.buf_mut()
    }
    fn update_header(&mut self) {
        let Some(RequestInfo {
            protocol,
            flags,
            name,
            lookup,
        }) = self.last_kind
        else {
            if !self.buf().is_empty() {
                assert_eq!(
                    self.last_header_offset + PushNlmsghdr::len(),
                    self.buf().len()
                );
                self.buf.buf_mut().truncate(self.last_header_offset);
            }
            return;
        };
        let header_offset = self.last_header_offset;
        let request_type = match protocol {
            Protocol::Raw { request_type, .. } => request_type,
            Protocol::Generic(_) => unreachable!(),
        };
        let index = self.lookups.len();
        let seq = self.first_seq.wrapping_add(index as u32);
        self.lookups.push((name, lookup));
        let buf = self.buf_mut();
        align(buf);
        let mut header = PushNlmsghdr::new();
        header.set_len((buf.len() - header_offset) as u32);
        header.set_type(request_type);
        header.set_flags(flags | consts::NLM_F_REQUEST as u16 | consts::NLM_F_ACK as u16);
        header.set_seq(seq);
        buf[header_offset..(header_offset + 16)].clone_from_slice(header.as_slice());
    }
}
use crate::traits::LookupFn;
use crate::utils::RequestBuf;
#[derive(Debug)]
pub struct Request<'buf> {
    buf: RequestBuf<'buf>,
    flags: u16,
    writeback: Option<&'buf mut Option<RequestInfo>>,
}
#[allow(unused)]
#[derive(Debug, Clone)]
pub struct RequestInfo {
    protocol: Protocol,
    flags: u16,
    name: &'static str,
    lookup: LookupFn,
}
impl Request<'static> {
    pub fn new() -> Self {
        Self::new_from_buf(Vec::new())
    }
    pub fn new_from_buf(buf: Vec<u8>) -> Self {
        Self {
            flags: 0,
            buf: RequestBuf::Own(buf),
            writeback: None,
        }
    }
    pub fn into_buf(self) -> Vec<u8> {
        match self.buf {
            RequestBuf::Own(buf) => buf,
            _ => unreachable!(),
        }
    }
}
impl<'buf> Request<'buf> {
    pub fn new_with_buf(buf: &'buf mut Vec<u8>) -> Self {
        buf.clear();
        Self::new_extend(buf)
    }
    pub fn new_extend(buf: &'buf mut Vec<u8>) -> Self {
        Self {
            flags: 0,
            buf: RequestBuf::Ref(buf),
            writeback: None,
        }
    }
    fn do_writeback(&mut self, protocol: Protocol, name: &'static str, lookup: LookupFn) {
        let Some(writeback) = &mut self.writeback else {
            return;
        };
        **writeback = Some(RequestInfo {
            protocol,
            flags: self.flags,
            name,
            lookup,
        })
    }
    pub fn buf(&self) -> &Vec<u8> {
        self.buf.buf()
    }
    pub fn buf_mut(&mut self) -> &mut Vec<u8> {
        self.buf.buf_mut()
    }
    #[doc = "Set `NLM_F_CREATE` flag"]
    pub fn set_create(mut self) -> Self {
        self.flags |= consts::NLM_F_CREATE as u16;
        self
    }
    #[doc = "Set `NLM_F_EXCL` flag"]
    pub fn set_excl(mut self) -> Self {
        self.flags |= consts::NLM_F_EXCL as u16;
        self
    }
    #[doc = "Set `NLM_F_REPLACE` flag"]
    pub fn set_replace(mut self) -> Self {
        self.flags |= consts::NLM_F_REPLACE as u16;
        self
    }
    #[doc = "Set `NLM_F_CREATE` and `NLM_F_REPLACE` flag"]
    pub fn set_change(self) -> Self {
        self.set_create().set_replace()
    }
    #[doc = "Set `NLM_F_APPEND` flag"]
    pub fn set_append(mut self) -> Self {
        self.flags |= consts::NLM_F_APPEND as u16;
        self
    }
    #[doc = "Set `NLM_F_DUMP` flag"]
    fn set_dump(mut self) -> Self {
        self.flags |= consts::NLM_F_DUMP as u16;
        self
    }
    pub fn op_getcompat_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetcompatDumpRequest<'buf> {
        let mut res = RequestOpGetcompatDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getcompat-dump-request",
            RequestOpGetcompatDumpRequest::lookup,
        );
        res
    }
    pub fn op_getcompat_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetcompatDoRequest<'buf> {
        let mut res = RequestOpGetcompatDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getcompat-do-request",
            RequestOpGetcompatDoRequest::lookup,
        );
        res
    }
    pub fn op_batch_begin_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpBatchBeginDoRequest<'buf> {
        let mut res = RequestOpBatchBeginDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-batch-begin-do-request",
            RequestOpBatchBeginDoRequest::lookup,
        );
        res
    }
    pub fn op_batch_end_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpBatchEndDoRequest<'buf> {
        let mut res = RequestOpBatchEndDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-batch-end-do-request",
            RequestOpBatchEndDoRequest::lookup,
        );
        res
    }
    pub fn op_newtable_do_request(self, header: &PushNfgenmsg) -> RequestOpNewtableDoRequest<'buf> {
        let mut res = RequestOpNewtableDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-newtable-do-request",
            RequestOpNewtableDoRequest::lookup,
        );
        res
    }
    pub fn op_gettable_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGettableDumpRequest<'buf> {
        let mut res = RequestOpGettableDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-gettable-dump-request",
            RequestOpGettableDumpRequest::lookup,
        );
        res
    }
    pub fn op_gettable_do_request(self, header: &PushNfgenmsg) -> RequestOpGettableDoRequest<'buf> {
        let mut res = RequestOpGettableDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-gettable-do-request",
            RequestOpGettableDoRequest::lookup,
        );
        res
    }
    pub fn op_deltable_do_request(self, header: &PushNfgenmsg) -> RequestOpDeltableDoRequest<'buf> {
        let mut res = RequestOpDeltableDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-deltable-do-request",
            RequestOpDeltableDoRequest::lookup,
        );
        res
    }
    pub fn op_destroytable_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroytableDoRequest<'buf> {
        let mut res = RequestOpDestroytableDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-destroytable-do-request",
            RequestOpDestroytableDoRequest::lookup,
        );
        res
    }
    pub fn op_newchain_do_request(self, header: &PushNfgenmsg) -> RequestOpNewchainDoRequest<'buf> {
        let mut res = RequestOpNewchainDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-newchain-do-request",
            RequestOpNewchainDoRequest::lookup,
        );
        res
    }
    pub fn op_getchain_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetchainDumpRequest<'buf> {
        let mut res = RequestOpGetchainDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getchain-dump-request",
            RequestOpGetchainDumpRequest::lookup,
        );
        res
    }
    pub fn op_getchain_do_request(self, header: &PushNfgenmsg) -> RequestOpGetchainDoRequest<'buf> {
        let mut res = RequestOpGetchainDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getchain-do-request",
            RequestOpGetchainDoRequest::lookup,
        );
        res
    }
    pub fn op_delchain_do_request(self, header: &PushNfgenmsg) -> RequestOpDelchainDoRequest<'buf> {
        let mut res = RequestOpDelchainDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-delchain-do-request",
            RequestOpDelchainDoRequest::lookup,
        );
        res
    }
    pub fn op_destroychain_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroychainDoRequest<'buf> {
        let mut res = RequestOpDestroychainDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-destroychain-do-request",
            RequestOpDestroychainDoRequest::lookup,
        );
        res
    }
    pub fn op_newrule_do_request(self, header: &PushNfgenmsg) -> RequestOpNewruleDoRequest<'buf> {
        let mut res = RequestOpNewruleDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-newrule-do-request",
            RequestOpNewruleDoRequest::lookup,
        );
        res
    }
    pub fn op_getrule_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetruleDumpRequest<'buf> {
        let mut res = RequestOpGetruleDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getrule-dump-request",
            RequestOpGetruleDumpRequest::lookup,
        );
        res
    }
    pub fn op_getrule_do_request(self, header: &PushNfgenmsg) -> RequestOpGetruleDoRequest<'buf> {
        let mut res = RequestOpGetruleDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getrule-do-request",
            RequestOpGetruleDoRequest::lookup,
        );
        res
    }
    pub fn op_getrule_reset_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetruleResetDumpRequest<'buf> {
        let mut res = RequestOpGetruleResetDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getrule-reset-dump-request",
            RequestOpGetruleResetDumpRequest::lookup,
        );
        res
    }
    pub fn op_getrule_reset_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetruleResetDoRequest<'buf> {
        let mut res = RequestOpGetruleResetDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getrule-reset-do-request",
            RequestOpGetruleResetDoRequest::lookup,
        );
        res
    }
    pub fn op_delrule_do_request(self, header: &PushNfgenmsg) -> RequestOpDelruleDoRequest<'buf> {
        let mut res = RequestOpDelruleDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-delrule-do-request",
            RequestOpDelruleDoRequest::lookup,
        );
        res
    }
    pub fn op_destroyrule_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroyruleDoRequest<'buf> {
        let mut res = RequestOpDestroyruleDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-destroyrule-do-request",
            RequestOpDestroyruleDoRequest::lookup,
        );
        res
    }
    pub fn op_newset_do_request(self, header: &PushNfgenmsg) -> RequestOpNewsetDoRequest<'buf> {
        let mut res = RequestOpNewsetDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-newset-do-request",
            RequestOpNewsetDoRequest::lookup,
        );
        res
    }
    pub fn op_getset_dump_request(self, header: &PushNfgenmsg) -> RequestOpGetsetDumpRequest<'buf> {
        let mut res = RequestOpGetsetDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getset-dump-request",
            RequestOpGetsetDumpRequest::lookup,
        );
        res
    }
    pub fn op_getset_do_request(self, header: &PushNfgenmsg) -> RequestOpGetsetDoRequest<'buf> {
        let mut res = RequestOpGetsetDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getset-do-request",
            RequestOpGetsetDoRequest::lookup,
        );
        res
    }
    pub fn op_delset_do_request(self, header: &PushNfgenmsg) -> RequestOpDelsetDoRequest<'buf> {
        let mut res = RequestOpDelsetDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-delset-do-request",
            RequestOpDelsetDoRequest::lookup,
        );
        res
    }
    pub fn op_destroyset_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroysetDoRequest<'buf> {
        let mut res = RequestOpDestroysetDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-destroyset-do-request",
            RequestOpDestroysetDoRequest::lookup,
        );
        res
    }
    pub fn op_newsetelem_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpNewsetelemDoRequest<'buf> {
        let mut res = RequestOpNewsetelemDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-newsetelem-do-request",
            RequestOpNewsetelemDoRequest::lookup,
        );
        res
    }
    pub fn op_getsetelem_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetsetelemDumpRequest<'buf> {
        let mut res = RequestOpGetsetelemDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getsetelem-dump-request",
            RequestOpGetsetelemDumpRequest::lookup,
        );
        res
    }
    pub fn op_getsetelem_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetsetelemDoRequest<'buf> {
        let mut res = RequestOpGetsetelemDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getsetelem-do-request",
            RequestOpGetsetelemDoRequest::lookup,
        );
        res
    }
    pub fn op_getsetelem_reset_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetsetelemResetDumpRequest<'buf> {
        let mut res = RequestOpGetsetelemResetDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getsetelem-reset-dump-request",
            RequestOpGetsetelemResetDumpRequest::lookup,
        );
        res
    }
    pub fn op_getsetelem_reset_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetsetelemResetDoRequest<'buf> {
        let mut res = RequestOpGetsetelemResetDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getsetelem-reset-do-request",
            RequestOpGetsetelemResetDoRequest::lookup,
        );
        res
    }
    pub fn op_delsetelem_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDelsetelemDoRequest<'buf> {
        let mut res = RequestOpDelsetelemDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-delsetelem-do-request",
            RequestOpDelsetelemDoRequest::lookup,
        );
        res
    }
    pub fn op_destroysetelem_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroysetelemDoRequest<'buf> {
        let mut res = RequestOpDestroysetelemDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-destroysetelem-do-request",
            RequestOpDestroysetelemDoRequest::lookup,
        );
        res
    }
    pub fn op_getgen_dump_request(self, header: &PushNfgenmsg) -> RequestOpGetgenDumpRequest<'buf> {
        let mut res = RequestOpGetgenDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getgen-dump-request",
            RequestOpGetgenDumpRequest::lookup,
        );
        res
    }
    pub fn op_getgen_do_request(self, header: &PushNfgenmsg) -> RequestOpGetgenDoRequest<'buf> {
        let mut res = RequestOpGetgenDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getgen-do-request",
            RequestOpGetgenDoRequest::lookup,
        );
        res
    }
    pub fn op_newobj_do_request(self, header: &PushNfgenmsg) -> RequestOpNewobjDoRequest<'buf> {
        let mut res = RequestOpNewobjDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-newobj-do-request",
            RequestOpNewobjDoRequest::lookup,
        );
        res
    }
    pub fn op_getobj_dump_request(self, header: &PushNfgenmsg) -> RequestOpGetobjDumpRequest<'buf> {
        let mut res = RequestOpGetobjDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getobj-dump-request",
            RequestOpGetobjDumpRequest::lookup,
        );
        res
    }
    pub fn op_getobj_do_request(self, header: &PushNfgenmsg) -> RequestOpGetobjDoRequest<'buf> {
        let mut res = RequestOpGetobjDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getobj-do-request",
            RequestOpGetobjDoRequest::lookup,
        );
        res
    }
    pub fn op_delobj_do_request(self, header: &PushNfgenmsg) -> RequestOpDelobjDoRequest<'buf> {
        let mut res = RequestOpDelobjDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-delobj-do-request",
            RequestOpDelobjDoRequest::lookup,
        );
        res
    }
    pub fn op_destroyobj_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroyobjDoRequest<'buf> {
        let mut res = RequestOpDestroyobjDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-destroyobj-do-request",
            RequestOpDestroyobjDoRequest::lookup,
        );
        res
    }
    pub fn op_newflowtable_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpNewflowtableDoRequest<'buf> {
        let mut res = RequestOpNewflowtableDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-newflowtable-do-request",
            RequestOpNewflowtableDoRequest::lookup,
        );
        res
    }
    pub fn op_getflowtable_dump_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetflowtableDumpRequest<'buf> {
        let mut res = RequestOpGetflowtableDumpRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getflowtable-dump-request",
            RequestOpGetflowtableDumpRequest::lookup,
        );
        res
    }
    pub fn op_getflowtable_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpGetflowtableDoRequest<'buf> {
        let mut res = RequestOpGetflowtableDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-getflowtable-do-request",
            RequestOpGetflowtableDoRequest::lookup,
        );
        res
    }
    pub fn op_delflowtable_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDelflowtableDoRequest<'buf> {
        let mut res = RequestOpDelflowtableDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-delflowtable-do-request",
            RequestOpDelflowtableDoRequest::lookup,
        );
        res
    }
    pub fn op_destroyflowtable_do_request(
        self,
        header: &PushNfgenmsg,
    ) -> RequestOpDestroyflowtableDoRequest<'buf> {
        let mut res = RequestOpDestroyflowtableDoRequest::new(self, header);
        res.request.do_writeback(
            res.protocol(),
            "op-destroyflowtable-do-request",
            RequestOpDestroyflowtableDoRequest::lookup,
        );
        res
    }
}
