
# Operation "get-wiphy"

## Do (request)

```rust
PushOpGetWiphyDoRequest::new(&mut vec)
  .push_wiphy(val) // u32
  .push_wdev(val) // u64
  .push_ifindex(val) // u32
  ;
```

```rust
let attrs = OpGetWiphyDoReply::new(buf);

attrs.get_bands(); // u32
attrs.get_cipher_suites(); // &[u8]
attrs.get_control_port_ethertype(); // ()
attrs.get_ext_capa(); // &[u8]
attrs.get_ext_capa_mask(); // &[u8]
attrs.get_ext_features(); // &[u8]

// Associated type: "FeatureFlags" (1 bit per enumeration)
attrs.get_feature_flags(); // u32
attrs.get_generation(); // u32
attrs.get_ht_capability_mask(); // &[u8]
attrs.get_interface_combinations(); // &[u8]
attrs.get_mac(); // &[u8]
attrs.get_max_csa_counters(); // u8
attrs.get_max_match_sets(); // u8
attrs.get_max_num_akm_suites(); // &[u8]
attrs.get_max_num_pmkids(); // u8
attrs.get_max_num_scan_ssids(); // u8
attrs.get_max_num_sched_scan_plans(); // u32
attrs.get_max_num_sched_scan_ssids(); // u8
attrs.get_max_remain_on_channel_duration(); // u32
attrs.get_max_scan_ie_len(); // u16
attrs.get_max_scan_plan_interval(); // u32
attrs.get_max_scan_plan_iterations(); // u32
attrs.get_max_sched_scan_ie_len(); // u16
attrs.get_offchannel_tx_ok(); // ()
{ // Nested RxFrameTypes
  let attrs = attrs.get_rx_frame_types();
  { // Nested Unspecified
    let attrs = attrs.get_unspecified();
    attrs.get_frame_type(); // u16
  }
  { // Nested Adhoc
    let attrs = attrs.get_adhoc();
    attrs.get_frame_type(); // u16
  }
  { // Nested Station
    let attrs = attrs.get_station();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ap
    let attrs = attrs.get_ap();
    attrs.get_frame_type(); // u16
  }
  { // Nested ApVlan
    let attrs = attrs.get_ap_vlan();
    attrs.get_frame_type(); // u16
  }
  { // Nested Wds
    let attrs = attrs.get_wds();
    attrs.get_frame_type(); // u16
  }
  { // Nested Monitor
    let attrs = attrs.get_monitor();
    attrs.get_frame_type(); // u16
  }
  { // Nested MeshPoint
    let attrs = attrs.get_mesh_point();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pClient
    let attrs = attrs.get_p2p_client();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pGo
    let attrs = attrs.get_p2p_go();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pDevice
    let attrs = attrs.get_p2p_device();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ocb
    let attrs = attrs.get_ocb();
    attrs.get_frame_type(); // u16
  }
  { // Nested Nan
    let attrs = attrs.get_nan();
    attrs.get_frame_type(); // u16
  }
}
attrs.get_sar_spec(); // &[u8]
attrs.get_sched_scan_max_reqs(); // u32
{ // Nested SoftwareIftypes
  let attrs = attrs.get_software_iftypes();
  attrs.get_adhoc(); // ()
  attrs.get_station(); // ()
  attrs.get_ap(); // ()
  attrs.get_ap_vlan(); // ()
  attrs.get_wds(); // ()
  attrs.get_monitor(); // ()
  attrs.get_mesh_point(); // ()
  attrs.get_p2p_client(); // ()
  attrs.get_p2p_go(); // ()
  attrs.get_p2p_device(); // ()
  attrs.get_ocb(); // ()
  attrs.get_nan(); // ()
}
attrs.get_support_ap_uapsd(); // ()
{ // Nested SupportedIftypes
  let attrs = attrs.get_supported_iftypes();
  attrs.get_adhoc(); // ()
  attrs.get_station(); // ()
  attrs.get_ap(); // ()
  attrs.get_ap_vlan(); // ()
  attrs.get_wds(); // ()
  attrs.get_monitor(); // ()
  attrs.get_mesh_point(); // ()
  attrs.get_p2p_client(); // ()
  attrs.get_p2p_go(); // ()
  attrs.get_p2p_device(); // ()
  attrs.get_ocb(); // ()
  attrs.get_nan(); // ()
}
attrs.get_tdls_external_setup(); // ()
attrs.get_tdls_support(); // ()
{ // Nested TxFrameTypes
  let attrs = attrs.get_tx_frame_types();
  { // Nested Unspecified
    let attrs = attrs.get_unspecified();
    attrs.get_frame_type(); // u16
  }
  { // Nested Adhoc
    let attrs = attrs.get_adhoc();
    attrs.get_frame_type(); // u16
  }
  { // Nested Station
    let attrs = attrs.get_station();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ap
    let attrs = attrs.get_ap();
    attrs.get_frame_type(); // u16
  }
  { // Nested ApVlan
    let attrs = attrs.get_ap_vlan();
    attrs.get_frame_type(); // u16
  }
  { // Nested Wds
    let attrs = attrs.get_wds();
    attrs.get_frame_type(); // u16
  }
  { // Nested Monitor
    let attrs = attrs.get_monitor();
    attrs.get_frame_type(); // u16
  }
  { // Nested MeshPoint
    let attrs = attrs.get_mesh_point();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pClient
    let attrs = attrs.get_p2p_client();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pGo
    let attrs = attrs.get_p2p_go();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pDevice
    let attrs = attrs.get_p2p_device();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ocb
    let attrs = attrs.get_ocb();
    attrs.get_frame_type(); // u16
  }
  { // Nested Nan
    let attrs = attrs.get_nan();
    attrs.get_frame_type(); // u16
  }
}
attrs.get_txq_limit(); // u32
attrs.get_txq_memory_limit(); // u32
attrs.get_txq_quantum(); // u32
{ // Nested TxqStats
  let attrs = attrs.get_txq_stats();
  attrs.get_backlog_bytes(); // u32
  attrs.get_backlog_packets(); // u32
  attrs.get_flows(); // u32
  attrs.get_drops(); // u32
  attrs.get_ecn_marks(); // u32
  attrs.get_overlimit(); // u32
  attrs.get_overmemory(); // u32
  attrs.get_collisions(); // u32
  attrs.get_tx_bytes(); // u32
  attrs.get_tx_packets(); // u32
  attrs.get_max_flows(); // u32
}
attrs.get_vht_capability_mask(); // &[u8]
attrs.get_wiphy(); // u32
attrs.get_wiphy_antenna_avail_rx(); // u32
attrs.get_wiphy_antenna_avail_tx(); // u32
attrs.get_wiphy_antenna_rx(); // u32
attrs.get_wiphy_antenna_tx(); // u32
{ // Nested WiphyBands
  let attrs = attrs.get_wiphy_bands();
  { // Nested 2ghz

    // 2.4 GHz ISM band
    let attrs = attrs.get_2ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 5ghz

    // around 5 GHz band (4.9 - 5.7 GHz)
    let attrs = attrs.get_5ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 60ghz

    // around 60 GHz band (58.32 - 69.12 GHz)
    let attrs = attrs.get_60ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 6ghz
    let attrs = attrs.get_6ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested S1ghz
    let attrs = attrs.get_s1ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested Lc
    let attrs = attrs.get_lc();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
}
attrs.get_wiphy_coverage_class(); // u8
attrs.get_wiphy_frag_threshold(); // u32
attrs.get_wiphy_name(); // &CStr
attrs.get_wiphy_retry_long(); // u8
attrs.get_wiphy_retry_short(); // u8
attrs.get_wiphy_rts_threshold(); // u32
{ // Nested WowlanTriggersSupported
  let attrs = attrs.get_wowlan_triggers_supported();
  attrs.get_any(); // ()
  attrs.get_disconnect(); // ()
  attrs.get_magic_pkt(); // ()
  attrs.get_pkt_pattern(); // ()
  attrs.get_gtk_rekey_supported(); // ()
  attrs.get_gtk_rekey_failure(); // ()
  attrs.get_eap_ident_request(); // ()
  attrs.get_4way_handshake(); // ()
  attrs.get_rfkill_release(); // ()
  attrs.get_wakeup_pkt_80211(); // ()
  attrs.get_wakeup_pkt_80211_len(); // ()
  attrs.get_wakeup_pkt_8023(); // ()
  attrs.get_wakeup_pkt_8023_len(); // ()
  attrs.get_tcp_connection(); // ()
  attrs.get_wakeup_tcp_match(); // ()
  attrs.get_wakeup_tcp_connlost(); // ()
  attrs.get_wakeup_tcp_nomoretokens(); // ()
  attrs.get_net_detect(); // ()
  attrs.get_net_detect_results(); // ()
  attrs.get_unprotected_deauth_disassoc(); // ()
}
```

### Do (reply)

```rust
PushOpGetWiphyDoReply::new(&mut vec)
  .push_bands(val) // u32
  .push_cipher_suites(val) // &[u8]
  .push_control_port_ethertype(val) // ()
  .push_ext_capa(val) // &[u8]
  .push_ext_capa_mask(val) // &[u8]
  .push_ext_features(val) // &[u8]

  // Associated type: "FeatureFlags" (1 bit per enumeration)
  .push_feature_flags(val) // u32
  .push_generation(val) // u32
  .push_ht_capability_mask(val) // &[u8]
  .push_interface_combinations(val) // &[u8]
  .push_mac(val) // &[u8]
  .push_max_csa_counters(val) // u8
  .push_max_match_sets(val) // u8
  .push_max_num_akm_suites(val) // &[u8]
  .push_max_num_pmkids(val) // u8
  .push_max_num_scan_ssids(val) // u8
  .push_max_num_sched_scan_plans(val) // u32
  .push_max_num_sched_scan_ssids(val) // u8
  .push_max_remain_on_channel_duration(val) // u32
  .push_max_scan_ie_len(val) // u16
  .push_max_scan_plan_interval(val) // u32
  .push_max_scan_plan_iterations(val) // u32
  .push_max_sched_scan_ie_len(val) // u16
  .push_offchannel_tx_ok(val) // ()
  .nested_rx_frame_types()
    .nested_unspecified()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_adhoc()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_station()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ap()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ap_vlan()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_wds()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_monitor()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_mesh_point()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_client()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_go()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_device()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ocb()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_nan()
      .push_frame_type(val) // u16
    .end_nested()
  .end_nested()
  .push_sar_spec(val) // &[u8]
  .push_sched_scan_max_reqs(val) // u32
  .nested_software_iftypes()
    .push_adhoc(val) // ()
    .push_station(val) // ()
    .push_ap(val) // ()
    .push_ap_vlan(val) // ()
    .push_wds(val) // ()
    .push_monitor(val) // ()
    .push_mesh_point(val) // ()
    .push_p2p_client(val) // ()
    .push_p2p_go(val) // ()
    .push_p2p_device(val) // ()
    .push_ocb(val) // ()
    .push_nan(val) // ()
  .end_nested()
  .push_support_ap_uapsd(val) // ()
  .nested_supported_iftypes()
    .push_adhoc(val) // ()
    .push_station(val) // ()
    .push_ap(val) // ()
    .push_ap_vlan(val) // ()
    .push_wds(val) // ()
    .push_monitor(val) // ()
    .push_mesh_point(val) // ()
    .push_p2p_client(val) // ()
    .push_p2p_go(val) // ()
    .push_p2p_device(val) // ()
    .push_ocb(val) // ()
    .push_nan(val) // ()
  .end_nested()
  .push_tdls_external_setup(val) // ()
  .push_tdls_support(val) // ()
  .nested_tx_frame_types()
    .nested_unspecified()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_adhoc()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_station()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ap()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ap_vlan()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_wds()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_monitor()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_mesh_point()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_client()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_go()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_device()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ocb()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_nan()
      .push_frame_type(val) // u16
    .end_nested()
  .end_nested()
  .push_txq_limit(val) // u32
  .push_txq_memory_limit(val) // u32
  .push_txq_quantum(val) // u32
  .nested_txq_stats()
    .push_backlog_bytes(val) // u32
    .push_backlog_packets(val) // u32
    .push_flows(val) // u32
    .push_drops(val) // u32
    .push_ecn_marks(val) // u32
    .push_overlimit(val) // u32
    .push_overmemory(val) // u32
    .push_collisions(val) // u32
    .push_tx_bytes(val) // u32
    .push_tx_packets(val) // u32
    .push_max_flows(val) // u32
  .end_nested()
  .push_vht_capability_mask(val) // &[u8]
  .push_wiphy(val) // u32
  .push_wiphy_antenna_avail_rx(val) // u32
  .push_wiphy_antenna_avail_tx(val) // u32
  .push_wiphy_antenna_rx(val) // u32
  .push_wiphy_antenna_tx(val) // u32
  .nested_wiphy_bands()

    // 2.4 GHz ISM band
    .nested_2ghz()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()

    // around 5 GHz band (4.9 - 5.7 GHz)
    .nested_5ghz()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()

    // around 60 GHz band (58.32 - 69.12 GHz)
    .nested_60ghz()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()
    .nested_6ghz()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()
    .nested_s1ghz()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()
    .nested_lc()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()
  .end_nested()
  .push_wiphy_coverage_class(val) // u8
  .push_wiphy_frag_threshold(val) // u32
  .push_wiphy_name(val) // &CStr
  .push_wiphy_name_bytes(val) // &[u8]
  .push_wiphy_retry_long(val) // u8
  .push_wiphy_retry_short(val) // u8
  .push_wiphy_rts_threshold(val) // u32
  .nested_wowlan_triggers_supported()
    .push_any(val) // ()
    .push_disconnect(val) // ()
    .push_magic_pkt(val) // ()
    .push_pkt_pattern(val) // ()
    .push_gtk_rekey_supported(val) // ()
    .push_gtk_rekey_failure(val) // ()
    .push_eap_ident_request(val) // ()
    .push_4way_handshake(val) // ()
    .push_rfkill_release(val) // ()
    .push_wakeup_pkt_80211(val) // ()
    .push_wakeup_pkt_80211_len(val) // ()
    .push_wakeup_pkt_8023(val) // ()
    .push_wakeup_pkt_8023_len(val) // ()
    .push_tcp_connection(val) // ()
    .push_wakeup_tcp_match(val) // ()
    .push_wakeup_tcp_connlost(val) // ()
    .push_wakeup_tcp_nomoretokens(val) // ()
    .push_net_detect(val) // ()
    .push_net_detect_results(val) // ()
    .push_unprotected_deauth_disassoc(val) // ()
  .end_nested()
  ;
```

```rust
let attrs = OpGetWiphyDoReply::new(buf);

attrs.get_bands(); // u32
attrs.get_cipher_suites(); // &[u8]
attrs.get_control_port_ethertype(); // ()
attrs.get_ext_capa(); // &[u8]
attrs.get_ext_capa_mask(); // &[u8]
attrs.get_ext_features(); // &[u8]

// Associated type: "FeatureFlags" (1 bit per enumeration)
attrs.get_feature_flags(); // u32
attrs.get_generation(); // u32
attrs.get_ht_capability_mask(); // &[u8]
attrs.get_interface_combinations(); // &[u8]
attrs.get_mac(); // &[u8]
attrs.get_max_csa_counters(); // u8
attrs.get_max_match_sets(); // u8
attrs.get_max_num_akm_suites(); // &[u8]
attrs.get_max_num_pmkids(); // u8
attrs.get_max_num_scan_ssids(); // u8
attrs.get_max_num_sched_scan_plans(); // u32
attrs.get_max_num_sched_scan_ssids(); // u8
attrs.get_max_remain_on_channel_duration(); // u32
attrs.get_max_scan_ie_len(); // u16
attrs.get_max_scan_plan_interval(); // u32
attrs.get_max_scan_plan_iterations(); // u32
attrs.get_max_sched_scan_ie_len(); // u16
attrs.get_offchannel_tx_ok(); // ()
{ // Nested RxFrameTypes
  let attrs = attrs.get_rx_frame_types();
  { // Nested Unspecified
    let attrs = attrs.get_unspecified();
    attrs.get_frame_type(); // u16
  }
  { // Nested Adhoc
    let attrs = attrs.get_adhoc();
    attrs.get_frame_type(); // u16
  }
  { // Nested Station
    let attrs = attrs.get_station();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ap
    let attrs = attrs.get_ap();
    attrs.get_frame_type(); // u16
  }
  { // Nested ApVlan
    let attrs = attrs.get_ap_vlan();
    attrs.get_frame_type(); // u16
  }
  { // Nested Wds
    let attrs = attrs.get_wds();
    attrs.get_frame_type(); // u16
  }
  { // Nested Monitor
    let attrs = attrs.get_monitor();
    attrs.get_frame_type(); // u16
  }
  { // Nested MeshPoint
    let attrs = attrs.get_mesh_point();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pClient
    let attrs = attrs.get_p2p_client();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pGo
    let attrs = attrs.get_p2p_go();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pDevice
    let attrs = attrs.get_p2p_device();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ocb
    let attrs = attrs.get_ocb();
    attrs.get_frame_type(); // u16
  }
  { // Nested Nan
    let attrs = attrs.get_nan();
    attrs.get_frame_type(); // u16
  }
}
attrs.get_sar_spec(); // &[u8]
attrs.get_sched_scan_max_reqs(); // u32
{ // Nested SoftwareIftypes
  let attrs = attrs.get_software_iftypes();
  attrs.get_adhoc(); // ()
  attrs.get_station(); // ()
  attrs.get_ap(); // ()
  attrs.get_ap_vlan(); // ()
  attrs.get_wds(); // ()
  attrs.get_monitor(); // ()
  attrs.get_mesh_point(); // ()
  attrs.get_p2p_client(); // ()
  attrs.get_p2p_go(); // ()
  attrs.get_p2p_device(); // ()
  attrs.get_ocb(); // ()
  attrs.get_nan(); // ()
}
attrs.get_support_ap_uapsd(); // ()
{ // Nested SupportedIftypes
  let attrs = attrs.get_supported_iftypes();
  attrs.get_adhoc(); // ()
  attrs.get_station(); // ()
  attrs.get_ap(); // ()
  attrs.get_ap_vlan(); // ()
  attrs.get_wds(); // ()
  attrs.get_monitor(); // ()
  attrs.get_mesh_point(); // ()
  attrs.get_p2p_client(); // ()
  attrs.get_p2p_go(); // ()
  attrs.get_p2p_device(); // ()
  attrs.get_ocb(); // ()
  attrs.get_nan(); // ()
}
attrs.get_tdls_external_setup(); // ()
attrs.get_tdls_support(); // ()
{ // Nested TxFrameTypes
  let attrs = attrs.get_tx_frame_types();
  { // Nested Unspecified
    let attrs = attrs.get_unspecified();
    attrs.get_frame_type(); // u16
  }
  { // Nested Adhoc
    let attrs = attrs.get_adhoc();
    attrs.get_frame_type(); // u16
  }
  { // Nested Station
    let attrs = attrs.get_station();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ap
    let attrs = attrs.get_ap();
    attrs.get_frame_type(); // u16
  }
  { // Nested ApVlan
    let attrs = attrs.get_ap_vlan();
    attrs.get_frame_type(); // u16
  }
  { // Nested Wds
    let attrs = attrs.get_wds();
    attrs.get_frame_type(); // u16
  }
  { // Nested Monitor
    let attrs = attrs.get_monitor();
    attrs.get_frame_type(); // u16
  }
  { // Nested MeshPoint
    let attrs = attrs.get_mesh_point();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pClient
    let attrs = attrs.get_p2p_client();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pGo
    let attrs = attrs.get_p2p_go();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pDevice
    let attrs = attrs.get_p2p_device();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ocb
    let attrs = attrs.get_ocb();
    attrs.get_frame_type(); // u16
  }
  { // Nested Nan
    let attrs = attrs.get_nan();
    attrs.get_frame_type(); // u16
  }
}
attrs.get_txq_limit(); // u32
attrs.get_txq_memory_limit(); // u32
attrs.get_txq_quantum(); // u32
{ // Nested TxqStats
  let attrs = attrs.get_txq_stats();
  attrs.get_backlog_bytes(); // u32
  attrs.get_backlog_packets(); // u32
  attrs.get_flows(); // u32
  attrs.get_drops(); // u32
  attrs.get_ecn_marks(); // u32
  attrs.get_overlimit(); // u32
  attrs.get_overmemory(); // u32
  attrs.get_collisions(); // u32
  attrs.get_tx_bytes(); // u32
  attrs.get_tx_packets(); // u32
  attrs.get_max_flows(); // u32
}
attrs.get_vht_capability_mask(); // &[u8]
attrs.get_wiphy(); // u32
attrs.get_wiphy_antenna_avail_rx(); // u32
attrs.get_wiphy_antenna_avail_tx(); // u32
attrs.get_wiphy_antenna_rx(); // u32
attrs.get_wiphy_antenna_tx(); // u32
{ // Nested WiphyBands
  let attrs = attrs.get_wiphy_bands();
  { // Nested 2ghz

    // 2.4 GHz ISM band
    let attrs = attrs.get_2ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 5ghz

    // around 5 GHz band (4.9 - 5.7 GHz)
    let attrs = attrs.get_5ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 60ghz

    // around 60 GHz band (58.32 - 69.12 GHz)
    let attrs = attrs.get_60ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 6ghz
    let attrs = attrs.get_6ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested S1ghz
    let attrs = attrs.get_s1ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested Lc
    let attrs = attrs.get_lc();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
}
attrs.get_wiphy_coverage_class(); // u8
attrs.get_wiphy_frag_threshold(); // u32
attrs.get_wiphy_name(); // &CStr
attrs.get_wiphy_retry_long(); // u8
attrs.get_wiphy_retry_short(); // u8
attrs.get_wiphy_rts_threshold(); // u32
{ // Nested WowlanTriggersSupported
  let attrs = attrs.get_wowlan_triggers_supported();
  attrs.get_any(); // ()
  attrs.get_disconnect(); // ()
  attrs.get_magic_pkt(); // ()
  attrs.get_pkt_pattern(); // ()
  attrs.get_gtk_rekey_supported(); // ()
  attrs.get_gtk_rekey_failure(); // ()
  attrs.get_eap_ident_request(); // ()
  attrs.get_4way_handshake(); // ()
  attrs.get_rfkill_release(); // ()
  attrs.get_wakeup_pkt_80211(); // ()
  attrs.get_wakeup_pkt_80211_len(); // ()
  attrs.get_wakeup_pkt_8023(); // ()
  attrs.get_wakeup_pkt_8023_len(); // ()
  attrs.get_tcp_connection(); // ()
  attrs.get_wakeup_tcp_match(); // ()
  attrs.get_wakeup_tcp_connlost(); // ()
  attrs.get_wakeup_tcp_nomoretokens(); // ()
  attrs.get_net_detect(); // ()
  attrs.get_net_detect_results(); // ()
  attrs.get_unprotected_deauth_disassoc(); // ()
}
```

## Low-level decoding

### Do (request)

```rust
let iter = OpGetWiphyDoRequest::new(buf);
for attr in iter {
  match attr {
    Wiphy(val) => {}, // u32
    Wdev(val) => {}, // u64
    Ifindex(val) => {}, // u32
  }
}
```

### Do (reply)

```rust
let iter = OpGetWiphyDoReply::new(buf);
for attr in iter {
  match attr {
    Bands(val) => {}, // u32
    CipherSuites(val) => {}, // &[u8]
    ControlPortEthertype(val) => {}, // ()
    ExtCapa(val) => {}, // &[u8]
    ExtCapaMask(val) => {}, // &[u8]
    ExtFeatures(val) => {}, // &[u8]

    // Associated type: "FeatureFlags" (1 bit per enumeration)
    FeatureFlags(val) => {}, // u32
    Generation(val) => {}, // u32
    HtCapabilityMask(val) => {}, // &[u8]
    InterfaceCombinations(val) => {}, // &[u8]
    Mac(val) => {}, // &[u8]
    MaxCsaCounters(val) => {}, // u8
    MaxMatchSets(val) => {}, // u8
    MaxNumAkmSuites(val) => {}, // &[u8]
    MaxNumPmkids(val) => {}, // u8
    MaxNumScanSsids(val) => {}, // u8
    MaxNumSchedScanPlans(val) => {}, // u32
    MaxNumSchedScanSsids(val) => {}, // u8
    MaxRemainOnChannelDuration(val) => {}, // u32
    MaxScanIeLen(val) => {}, // u16
    MaxScanPlanInterval(val) => {}, // u32
    MaxScanPlanIterations(val) => {}, // u32
    MaxSchedScanIeLen(val) => {}, // u16
    OffchannelTxOk(val) => {}, // ()
    RxFrameTypes(iter) => {
      for attr in iter {
        match attr {
          Unspecified(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Adhoc(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Station(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Ap(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          ApVlan(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Wds(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Monitor(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          MeshPoint(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pClient(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pGo(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pDevice(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Ocb(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Nan(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
        }
      }
    },
    SarSpec(val) => {}, // &[u8]
    SchedScanMaxReqs(val) => {}, // u32
    SoftwareIftypes(iter) => {
      for attr in iter {
        match attr {
          Adhoc(val) => {}, // ()
          Station(val) => {}, // ()
          Ap(val) => {}, // ()
          ApVlan(val) => {}, // ()
          Wds(val) => {}, // ()
          Monitor(val) => {}, // ()
          MeshPoint(val) => {}, // ()
          P2pClient(val) => {}, // ()
          P2pGo(val) => {}, // ()
          P2pDevice(val) => {}, // ()
          Ocb(val) => {}, // ()
          Nan(val) => {}, // ()
        }
      }
    },
    SupportApUapsd(val) => {}, // ()
    SupportedIftypes(iter) => {
      for attr in iter {
        match attr {
          Adhoc(val) => {}, // ()
          Station(val) => {}, // ()
          Ap(val) => {}, // ()
          ApVlan(val) => {}, // ()
          Wds(val) => {}, // ()
          Monitor(val) => {}, // ()
          MeshPoint(val) => {}, // ()
          P2pClient(val) => {}, // ()
          P2pGo(val) => {}, // ()
          P2pDevice(val) => {}, // ()
          Ocb(val) => {}, // ()
          Nan(val) => {}, // ()
        }
      }
    },
    TdlsExternalSetup(val) => {}, // ()
    TdlsSupport(val) => {}, // ()
    TxFrameTypes(iter) => {
      for attr in iter {
        match attr {
          Unspecified(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Adhoc(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Station(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Ap(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          ApVlan(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Wds(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Monitor(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          MeshPoint(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pClient(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pGo(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pDevice(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Ocb(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Nan(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
        }
      }
    },
    TxqLimit(val) => {}, // u32
    TxqMemoryLimit(val) => {}, // u32
    TxqQuantum(val) => {}, // u32
    TxqStats(iter) => {
      for attr in iter {
        match attr {
          BacklogBytes(val) => {}, // u32
          BacklogPackets(val) => {}, // u32
          Flows(val) => {}, // u32
          Drops(val) => {}, // u32
          EcnMarks(val) => {}, // u32
          Overlimit(val) => {}, // u32
          Overmemory(val) => {}, // u32
          Collisions(val) => {}, // u32
          TxBytes(val) => {}, // u32
          TxPackets(val) => {}, // u32
          MaxFlows(val) => {}, // u32
        }
      }
    },
    VhtCapabilityMask(val) => {}, // &[u8]
    Wiphy(val) => {}, // u32
    WiphyAntennaAvailRx(val) => {}, // u32
    WiphyAntennaAvailTx(val) => {}, // u32
    WiphyAntennaRx(val) => {}, // u32
    WiphyAntennaTx(val) => {}, // u32
    WiphyBands(iter) => {
      for attr in iter {
        match attr {

          // 2.4 GHz ISM band
          2ghz(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },

          // around 5 GHz band (4.9 - 5.7 GHz)
          5ghz(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },

          // around 60 GHz band (58.32 - 69.12 GHz)
          60ghz(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },
          6ghz(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },
          S1ghz(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },
          Lc(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },
        }
      }
    },
    WiphyCoverageClass(val) => {}, // u8
    WiphyFragThreshold(val) => {}, // u32
    WiphyName(val) => {}, // &CStr
    WiphyRetryLong(val) => {}, // u8
    WiphyRetryShort(val) => {}, // u8
    WiphyRtsThreshold(val) => {}, // u32
    WowlanTriggersSupported(iter) => {
      for attr in iter {
        match attr {
          Any(val) => {}, // ()
          Disconnect(val) => {}, // ()
          MagicPkt(val) => {}, // ()
          PktPattern(val) => {}, // ()
          GtkRekeySupported(val) => {}, // ()
          GtkRekeyFailure(val) => {}, // ()
          EapIdentRequest(val) => {}, // ()
          4wayHandshake(val) => {}, // ()
          RfkillRelease(val) => {}, // ()
          WakeupPkt80211(val) => {}, // ()
          WakeupPkt80211Len(val) => {}, // ()
          WakeupPkt8023(val) => {}, // ()
          WakeupPkt8023Len(val) => {}, // ()
          TcpConnection(val) => {}, // ()
          WakeupTcpMatch(val) => {}, // ()
          WakeupTcpConnlost(val) => {}, // ()
          WakeupTcpNomoretokens(val) => {}, // ()
          NetDetect(val) => {}, // ()
          NetDetectResults(val) => {}, // ()
          UnprotectedDeauthDisassoc(val) => {}, // ()
        }
      }
    },
  }
}
```

## Dump (request)

```rust
PushOpGetWiphyDumpRequest::new(&mut vec)
  .push_wiphy(val) // u32
  .push_wdev(val) // u64
  .push_ifindex(val) // u32
  .push_split_wiphy_dump(val) // ()
  ;
```

```rust
let attrs = OpGetWiphyDumpReply::new(buf);

attrs.get_bands(); // u32
attrs.get_cipher_suites(); // &[u8]
attrs.get_control_port_ethertype(); // ()
attrs.get_ext_capa(); // &[u8]
attrs.get_ext_capa_mask(); // &[u8]
attrs.get_ext_features(); // &[u8]

// Associated type: "FeatureFlags" (1 bit per enumeration)
attrs.get_feature_flags(); // u32
attrs.get_generation(); // u32
attrs.get_ht_capability_mask(); // &[u8]
attrs.get_interface_combinations(); // &[u8]
attrs.get_mac(); // &[u8]
attrs.get_max_csa_counters(); // u8
attrs.get_max_match_sets(); // u8
attrs.get_max_num_akm_suites(); // &[u8]
attrs.get_max_num_pmkids(); // u8
attrs.get_max_num_scan_ssids(); // u8
attrs.get_max_num_sched_scan_plans(); // u32
attrs.get_max_num_sched_scan_ssids(); // u8
attrs.get_max_remain_on_channel_duration(); // u32
attrs.get_max_scan_ie_len(); // u16
attrs.get_max_scan_plan_interval(); // u32
attrs.get_max_scan_plan_iterations(); // u32
attrs.get_max_sched_scan_ie_len(); // u16
attrs.get_offchannel_tx_ok(); // ()
{ // Nested RxFrameTypes
  let attrs = attrs.get_rx_frame_types();
  { // Nested Unspecified
    let attrs = attrs.get_unspecified();
    attrs.get_frame_type(); // u16
  }
  { // Nested Adhoc
    let attrs = attrs.get_adhoc();
    attrs.get_frame_type(); // u16
  }
  { // Nested Station
    let attrs = attrs.get_station();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ap
    let attrs = attrs.get_ap();
    attrs.get_frame_type(); // u16
  }
  { // Nested ApVlan
    let attrs = attrs.get_ap_vlan();
    attrs.get_frame_type(); // u16
  }
  { // Nested Wds
    let attrs = attrs.get_wds();
    attrs.get_frame_type(); // u16
  }
  { // Nested Monitor
    let attrs = attrs.get_monitor();
    attrs.get_frame_type(); // u16
  }
  { // Nested MeshPoint
    let attrs = attrs.get_mesh_point();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pClient
    let attrs = attrs.get_p2p_client();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pGo
    let attrs = attrs.get_p2p_go();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pDevice
    let attrs = attrs.get_p2p_device();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ocb
    let attrs = attrs.get_ocb();
    attrs.get_frame_type(); // u16
  }
  { // Nested Nan
    let attrs = attrs.get_nan();
    attrs.get_frame_type(); // u16
  }
}
attrs.get_sar_spec(); // &[u8]
attrs.get_sched_scan_max_reqs(); // u32
{ // Nested SoftwareIftypes
  let attrs = attrs.get_software_iftypes();
  attrs.get_adhoc(); // ()
  attrs.get_station(); // ()
  attrs.get_ap(); // ()
  attrs.get_ap_vlan(); // ()
  attrs.get_wds(); // ()
  attrs.get_monitor(); // ()
  attrs.get_mesh_point(); // ()
  attrs.get_p2p_client(); // ()
  attrs.get_p2p_go(); // ()
  attrs.get_p2p_device(); // ()
  attrs.get_ocb(); // ()
  attrs.get_nan(); // ()
}
attrs.get_support_ap_uapsd(); // ()
{ // Nested SupportedIftypes
  let attrs = attrs.get_supported_iftypes();
  attrs.get_adhoc(); // ()
  attrs.get_station(); // ()
  attrs.get_ap(); // ()
  attrs.get_ap_vlan(); // ()
  attrs.get_wds(); // ()
  attrs.get_monitor(); // ()
  attrs.get_mesh_point(); // ()
  attrs.get_p2p_client(); // ()
  attrs.get_p2p_go(); // ()
  attrs.get_p2p_device(); // ()
  attrs.get_ocb(); // ()
  attrs.get_nan(); // ()
}
attrs.get_tdls_external_setup(); // ()
attrs.get_tdls_support(); // ()
{ // Nested TxFrameTypes
  let attrs = attrs.get_tx_frame_types();
  { // Nested Unspecified
    let attrs = attrs.get_unspecified();
    attrs.get_frame_type(); // u16
  }
  { // Nested Adhoc
    let attrs = attrs.get_adhoc();
    attrs.get_frame_type(); // u16
  }
  { // Nested Station
    let attrs = attrs.get_station();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ap
    let attrs = attrs.get_ap();
    attrs.get_frame_type(); // u16
  }
  { // Nested ApVlan
    let attrs = attrs.get_ap_vlan();
    attrs.get_frame_type(); // u16
  }
  { // Nested Wds
    let attrs = attrs.get_wds();
    attrs.get_frame_type(); // u16
  }
  { // Nested Monitor
    let attrs = attrs.get_monitor();
    attrs.get_frame_type(); // u16
  }
  { // Nested MeshPoint
    let attrs = attrs.get_mesh_point();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pClient
    let attrs = attrs.get_p2p_client();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pGo
    let attrs = attrs.get_p2p_go();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pDevice
    let attrs = attrs.get_p2p_device();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ocb
    let attrs = attrs.get_ocb();
    attrs.get_frame_type(); // u16
  }
  { // Nested Nan
    let attrs = attrs.get_nan();
    attrs.get_frame_type(); // u16
  }
}
attrs.get_txq_limit(); // u32
attrs.get_txq_memory_limit(); // u32
attrs.get_txq_quantum(); // u32
{ // Nested TxqStats
  let attrs = attrs.get_txq_stats();
  attrs.get_backlog_bytes(); // u32
  attrs.get_backlog_packets(); // u32
  attrs.get_flows(); // u32
  attrs.get_drops(); // u32
  attrs.get_ecn_marks(); // u32
  attrs.get_overlimit(); // u32
  attrs.get_overmemory(); // u32
  attrs.get_collisions(); // u32
  attrs.get_tx_bytes(); // u32
  attrs.get_tx_packets(); // u32
  attrs.get_max_flows(); // u32
}
attrs.get_vht_capability_mask(); // &[u8]
attrs.get_wiphy(); // u32
attrs.get_wiphy_antenna_avail_rx(); // u32
attrs.get_wiphy_antenna_avail_tx(); // u32
attrs.get_wiphy_antenna_rx(); // u32
attrs.get_wiphy_antenna_tx(); // u32
{ // Nested WiphyBands
  let attrs = attrs.get_wiphy_bands();
  { // Nested 2ghz

    // 2.4 GHz ISM band
    let attrs = attrs.get_2ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 5ghz

    // around 5 GHz band (4.9 - 5.7 GHz)
    let attrs = attrs.get_5ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 60ghz

    // around 60 GHz band (58.32 - 69.12 GHz)
    let attrs = attrs.get_60ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 6ghz
    let attrs = attrs.get_6ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested S1ghz
    let attrs = attrs.get_s1ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested Lc
    let attrs = attrs.get_lc();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
}
attrs.get_wiphy_coverage_class(); // u8
attrs.get_wiphy_frag_threshold(); // u32
attrs.get_wiphy_name(); // &CStr
attrs.get_wiphy_retry_long(); // u8
attrs.get_wiphy_retry_short(); // u8
attrs.get_wiphy_rts_threshold(); // u32
{ // Nested WowlanTriggersSupported
  let attrs = attrs.get_wowlan_triggers_supported();
  attrs.get_any(); // ()
  attrs.get_disconnect(); // ()
  attrs.get_magic_pkt(); // ()
  attrs.get_pkt_pattern(); // ()
  attrs.get_gtk_rekey_supported(); // ()
  attrs.get_gtk_rekey_failure(); // ()
  attrs.get_eap_ident_request(); // ()
  attrs.get_4way_handshake(); // ()
  attrs.get_rfkill_release(); // ()
  attrs.get_wakeup_pkt_80211(); // ()
  attrs.get_wakeup_pkt_80211_len(); // ()
  attrs.get_wakeup_pkt_8023(); // ()
  attrs.get_wakeup_pkt_8023_len(); // ()
  attrs.get_tcp_connection(); // ()
  attrs.get_wakeup_tcp_match(); // ()
  attrs.get_wakeup_tcp_connlost(); // ()
  attrs.get_wakeup_tcp_nomoretokens(); // ()
  attrs.get_net_detect(); // ()
  attrs.get_net_detect_results(); // ()
  attrs.get_unprotected_deauth_disassoc(); // ()
}
```

### Dump (reply)

```rust
PushOpGetWiphyDumpReply::new(&mut vec)
  .push_bands(val) // u32
  .push_cipher_suites(val) // &[u8]
  .push_control_port_ethertype(val) // ()
  .push_ext_capa(val) // &[u8]
  .push_ext_capa_mask(val) // &[u8]
  .push_ext_features(val) // &[u8]

  // Associated type: "FeatureFlags" (1 bit per enumeration)
  .push_feature_flags(val) // u32
  .push_generation(val) // u32
  .push_ht_capability_mask(val) // &[u8]
  .push_interface_combinations(val) // &[u8]
  .push_mac(val) // &[u8]
  .push_max_csa_counters(val) // u8
  .push_max_match_sets(val) // u8
  .push_max_num_akm_suites(val) // &[u8]
  .push_max_num_pmkids(val) // u8
  .push_max_num_scan_ssids(val) // u8
  .push_max_num_sched_scan_plans(val) // u32
  .push_max_num_sched_scan_ssids(val) // u8
  .push_max_remain_on_channel_duration(val) // u32
  .push_max_scan_ie_len(val) // u16
  .push_max_scan_plan_interval(val) // u32
  .push_max_scan_plan_iterations(val) // u32
  .push_max_sched_scan_ie_len(val) // u16
  .push_offchannel_tx_ok(val) // ()
  .nested_rx_frame_types()
    .nested_unspecified()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_adhoc()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_station()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ap()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ap_vlan()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_wds()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_monitor()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_mesh_point()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_client()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_go()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_device()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ocb()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_nan()
      .push_frame_type(val) // u16
    .end_nested()
  .end_nested()
  .push_sar_spec(val) // &[u8]
  .push_sched_scan_max_reqs(val) // u32
  .nested_software_iftypes()
    .push_adhoc(val) // ()
    .push_station(val) // ()
    .push_ap(val) // ()
    .push_ap_vlan(val) // ()
    .push_wds(val) // ()
    .push_monitor(val) // ()
    .push_mesh_point(val) // ()
    .push_p2p_client(val) // ()
    .push_p2p_go(val) // ()
    .push_p2p_device(val) // ()
    .push_ocb(val) // ()
    .push_nan(val) // ()
  .end_nested()
  .push_support_ap_uapsd(val) // ()
  .nested_supported_iftypes()
    .push_adhoc(val) // ()
    .push_station(val) // ()
    .push_ap(val) // ()
    .push_ap_vlan(val) // ()
    .push_wds(val) // ()
    .push_monitor(val) // ()
    .push_mesh_point(val) // ()
    .push_p2p_client(val) // ()
    .push_p2p_go(val) // ()
    .push_p2p_device(val) // ()
    .push_ocb(val) // ()
    .push_nan(val) // ()
  .end_nested()
  .push_tdls_external_setup(val) // ()
  .push_tdls_support(val) // ()
  .nested_tx_frame_types()
    .nested_unspecified()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_adhoc()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_station()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ap()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ap_vlan()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_wds()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_monitor()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_mesh_point()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_client()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_go()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_p2p_device()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_ocb()
      .push_frame_type(val) // u16
    .end_nested()
    .nested_nan()
      .push_frame_type(val) // u16
    .end_nested()
  .end_nested()
  .push_txq_limit(val) // u32
  .push_txq_memory_limit(val) // u32
  .push_txq_quantum(val) // u32
  .nested_txq_stats()
    .push_backlog_bytes(val) // u32
    .push_backlog_packets(val) // u32
    .push_flows(val) // u32
    .push_drops(val) // u32
    .push_ecn_marks(val) // u32
    .push_overlimit(val) // u32
    .push_overmemory(val) // u32
    .push_collisions(val) // u32
    .push_tx_bytes(val) // u32
    .push_tx_packets(val) // u32
    .push_max_flows(val) // u32
  .end_nested()
  .push_vht_capability_mask(val) // &[u8]
  .push_wiphy(val) // u32
  .push_wiphy_antenna_avail_rx(val) // u32
  .push_wiphy_antenna_avail_tx(val) // u32
  .push_wiphy_antenna_rx(val) // u32
  .push_wiphy_antenna_tx(val) // u32
  .nested_wiphy_bands()

    // 2.4 GHz ISM band
    .nested_2ghz()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()

    // around 5 GHz band (4.9 - 5.7 GHz)
    .nested_5ghz()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()

    // around 60 GHz band (58.32 - 69.12 GHz)
    .nested_60ghz()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()
    .nested_6ghz()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()
    .nested_s1ghz()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()
    .nested_lc()
      .array_freqs()
        .entry_nested()
          .push_freq(val) // u32
          .push_disabled(val) // ()
          .push_no_ir(val) // ()
          .push_no_ibss(val) // ()
          .push_radar(val) // ()
          .push_max_tx_power(val) // u32
          .push_dfs_state(val) // u32
          .push_dfs_time(val) // &[u8]
          .push_no_ht40_minus(val) // &[u8]
          .push_no_ht40_plus(val) // &[u8]
          .push_no_80mhz(val) // &[u8]
          .push_no_160mhz(val) // &[u8]
          .push_dfs_cac_time(val) // &[u8]
          .push_indoor_only(val) // &[u8]
          .push_ir_concurrent(val) // &[u8]
          .push_no_20mhz(val) // &[u8]
          .push_no_10mhz(val) // &[u8]
          .array_wmm()
            .entry_nested()
              .push_cw_min(val) // u16
              .push_cw_max(val) // u16
              .push_aifsn(val) // u8
              .push_txop(val) // u16
            .end_nested()
          .end_array()
          .push_no_he(val) // &[u8]
          .push_offset(val) // u32
          .push_1mhz(val) // &[u8]
          .push_2mhz(val) // &[u8]
          .push_4mhz(val) // &[u8]
          .push_8mhz(val) // &[u8]
          .push_16mhz(val) // &[u8]
          .push_no_320mhz(val) // &[u8]
          .push_no_eht(val) // &[u8]
          .push_psd(val) // &[u8]
          .push_dfs_concurrent(val) // &[u8]
          .push_no_6ghz_vlp_client(val) // &[u8]
          .push_no_6ghz_afc_client(val) // &[u8]
          .push_can_monitor(val) // &[u8]
          .push_allow_6ghz_vlp_ap(val) // &[u8]
        .end_nested()
      .end_array()
      .array_rates()
        .entry_nested()
          .push_rate(val) // u32
          .push_2ghz_shortpreamble(val) // ()
        .end_nested()
      .end_array()
      .push_ht_mcs_set(val) // &[u8]
      .push_ht_capa(val) // u16
      .push_ht_ampdu_factor(val) // u8
      .push_ht_ampdu_density(val) // u8
      .push_vht_mcs_set(val) // &[u8]
      .push_vht_capa(val) // u32
      .array_iftype_data()
        .entry_nested()
          .push_iftypes(val) // &[u8]
          .push_he_cap_mac(val) // &[u8]
          .push_he_cap_phy(val) // &[u8]
          .push_he_cap_mcs_set(val) // &[u8]
          .push_he_cap_ppe(val) // &[u8]
          .push_he_6ghz_capa(val) // &[u8]
          .push_vendor_elems(val) // &[u8]
          .push_eht_cap_mac(val) // &[u8]
          .push_eht_cap_phy(val) // &[u8]
          .push_eht_cap_mcs_set(val) // &[u8]
          .push_eht_cap_ppe(val) // &[u8]
        .end_nested()
      .end_array()
      .push_edmg_channels(val) // &[u8]
      .push_edmg_bw_config(val) // &[u8]
      .push_s1g_mcs_nss_set(val) // &[u8]
      .push_s1g_capa(val) // &[u8]
    .end_nested()
  .end_nested()
  .push_wiphy_coverage_class(val) // u8
  .push_wiphy_frag_threshold(val) // u32
  .push_wiphy_name(val) // &CStr
  .push_wiphy_name_bytes(val) // &[u8]
  .push_wiphy_retry_long(val) // u8
  .push_wiphy_retry_short(val) // u8
  .push_wiphy_rts_threshold(val) // u32
  .nested_wowlan_triggers_supported()
    .push_any(val) // ()
    .push_disconnect(val) // ()
    .push_magic_pkt(val) // ()
    .push_pkt_pattern(val) // ()
    .push_gtk_rekey_supported(val) // ()
    .push_gtk_rekey_failure(val) // ()
    .push_eap_ident_request(val) // ()
    .push_4way_handshake(val) // ()
    .push_rfkill_release(val) // ()
    .push_wakeup_pkt_80211(val) // ()
    .push_wakeup_pkt_80211_len(val) // ()
    .push_wakeup_pkt_8023(val) // ()
    .push_wakeup_pkt_8023_len(val) // ()
    .push_tcp_connection(val) // ()
    .push_wakeup_tcp_match(val) // ()
    .push_wakeup_tcp_connlost(val) // ()
    .push_wakeup_tcp_nomoretokens(val) // ()
    .push_net_detect(val) // ()
    .push_net_detect_results(val) // ()
    .push_unprotected_deauth_disassoc(val) // ()
  .end_nested()
  ;
```

```rust
let attrs = OpGetWiphyDumpReply::new(buf);

attrs.get_bands(); // u32
attrs.get_cipher_suites(); // &[u8]
attrs.get_control_port_ethertype(); // ()
attrs.get_ext_capa(); // &[u8]
attrs.get_ext_capa_mask(); // &[u8]
attrs.get_ext_features(); // &[u8]

// Associated type: "FeatureFlags" (1 bit per enumeration)
attrs.get_feature_flags(); // u32
attrs.get_generation(); // u32
attrs.get_ht_capability_mask(); // &[u8]
attrs.get_interface_combinations(); // &[u8]
attrs.get_mac(); // &[u8]
attrs.get_max_csa_counters(); // u8
attrs.get_max_match_sets(); // u8
attrs.get_max_num_akm_suites(); // &[u8]
attrs.get_max_num_pmkids(); // u8
attrs.get_max_num_scan_ssids(); // u8
attrs.get_max_num_sched_scan_plans(); // u32
attrs.get_max_num_sched_scan_ssids(); // u8
attrs.get_max_remain_on_channel_duration(); // u32
attrs.get_max_scan_ie_len(); // u16
attrs.get_max_scan_plan_interval(); // u32
attrs.get_max_scan_plan_iterations(); // u32
attrs.get_max_sched_scan_ie_len(); // u16
attrs.get_offchannel_tx_ok(); // ()
{ // Nested RxFrameTypes
  let attrs = attrs.get_rx_frame_types();
  { // Nested Unspecified
    let attrs = attrs.get_unspecified();
    attrs.get_frame_type(); // u16
  }
  { // Nested Adhoc
    let attrs = attrs.get_adhoc();
    attrs.get_frame_type(); // u16
  }
  { // Nested Station
    let attrs = attrs.get_station();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ap
    let attrs = attrs.get_ap();
    attrs.get_frame_type(); // u16
  }
  { // Nested ApVlan
    let attrs = attrs.get_ap_vlan();
    attrs.get_frame_type(); // u16
  }
  { // Nested Wds
    let attrs = attrs.get_wds();
    attrs.get_frame_type(); // u16
  }
  { // Nested Monitor
    let attrs = attrs.get_monitor();
    attrs.get_frame_type(); // u16
  }
  { // Nested MeshPoint
    let attrs = attrs.get_mesh_point();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pClient
    let attrs = attrs.get_p2p_client();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pGo
    let attrs = attrs.get_p2p_go();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pDevice
    let attrs = attrs.get_p2p_device();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ocb
    let attrs = attrs.get_ocb();
    attrs.get_frame_type(); // u16
  }
  { // Nested Nan
    let attrs = attrs.get_nan();
    attrs.get_frame_type(); // u16
  }
}
attrs.get_sar_spec(); // &[u8]
attrs.get_sched_scan_max_reqs(); // u32
{ // Nested SoftwareIftypes
  let attrs = attrs.get_software_iftypes();
  attrs.get_adhoc(); // ()
  attrs.get_station(); // ()
  attrs.get_ap(); // ()
  attrs.get_ap_vlan(); // ()
  attrs.get_wds(); // ()
  attrs.get_monitor(); // ()
  attrs.get_mesh_point(); // ()
  attrs.get_p2p_client(); // ()
  attrs.get_p2p_go(); // ()
  attrs.get_p2p_device(); // ()
  attrs.get_ocb(); // ()
  attrs.get_nan(); // ()
}
attrs.get_support_ap_uapsd(); // ()
{ // Nested SupportedIftypes
  let attrs = attrs.get_supported_iftypes();
  attrs.get_adhoc(); // ()
  attrs.get_station(); // ()
  attrs.get_ap(); // ()
  attrs.get_ap_vlan(); // ()
  attrs.get_wds(); // ()
  attrs.get_monitor(); // ()
  attrs.get_mesh_point(); // ()
  attrs.get_p2p_client(); // ()
  attrs.get_p2p_go(); // ()
  attrs.get_p2p_device(); // ()
  attrs.get_ocb(); // ()
  attrs.get_nan(); // ()
}
attrs.get_tdls_external_setup(); // ()
attrs.get_tdls_support(); // ()
{ // Nested TxFrameTypes
  let attrs = attrs.get_tx_frame_types();
  { // Nested Unspecified
    let attrs = attrs.get_unspecified();
    attrs.get_frame_type(); // u16
  }
  { // Nested Adhoc
    let attrs = attrs.get_adhoc();
    attrs.get_frame_type(); // u16
  }
  { // Nested Station
    let attrs = attrs.get_station();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ap
    let attrs = attrs.get_ap();
    attrs.get_frame_type(); // u16
  }
  { // Nested ApVlan
    let attrs = attrs.get_ap_vlan();
    attrs.get_frame_type(); // u16
  }
  { // Nested Wds
    let attrs = attrs.get_wds();
    attrs.get_frame_type(); // u16
  }
  { // Nested Monitor
    let attrs = attrs.get_monitor();
    attrs.get_frame_type(); // u16
  }
  { // Nested MeshPoint
    let attrs = attrs.get_mesh_point();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pClient
    let attrs = attrs.get_p2p_client();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pGo
    let attrs = attrs.get_p2p_go();
    attrs.get_frame_type(); // u16
  }
  { // Nested P2pDevice
    let attrs = attrs.get_p2p_device();
    attrs.get_frame_type(); // u16
  }
  { // Nested Ocb
    let attrs = attrs.get_ocb();
    attrs.get_frame_type(); // u16
  }
  { // Nested Nan
    let attrs = attrs.get_nan();
    attrs.get_frame_type(); // u16
  }
}
attrs.get_txq_limit(); // u32
attrs.get_txq_memory_limit(); // u32
attrs.get_txq_quantum(); // u32
{ // Nested TxqStats
  let attrs = attrs.get_txq_stats();
  attrs.get_backlog_bytes(); // u32
  attrs.get_backlog_packets(); // u32
  attrs.get_flows(); // u32
  attrs.get_drops(); // u32
  attrs.get_ecn_marks(); // u32
  attrs.get_overlimit(); // u32
  attrs.get_overmemory(); // u32
  attrs.get_collisions(); // u32
  attrs.get_tx_bytes(); // u32
  attrs.get_tx_packets(); // u32
  attrs.get_max_flows(); // u32
}
attrs.get_vht_capability_mask(); // &[u8]
attrs.get_wiphy(); // u32
attrs.get_wiphy_antenna_avail_rx(); // u32
attrs.get_wiphy_antenna_avail_tx(); // u32
attrs.get_wiphy_antenna_rx(); // u32
attrs.get_wiphy_antenna_tx(); // u32
{ // Nested WiphyBands
  let attrs = attrs.get_wiphy_bands();
  { // Nested 2ghz

    // 2.4 GHz ISM band
    let attrs = attrs.get_2ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 5ghz

    // around 5 GHz band (4.9 - 5.7 GHz)
    let attrs = attrs.get_5ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 60ghz

    // around 60 GHz band (58.32 - 69.12 GHz)
    let attrs = attrs.get_60ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested 6ghz
    let attrs = attrs.get_6ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested S1ghz
    let attrs = attrs.get_s1ghz();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
  { // Nested Lc
    let attrs = attrs.get_lc();

    for entry in attrs.get_freqs() {
      entry.get_freq(); // u32
      entry.get_disabled(); // ()
      entry.get_no_ir(); // ()
      entry.get_no_ibss(); // ()
      entry.get_radar(); // ()
      entry.get_max_tx_power(); // u32
      entry.get_dfs_state(); // u32
      entry.get_dfs_time(); // &[u8]
      entry.get_no_ht40_minus(); // &[u8]
      entry.get_no_ht40_plus(); // &[u8]
      entry.get_no_80mhz(); // &[u8]
      entry.get_no_160mhz(); // &[u8]
      entry.get_dfs_cac_time(); // &[u8]
      entry.get_indoor_only(); // &[u8]
      entry.get_ir_concurrent(); // &[u8]
      entry.get_no_20mhz(); // &[u8]
      entry.get_no_10mhz(); // &[u8]

      for entry in entry.get_wmm() {
        entry.get_cw_min(); // u16
        entry.get_cw_max(); // u16
        entry.get_aifsn(); // u8
        entry.get_txop(); // u16
      }
      entry.get_no_he(); // &[u8]
      entry.get_offset(); // u32
      entry.get_1mhz(); // &[u8]
      entry.get_2mhz(); // &[u8]
      entry.get_4mhz(); // &[u8]
      entry.get_8mhz(); // &[u8]
      entry.get_16mhz(); // &[u8]
      entry.get_no_320mhz(); // &[u8]
      entry.get_no_eht(); // &[u8]
      entry.get_psd(); // &[u8]
      entry.get_dfs_concurrent(); // &[u8]
      entry.get_no_6ghz_vlp_client(); // &[u8]
      entry.get_no_6ghz_afc_client(); // &[u8]
      entry.get_can_monitor(); // &[u8]
      entry.get_allow_6ghz_vlp_ap(); // &[u8]
    }

    for entry in attrs.get_rates() {
      entry.get_rate(); // u32
      entry.get_2ghz_shortpreamble(); // ()
    }
    attrs.get_ht_mcs_set(); // &[u8]
    attrs.get_ht_capa(); // u16
    attrs.get_ht_ampdu_factor(); // u8
    attrs.get_ht_ampdu_density(); // u8
    attrs.get_vht_mcs_set(); // &[u8]
    attrs.get_vht_capa(); // u32

    for entry in attrs.get_iftype_data() {
      entry.get_iftypes(); // &[u8]
      entry.get_he_cap_mac(); // &[u8]
      entry.get_he_cap_phy(); // &[u8]
      entry.get_he_cap_mcs_set(); // &[u8]
      entry.get_he_cap_ppe(); // &[u8]
      entry.get_he_6ghz_capa(); // &[u8]
      entry.get_vendor_elems(); // &[u8]
      entry.get_eht_cap_mac(); // &[u8]
      entry.get_eht_cap_phy(); // &[u8]
      entry.get_eht_cap_mcs_set(); // &[u8]
      entry.get_eht_cap_ppe(); // &[u8]
    }
    attrs.get_edmg_channels(); // &[u8]
    attrs.get_edmg_bw_config(); // &[u8]
    attrs.get_s1g_mcs_nss_set(); // &[u8]
    attrs.get_s1g_capa(); // &[u8]
  }
}
attrs.get_wiphy_coverage_class(); // u8
attrs.get_wiphy_frag_threshold(); // u32
attrs.get_wiphy_name(); // &CStr
attrs.get_wiphy_retry_long(); // u8
attrs.get_wiphy_retry_short(); // u8
attrs.get_wiphy_rts_threshold(); // u32
{ // Nested WowlanTriggersSupported
  let attrs = attrs.get_wowlan_triggers_supported();
  attrs.get_any(); // ()
  attrs.get_disconnect(); // ()
  attrs.get_magic_pkt(); // ()
  attrs.get_pkt_pattern(); // ()
  attrs.get_gtk_rekey_supported(); // ()
  attrs.get_gtk_rekey_failure(); // ()
  attrs.get_eap_ident_request(); // ()
  attrs.get_4way_handshake(); // ()
  attrs.get_rfkill_release(); // ()
  attrs.get_wakeup_pkt_80211(); // ()
  attrs.get_wakeup_pkt_80211_len(); // ()
  attrs.get_wakeup_pkt_8023(); // ()
  attrs.get_wakeup_pkt_8023_len(); // ()
  attrs.get_tcp_connection(); // ()
  attrs.get_wakeup_tcp_match(); // ()
  attrs.get_wakeup_tcp_connlost(); // ()
  attrs.get_wakeup_tcp_nomoretokens(); // ()
  attrs.get_net_detect(); // ()
  attrs.get_net_detect_results(); // ()
  attrs.get_unprotected_deauth_disassoc(); // ()
}
```

## Low-level decoding

### Dump (request)

```rust
let iter = OpGetWiphyDumpRequest::new(buf);
for attr in iter {
  match attr {
    Wiphy(val) => {}, // u32
    Wdev(val) => {}, // u64
    Ifindex(val) => {}, // u32
    SplitWiphyDump(val) => {}, // ()
  }
}
```

### Dump (reply)

```rust
let iter = OpGetWiphyDumpReply::new(buf);
for attr in iter {
  match attr {
    Bands(val) => {}, // u32
    CipherSuites(val) => {}, // &[u8]
    ControlPortEthertype(val) => {}, // ()
    ExtCapa(val) => {}, // &[u8]
    ExtCapaMask(val) => {}, // &[u8]
    ExtFeatures(val) => {}, // &[u8]

    // Associated type: "FeatureFlags" (1 bit per enumeration)
    FeatureFlags(val) => {}, // u32
    Generation(val) => {}, // u32
    HtCapabilityMask(val) => {}, // &[u8]
    InterfaceCombinations(val) => {}, // &[u8]
    Mac(val) => {}, // &[u8]
    MaxCsaCounters(val) => {}, // u8
    MaxMatchSets(val) => {}, // u8
    MaxNumAkmSuites(val) => {}, // &[u8]
    MaxNumPmkids(val) => {}, // u8
    MaxNumScanSsids(val) => {}, // u8
    MaxNumSchedScanPlans(val) => {}, // u32
    MaxNumSchedScanSsids(val) => {}, // u8
    MaxRemainOnChannelDuration(val) => {}, // u32
    MaxScanIeLen(val) => {}, // u16
    MaxScanPlanInterval(val) => {}, // u32
    MaxScanPlanIterations(val) => {}, // u32
    MaxSchedScanIeLen(val) => {}, // u16
    OffchannelTxOk(val) => {}, // ()
    RxFrameTypes(iter) => {
      for attr in iter {
        match attr {
          Unspecified(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Adhoc(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Station(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Ap(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          ApVlan(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Wds(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Monitor(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          MeshPoint(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pClient(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pGo(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pDevice(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Ocb(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Nan(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
        }
      }
    },
    SarSpec(val) => {}, // &[u8]
    SchedScanMaxReqs(val) => {}, // u32
    SoftwareIftypes(iter) => {
      for attr in iter {
        match attr {
          Adhoc(val) => {}, // ()
          Station(val) => {}, // ()
          Ap(val) => {}, // ()
          ApVlan(val) => {}, // ()
          Wds(val) => {}, // ()
          Monitor(val) => {}, // ()
          MeshPoint(val) => {}, // ()
          P2pClient(val) => {}, // ()
          P2pGo(val) => {}, // ()
          P2pDevice(val) => {}, // ()
          Ocb(val) => {}, // ()
          Nan(val) => {}, // ()
        }
      }
    },
    SupportApUapsd(val) => {}, // ()
    SupportedIftypes(iter) => {
      for attr in iter {
        match attr {
          Adhoc(val) => {}, // ()
          Station(val) => {}, // ()
          Ap(val) => {}, // ()
          ApVlan(val) => {}, // ()
          Wds(val) => {}, // ()
          Monitor(val) => {}, // ()
          MeshPoint(val) => {}, // ()
          P2pClient(val) => {}, // ()
          P2pGo(val) => {}, // ()
          P2pDevice(val) => {}, // ()
          Ocb(val) => {}, // ()
          Nan(val) => {}, // ()
        }
      }
    },
    TdlsExternalSetup(val) => {}, // ()
    TdlsSupport(val) => {}, // ()
    TxFrameTypes(iter) => {
      for attr in iter {
        match attr {
          Unspecified(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Adhoc(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Station(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Ap(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          ApVlan(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Wds(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Monitor(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          MeshPoint(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pClient(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pGo(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          P2pDevice(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Ocb(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
          Nan(iter) => {
            for attr in iter {
              match attr {
                FrameType(val) => {}, // u16
              }
            }
          },
        }
      }
    },
    TxqLimit(val) => {}, // u32
    TxqMemoryLimit(val) => {}, // u32
    TxqQuantum(val) => {}, // u32
    TxqStats(iter) => {
      for attr in iter {
        match attr {
          BacklogBytes(val) => {}, // u32
          BacklogPackets(val) => {}, // u32
          Flows(val) => {}, // u32
          Drops(val) => {}, // u32
          EcnMarks(val) => {}, // u32
          Overlimit(val) => {}, // u32
          Overmemory(val) => {}, // u32
          Collisions(val) => {}, // u32
          TxBytes(val) => {}, // u32
          TxPackets(val) => {}, // u32
          MaxFlows(val) => {}, // u32
        }
      }
    },
    VhtCapabilityMask(val) => {}, // &[u8]
    Wiphy(val) => {}, // u32
    WiphyAntennaAvailRx(val) => {}, // u32
    WiphyAntennaAvailTx(val) => {}, // u32
    WiphyAntennaRx(val) => {}, // u32
    WiphyAntennaTx(val) => {}, // u32
    WiphyBands(iter) => {
      for attr in iter {
        match attr {

          // 2.4 GHz ISM band
          2ghz(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },

          // around 5 GHz band (4.9 - 5.7 GHz)
          5ghz(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },

          // around 60 GHz band (58.32 - 69.12 GHz)
          60ghz(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },
          6ghz(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },
          S1ghz(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },
          Lc(iter) => {
            for attr in iter {
              match attr {
                Freqs(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Freq(val) => {}, // u32
                        Disabled(val) => {}, // ()
                        NoIr(val) => {}, // ()
                        NoIbss(val) => {}, // ()
                        Radar(val) => {}, // ()
                        MaxTxPower(val) => {}, // u32
                        DfsState(val) => {}, // u32
                        DfsTime(val) => {}, // &[u8]
                        NoHt40Minus(val) => {}, // &[u8]
                        NoHt40Plus(val) => {}, // &[u8]
                        No80mhz(val) => {}, // &[u8]
                        No160mhz(val) => {}, // &[u8]
                        DfsCacTime(val) => {}, // &[u8]
                        IndoorOnly(val) => {}, // &[u8]
                        IrConcurrent(val) => {}, // &[u8]
                        No20mhz(val) => {}, // &[u8]
                        No10mhz(val) => {}, // &[u8]
                        Wmm(iter) => {
                          for entry in iter {
                            for attr in entry {
                              match attr {
                                CwMin(val) => {}, // u16
                                CwMax(val) => {}, // u16
                                Aifsn(val) => {}, // u8
                                Txop(val) => {}, // u16
                              }
                            }
                          }
                        },
                        NoHe(val) => {}, // &[u8]
                        Offset(val) => {}, // u32
                        1mhz(val) => {}, // &[u8]
                        2mhz(val) => {}, // &[u8]
                        4mhz(val) => {}, // &[u8]
                        8mhz(val) => {}, // &[u8]
                        16mhz(val) => {}, // &[u8]
                        No320mhz(val) => {}, // &[u8]
                        NoEht(val) => {}, // &[u8]
                        Psd(val) => {}, // &[u8]
                        DfsConcurrent(val) => {}, // &[u8]
                        No6ghzVlpClient(val) => {}, // &[u8]
                        No6ghzAfcClient(val) => {}, // &[u8]
                        CanMonitor(val) => {}, // &[u8]
                        Allow6ghzVlpAp(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                Rates(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Rate(val) => {}, // u32
                        2ghzShortpreamble(val) => {}, // ()
                      }
                    }
                  }
                },
                HtMcsSet(val) => {}, // &[u8]
                HtCapa(val) => {}, // u16
                HtAmpduFactor(val) => {}, // u8
                HtAmpduDensity(val) => {}, // u8
                VhtMcsSet(val) => {}, // &[u8]
                VhtCapa(val) => {}, // u32
                IftypeData(iter) => {
                  for entry in iter {
                    for attr in entry {
                      match attr {
                        Iftypes(val) => {}, // &[u8]
                        HeCapMac(val) => {}, // &[u8]
                        HeCapPhy(val) => {}, // &[u8]
                        HeCapMcsSet(val) => {}, // &[u8]
                        HeCapPpe(val) => {}, // &[u8]
                        He6ghzCapa(val) => {}, // &[u8]
                        VendorElems(val) => {}, // &[u8]
                        EhtCapMac(val) => {}, // &[u8]
                        EhtCapPhy(val) => {}, // &[u8]
                        EhtCapMcsSet(val) => {}, // &[u8]
                        EhtCapPpe(val) => {}, // &[u8]
                      }
                    }
                  }
                },
                EdmgChannels(val) => {}, // &[u8]
                EdmgBwConfig(val) => {}, // &[u8]
                S1gMcsNssSet(val) => {}, // &[u8]
                S1gCapa(val) => {}, // &[u8]
              }
            }
          },
        }
      }
    },
    WiphyCoverageClass(val) => {}, // u8
    WiphyFragThreshold(val) => {}, // u32
    WiphyName(val) => {}, // &CStr
    WiphyRetryLong(val) => {}, // u8
    WiphyRetryShort(val) => {}, // u8
    WiphyRtsThreshold(val) => {}, // u32
    WowlanTriggersSupported(iter) => {
      for attr in iter {
        match attr {
          Any(val) => {}, // ()
          Disconnect(val) => {}, // ()
          MagicPkt(val) => {}, // ()
          PktPattern(val) => {}, // ()
          GtkRekeySupported(val) => {}, // ()
          GtkRekeyFailure(val) => {}, // ()
          EapIdentRequest(val) => {}, // ()
          4wayHandshake(val) => {}, // ()
          RfkillRelease(val) => {}, // ()
          WakeupPkt80211(val) => {}, // ()
          WakeupPkt80211Len(val) => {}, // ()
          WakeupPkt8023(val) => {}, // ()
          WakeupPkt8023Len(val) => {}, // ()
          TcpConnection(val) => {}, // ()
          WakeupTcpMatch(val) => {}, // ()
          WakeupTcpConnlost(val) => {}, // ()
          WakeupTcpNomoretokens(val) => {}, // ()
          NetDetect(val) => {}, // ()
          NetDetectResults(val) => {}, // ()
          UnprotectedDeauthDisassoc(val) => {}, // ()
        }
      }
    },
  }
}
```

# Operation "get-interface"

## Do (request)

```rust
PushOpGetInterfaceDoRequest::new(&mut vec)
  .push_ifname(val) // &CStr
  .push_ifname_bytes(val) // &[u8]
  ;
```

```rust
let attrs = OpGetInterfaceDoReply::new(buf);

attrs.get_ifname(); // &CStr
attrs.get_iftype(); // u32
attrs.get_ifindex(); // u32
attrs.get_wiphy(); // u32
attrs.get_wdev(); // u64
attrs.get_mac(); // &[u8]
attrs.get_generation(); // u32
{ // Nested TxqStats
  let attrs = attrs.get_txq_stats();
  attrs.get_backlog_bytes(); // u32
  attrs.get_backlog_packets(); // u32
  attrs.get_flows(); // u32
  attrs.get_drops(); // u32
  attrs.get_ecn_marks(); // u32
  attrs.get_overlimit(); // u32
  attrs.get_overmemory(); // u32
  attrs.get_collisions(); // u32
  attrs.get_tx_bytes(); // u32
  attrs.get_tx_packets(); // u32
  attrs.get_max_flows(); // u32
}
attrs.get_4addr(); // u8
```

### Do (reply)

```rust
PushOpGetInterfaceDoReply::new(&mut vec)
  .push_ifname(val) // &CStr
  .push_ifname_bytes(val) // &[u8]
  .push_iftype(val) // u32
  .push_ifindex(val) // u32
  .push_wiphy(val) // u32
  .push_wdev(val) // u64
  .push_mac(val) // &[u8]
  .push_generation(val) // u32
  .nested_txq_stats()
    .push_backlog_bytes(val) // u32
    .push_backlog_packets(val) // u32
    .push_flows(val) // u32
    .push_drops(val) // u32
    .push_ecn_marks(val) // u32
    .push_overlimit(val) // u32
    .push_overmemory(val) // u32
    .push_collisions(val) // u32
    .push_tx_bytes(val) // u32
    .push_tx_packets(val) // u32
    .push_max_flows(val) // u32
  .end_nested()
  .push_4addr(val) // u8
  ;
```

```rust
let attrs = OpGetInterfaceDoReply::new(buf);

attrs.get_ifname(); // &CStr
attrs.get_iftype(); // u32
attrs.get_ifindex(); // u32
attrs.get_wiphy(); // u32
attrs.get_wdev(); // u64
attrs.get_mac(); // &[u8]
attrs.get_generation(); // u32
{ // Nested TxqStats
  let attrs = attrs.get_txq_stats();
  attrs.get_backlog_bytes(); // u32
  attrs.get_backlog_packets(); // u32
  attrs.get_flows(); // u32
  attrs.get_drops(); // u32
  attrs.get_ecn_marks(); // u32
  attrs.get_overlimit(); // u32
  attrs.get_overmemory(); // u32
  attrs.get_collisions(); // u32
  attrs.get_tx_bytes(); // u32
  attrs.get_tx_packets(); // u32
  attrs.get_max_flows(); // u32
}
attrs.get_4addr(); // u8
```

## Low-level decoding

### Do (request)

```rust
let iter = OpGetInterfaceDoRequest::new(buf);
for attr in iter {
  match attr {
    Ifname(val) => {}, // &CStr
  }
}
```

### Do (reply)

```rust
let iter = OpGetInterfaceDoReply::new(buf);
for attr in iter {
  match attr {
    Ifname(val) => {}, // &CStr
    Iftype(val) => {}, // u32
    Ifindex(val) => {}, // u32
    Wiphy(val) => {}, // u32
    Wdev(val) => {}, // u64
    Mac(val) => {}, // &[u8]
    Generation(val) => {}, // u32
    TxqStats(iter) => {
      for attr in iter {
        match attr {
          BacklogBytes(val) => {}, // u32
          BacklogPackets(val) => {}, // u32
          Flows(val) => {}, // u32
          Drops(val) => {}, // u32
          EcnMarks(val) => {}, // u32
          Overlimit(val) => {}, // u32
          Overmemory(val) => {}, // u32
          Collisions(val) => {}, // u32
          TxBytes(val) => {}, // u32
          TxPackets(val) => {}, // u32
          MaxFlows(val) => {}, // u32
        }
      }
    },
    4addr(val) => {}, // u8
  }
}
```

## Dump (request)

```rust
PushOpGetInterfaceDumpRequest::new(&mut vec)
  .push_ifname(val) // &CStr
  .push_ifname_bytes(val) // &[u8]
  ;
```

```rust
let attrs = OpGetInterfaceDumpReply::new(buf);

attrs.get_ifname(); // &CStr
attrs.get_iftype(); // u32
attrs.get_ifindex(); // u32
attrs.get_wiphy(); // u32
attrs.get_wdev(); // u64
attrs.get_mac(); // &[u8]
attrs.get_generation(); // u32
{ // Nested TxqStats
  let attrs = attrs.get_txq_stats();
  attrs.get_backlog_bytes(); // u32
  attrs.get_backlog_packets(); // u32
  attrs.get_flows(); // u32
  attrs.get_drops(); // u32
  attrs.get_ecn_marks(); // u32
  attrs.get_overlimit(); // u32
  attrs.get_overmemory(); // u32
  attrs.get_collisions(); // u32
  attrs.get_tx_bytes(); // u32
  attrs.get_tx_packets(); // u32
  attrs.get_max_flows(); // u32
}
attrs.get_4addr(); // u8
```

### Dump (reply)

```rust
PushOpGetInterfaceDumpReply::new(&mut vec)
  .push_ifname(val) // &CStr
  .push_ifname_bytes(val) // &[u8]
  .push_iftype(val) // u32
  .push_ifindex(val) // u32
  .push_wiphy(val) // u32
  .push_wdev(val) // u64
  .push_mac(val) // &[u8]
  .push_generation(val) // u32
  .nested_txq_stats()
    .push_backlog_bytes(val) // u32
    .push_backlog_packets(val) // u32
    .push_flows(val) // u32
    .push_drops(val) // u32
    .push_ecn_marks(val) // u32
    .push_overlimit(val) // u32
    .push_overmemory(val) // u32
    .push_collisions(val) // u32
    .push_tx_bytes(val) // u32
    .push_tx_packets(val) // u32
    .push_max_flows(val) // u32
  .end_nested()
  .push_4addr(val) // u8
  ;
```

```rust
let attrs = OpGetInterfaceDumpReply::new(buf);

attrs.get_ifname(); // &CStr
attrs.get_iftype(); // u32
attrs.get_ifindex(); // u32
attrs.get_wiphy(); // u32
attrs.get_wdev(); // u64
attrs.get_mac(); // &[u8]
attrs.get_generation(); // u32
{ // Nested TxqStats
  let attrs = attrs.get_txq_stats();
  attrs.get_backlog_bytes(); // u32
  attrs.get_backlog_packets(); // u32
  attrs.get_flows(); // u32
  attrs.get_drops(); // u32
  attrs.get_ecn_marks(); // u32
  attrs.get_overlimit(); // u32
  attrs.get_overmemory(); // u32
  attrs.get_collisions(); // u32
  attrs.get_tx_bytes(); // u32
  attrs.get_tx_packets(); // u32
  attrs.get_max_flows(); // u32
}
attrs.get_4addr(); // u8
```

## Low-level decoding

### Dump (request)

```rust
let iter = OpGetInterfaceDumpRequest::new(buf);
for attr in iter {
  match attr {
    Ifname(val) => {}, // &CStr
  }
}
```

### Dump (reply)

```rust
let iter = OpGetInterfaceDumpReply::new(buf);
for attr in iter {
  match attr {
    Ifname(val) => {}, // &CStr
    Iftype(val) => {}, // u32
    Ifindex(val) => {}, // u32
    Wiphy(val) => {}, // u32
    Wdev(val) => {}, // u64
    Mac(val) => {}, // &[u8]
    Generation(val) => {}, // u32
    TxqStats(iter) => {
      for attr in iter {
        match attr {
          BacklogBytes(val) => {}, // u32
          BacklogPackets(val) => {}, // u32
          Flows(val) => {}, // u32
          Drops(val) => {}, // u32
          EcnMarks(val) => {}, // u32
          Overlimit(val) => {}, // u32
          Overmemory(val) => {}, // u32
          Collisions(val) => {}, // u32
          TxBytes(val) => {}, // u32
          TxPackets(val) => {}, // u32
          MaxFlows(val) => {}, // u32
        }
      }
    },
    4addr(val) => {}, // u8
  }
}
```

# Operation "get-protocol-features"

## Do (request)

```rust
PushOpGetProtocolFeaturesDoRequest::new(&mut vec)

  // Associated type: "ProtocolFeatures" (enum)
  .push_protocol_features(val) // u32
  ;
```

```rust
let attrs = OpGetProtocolFeaturesDoReply::new(buf);

// Associated type: "ProtocolFeatures" (enum)
attrs.get_protocol_features(); // u32
```

### Do (reply)

```rust
PushOpGetProtocolFeaturesDoReply::new(&mut vec)

  // Associated type: "ProtocolFeatures" (enum)
  .push_protocol_features(val) // u32
  ;
```

```rust
let attrs = OpGetProtocolFeaturesDoReply::new(buf);

// Associated type: "ProtocolFeatures" (enum)
attrs.get_protocol_features(); // u32
```

## Low-level decoding

### Do (request)

```rust
let iter = OpGetProtocolFeaturesDoRequest::new(buf);
for attr in iter {
  match attr {

    // Associated type: "ProtocolFeatures" (enum)
    ProtocolFeatures(val) => {}, // u32
  }
}
```

### Do (reply)

```rust
let iter = OpGetProtocolFeaturesDoReply::new(buf);
for attr in iter {
  match attr {

    // Associated type: "ProtocolFeatures" (enum)
    ProtocolFeatures(val) => {}, // u32
  }
}
```
