#![doc = "Partial family for Devlink."]
#![allow(clippy::all)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(irrefutable_let_patterns)]
#![allow(unreachable_code)]
#![allow(unreachable_patterns)]
use crate::builtin::{PushBuiltinBitfield32, PushBuiltinNfgenmsg, PushDummy, PushNlmsghdr};
use crate::{
    consts,
    traits::{NetlinkRequest, Protocol},
    utils::*,
};
pub const PROTONAME: &CStr = c"devlink";
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum SbPoolType {
    Ingress = 0,
    Egress = 1,
}
impl SbPoolType {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Ingress,
            1 => Self::Egress,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum PortType {
    Notset = 0,
    Auto = 1,
    Eth = 2,
    Ib = 3,
}
impl PortType {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Notset,
            1 => Self::Auto,
            2 => Self::Eth,
            3 => Self::Ib,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum PortFlavour {
    Physical = 0,
    Cpu = 1,
    Dsa = 2,
    PciPf = 3,
    PciVf = 4,
    Virtual = 5,
    Unused = 6,
    PciSf = 7,
}
impl PortFlavour {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Physical,
            1 => Self::Cpu,
            2 => Self::Dsa,
            3 => Self::PciPf,
            4 => Self::PciVf,
            5 => Self::Virtual,
            6 => Self::Unused,
            7 => Self::PciSf,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum PortFnState {
    Inactive = 0,
    Active = 1,
}
impl PortFnState {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Inactive,
            1 => Self::Active,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum PortFnOpstate {
    Detached = 0,
    Attached = 1,
}
impl PortFnOpstate {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Detached,
            1 => Self::Attached,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum PortFnAttrCap {
    RoceBit = 0,
    MigratableBit = 1,
    IpsecCryptoBit = 2,
    IpsecPacketBit = 3,
}
impl PortFnAttrCap {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::RoceBit,
            1 => Self::MigratableBit,
            2 => Self::IpsecCryptoBit,
            3 => Self::IpsecPacketBit,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum RateType {
    Leaf = 0,
    Node = 1,
}
impl RateType {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Leaf,
            1 => Self::Node,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum SbThresholdType {
    Static = 0,
    Dynamic = 1,
}
impl SbThresholdType {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Static,
            1 => Self::Dynamic,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum EswitchMode {
    Legacy = 0,
    Switchdev = 1,
    SwitchdevInactive = 2,
}
impl EswitchMode {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Legacy,
            1 => Self::Switchdev,
            2 => Self::SwitchdevInactive,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum EswitchInlineMode {
    None = 0,
    Link = 1,
    Network = 2,
    Transport = 3,
}
impl EswitchInlineMode {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::None,
            1 => Self::Link,
            2 => Self::Network,
            3 => Self::Transport,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum EswitchEncapMode {
    None = 0,
    Basic = 1,
}
impl EswitchEncapMode {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::None,
            1 => Self::Basic,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum DpipeHeaderId {
    Ethernet = 0,
    Ipv4 = 1,
    Ipv6 = 2,
}
impl DpipeHeaderId {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Ethernet,
            1 => Self::Ipv4,
            2 => Self::Ipv6,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum DpipeMatchType {
    FieldExact = 0,
}
impl DpipeMatchType {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::FieldExact,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum DpipeActionType {
    FieldModify = 0,
}
impl DpipeActionType {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::FieldModify,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum DpipeFieldMappingType {
    None = 0,
    Ifindex = 1,
}
impl DpipeFieldMappingType {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::None,
            1 => Self::Ifindex,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum ResourceUnit {
    Entry = 0,
}
impl ResourceUnit {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Entry,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum ReloadAction {
    DriverReinit = 1,
    FwActivate = 2,
}
impl ReloadAction {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            1 => Self::DriverReinit,
            2 => Self::FwActivate,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum ParamCmode {
    Runtime = 0,
    Driverinit = 1,
    Permanent = 2,
}
impl ParamCmode {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Runtime,
            1 => Self::Driverinit,
            2 => Self::Permanent,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum FlashOverwrite {
    SettingsBit = 0,
    IdentifiersBit = 1,
}
impl FlashOverwrite {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::SettingsBit,
            1 => Self::IdentifiersBit,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum TrapAction {
    Drop = 0,
    Trap = 1,
    Mirror = 2,
}
impl TrapAction {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Drop,
            1 => Self::Trap,
            2 => Self::Mirror,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum TrapType {
    Drop = 0,
    Exception = 1,
    Control = 2,
}
impl TrapType {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            0 => Self::Drop,
            1 => Self::Exception,
            2 => Self::Control,
            _ => return None,
        })
    }
}
#[doc = "Enum - defines an integer enumeration, with values for each entry incrementing by 1, (e.g. 0, 1, 2, 3)"]
#[derive(Debug, Clone, Copy)]
pub enum VarAttrType {
    U8 = 1,
    U16 = 2,
    U32 = 3,
    U64 = 4,
    String = 5,
    Flag = 6,
    NulString = 10,
    Binary = 11,
}
impl VarAttrType {
    pub fn from_value(value: u64) -> Option<Self> {
        Some(match value {
            1 => Self::U8,
            2 => Self::U16,
            3 => Self::U32,
            4 => Self::U64,
            5 => Self::String,
            6 => Self::Flag,
            10 => Self::NulString,
            11 => Self::Binary,
            _ => return None,
        })
    }
}
pub const RATE_TC_INDEX_MAX: u64 = 7u64;
#[derive(Clone)]
pub enum Devlink<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    #[doc = "Associated type: \"PortType\" (enum)"]
    PortType(u16),
    PortDesiredType(u16),
    PortNetdevIfindex(u32),
    PortNetdevName(&'a CStr),
    PortIbdevName(&'a CStr),
    PortSplitCount(u32),
    PortSplitGroup(u32),
    SbIndex(u32),
    SbSize(u32),
    SbIngressPoolCount(u16),
    SbEgressPoolCount(u16),
    SbIngressTcCount(u16),
    SbEgressTcCount(u16),
    SbPoolIndex(u16),
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    SbPoolType(u8),
    SbPoolSize(u32),
    #[doc = "Associated type: \"SbThresholdType\" (enum)"]
    SbPoolThresholdType(u8),
    SbThreshold(u32),
    SbTcIndex(u16),
    SbOccCur(u32),
    SbOccMax(u32),
    #[doc = "Associated type: \"EswitchMode\" (enum)"]
    EswitchMode(u16),
    #[doc = "Associated type: \"EswitchInlineMode\" (enum)"]
    EswitchInlineMode(u8),
    DpipeTables(IterableDlDpipeTables<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeTable(IterableDlDpipeTable<'a>),
    DpipeTableName(&'a CStr),
    DpipeTableSize(u64),
    DpipeTableMatches(IterableDlDpipeTableMatches<'a>),
    DpipeTableActions(IterableDlDpipeTableActions<'a>),
    DpipeTableCountersEnabled(u8),
    DpipeEntries(IterableDlDpipeEntries<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeEntry(IterableDlDpipeEntry<'a>),
    DpipeEntryIndex(u64),
    DpipeEntryMatchValues(IterableDlDpipeEntryMatchValues<'a>),
    DpipeEntryActionValues(IterableDlDpipeEntryActionValues<'a>),
    DpipeEntryCounter(u64),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeMatch(IterableDlDpipeMatch<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeMatchValue(IterableDlDpipeMatchValue<'a>),
    #[doc = "Associated type: \"DpipeMatchType\" (enum)"]
    DpipeMatchType(u32),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeAction(IterableDlDpipeAction<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeActionValue(IterableDlDpipeActionValue<'a>),
    #[doc = "Associated type: \"DpipeActionType\" (enum)"]
    DpipeActionType(u32),
    DpipeValue(&'a [u8]),
    DpipeValueMask(&'a [u8]),
    DpipeValueMapping(u32),
    DpipeHeaders(IterableDlDpipeHeaders<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeHeader(IterableDlDpipeHeader<'a>),
    DpipeHeaderName(&'a CStr),
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    DpipeHeaderId(u32),
    DpipeHeaderFields(IterableDlDpipeHeaderFields<'a>),
    DpipeHeaderGlobal(u8),
    DpipeHeaderIndex(u32),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeField(IterableDlDpipeField<'a>),
    DpipeFieldName(&'a CStr),
    DpipeFieldId(u32),
    DpipeFieldBitwidth(u32),
    #[doc = "Associated type: \"DpipeFieldMappingType\" (enum)"]
    DpipeFieldMappingType(u32),
    Pad(&'a [u8]),
    #[doc = "Associated type: \"EswitchEncapMode\" (enum)"]
    EswitchEncapMode(u8),
    ResourceList(IterableDlResourceList<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Resource(IterableDlResource<'a>),
    ResourceName(&'a CStr),
    ResourceId(u64),
    ResourceSize(u64),
    ResourceSizeNew(u64),
    ResourceSizeValid(u8),
    ResourceSizeMin(u64),
    ResourceSizeMax(u64),
    ResourceSizeGran(u64),
    #[doc = "Associated type: \"ResourceUnit\" (enum)"]
    ResourceUnit(u8),
    ResourceOcc(u64),
    DpipeTableResourceId(u64),
    DpipeTableResourceUnits(u64),
    #[doc = "Associated type: \"PortFlavour\" (enum)"]
    PortFlavour(u16),
    PortNumber(u32),
    PortSplitSubportNumber(u32),
    Param(IterableDlParam<'a>),
    ParamName(&'a CStr),
    ParamGeneric(()),
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    ParamType(u8),
    #[doc = "Associated type: \"ParamCmode\" (enum)"]
    ParamValueCmode(u8),
    RegionName(&'a CStr),
    RegionSize(u64),
    RegionSnapshots(IterableDlRegionSnapshots<'a>),
    RegionSnapshot(IterableDlRegionSnapshot<'a>),
    RegionSnapshotId(u32),
    RegionChunks(IterableDlRegionChunks<'a>),
    RegionChunk(IterableDlRegionChunk<'a>),
    RegionChunkData(&'a [u8]),
    RegionChunkAddr(u64),
    RegionChunkLen(u64),
    InfoDriverName(&'a CStr),
    InfoSerialNumber(&'a CStr),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    InfoVersionFixed(IterableDlInfoVersion<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    InfoVersionRunning(IterableDlInfoVersion<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    InfoVersionStored(IterableDlInfoVersion<'a>),
    InfoVersionName(&'a CStr),
    InfoVersionValue(&'a CStr),
    SbPoolCellSize(u32),
    Fmsg(IterableDlFmsg<'a>),
    FmsgObjNestStart(()),
    FmsgPairNestStart(()),
    FmsgArrNestStart(()),
    FmsgNestEnd(()),
    FmsgObjName(&'a CStr),
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    FmsgObjValueType(u8),
    HealthReporter(IterableDlHealthReporter<'a>),
    HealthReporterName(&'a CStr),
    HealthReporterState(u8),
    HealthReporterErrCount(u64),
    HealthReporterRecoverCount(u64),
    HealthReporterDumpTs(u64),
    HealthReporterGracefulPeriod(u64),
    HealthReporterAutoRecover(u8),
    FlashUpdateFileName(&'a CStr),
    FlashUpdateComponent(&'a CStr),
    FlashUpdateStatusMsg(&'a CStr),
    FlashUpdateStatusDone(u64),
    FlashUpdateStatusTotal(u64),
    PortPciPfNumber(u16),
    PortPciVfNumber(u16),
    Stats(IterableDlAttrStats<'a>),
    TrapName(&'a CStr),
    #[doc = "Associated type: \"TrapAction\" (enum)"]
    TrapAction(u8),
    #[doc = "Associated type: \"TrapType\" (enum)"]
    TrapType(u8),
    TrapGeneric(()),
    TrapMetadata(IterableDlTrapMetadata<'a>),
    TrapGroupName(&'a CStr),
    ReloadFailed(u8),
    HealthReporterDumpTsNs(u64),
    NetnsFd(u32),
    NetnsPid(u32),
    NetnsId(u32),
    HealthReporterAutoDump(u8),
    TrapPolicerId(u32),
    TrapPolicerRate(u64),
    TrapPolicerBurst(u64),
    PortFunction(IterableDlPortFunction<'a>),
    InfoBoardSerialNumber(&'a CStr),
    PortLanes(u32),
    PortSplittable(u8),
    PortExternal(u8),
    PortControllerNumber(u32),
    FlashUpdateStatusTimeout(u64),
    #[doc = "Associated type: \"FlashOverwrite\" (1 bit per enumeration)"]
    FlashUpdateOverwriteMask(PushBuiltinBitfield32),
    #[doc = "Associated type: \"ReloadAction\" (enum)"]
    ReloadAction(u8),
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    ReloadActionsPerformed(PushBuiltinBitfield32),
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    ReloadLimits(PushBuiltinBitfield32),
    DevStats(IterableDlDevStats<'a>),
    ReloadStats(IterableDlReloadStats<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    ReloadStatsEntry(IterableDlReloadStatsEntry<'a>),
    ReloadStatsLimit(u8),
    ReloadStatsValue(u32),
    RemoteReloadStats(IterableDlReloadStats<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    ReloadActionInfo(IterableDlReloadActInfo<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    ReloadActionStats(IterableDlReloadActStats<'a>),
    PortPciSfNumber(u32),
    #[doc = "Associated type: \"RateType\" (enum)"]
    RateType(u16),
    RateTxShare(u64),
    RateTxMax(u64),
    RateNodeName(&'a CStr),
    RateParentNodeName(&'a CStr),
    RegionMaxSnapshots(u32),
    LinecardIndex(u32),
    LinecardState(u8),
    LinecardType(&'a CStr),
    LinecardSupportedTypes(IterableDlLinecardSupportedTypes<'a>),
    Selftests(IterableDlSelftestId<'a>),
    RateTxPriority(u32),
    RateTxWeight(u32),
    RegionDirect(()),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    RateTcBws(IterableDlRateTcBws<'a>),
    #[doc = "Time (in msec) for recoveries before starting the grace period."]
    HealthReporterBurstPeriod(u64),
}
impl<'a> IterableDevlink<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"PortType\" (enum)"]
    pub fn get_port_type(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_desired_type(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortDesiredType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortDesiredType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_netdev_ifindex(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortNetdevIfindex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortNetdevIfindex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_netdev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortNetdevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortNetdevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_ibdev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortIbdevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortIbdevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_split_count(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortSplitCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortSplitCount",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_split_group(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortSplitGroup(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortSplitGroup",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_size(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbSize",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_ingress_pool_count(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbIngressPoolCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbIngressPoolCount",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_egress_pool_count(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbEgressPoolCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbEgressPoolCount",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_ingress_tc_count(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbIngressTcCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbIngressTcCount",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_egress_tc_count(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbEgressTcCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbEgressTcCount",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbPoolIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbPoolIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    pub fn get_sb_pool_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbPoolType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbPoolType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_size(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbPoolSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbPoolSize",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"SbThresholdType\" (enum)"]
    pub fn get_sb_pool_threshold_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbPoolThresholdType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbPoolThresholdType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_threshold(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbThreshold(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbThreshold",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_tc_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbTcIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbTcIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_occ_cur(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbOccCur(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbOccCur",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_occ_max(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbOccMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbOccMax",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"EswitchMode\" (enum)"]
    pub fn get_eswitch_mode(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::EswitchMode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "EswitchMode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"EswitchInlineMode\" (enum)"]
    pub fn get_eswitch_inline_mode(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::EswitchInlineMode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "EswitchInlineMode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_tables(&self) -> Result<IterableDlDpipeTables<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeTables(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeTables",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_table(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlDpipeTable<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::DpipeTable(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_dpipe_table_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeTableName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeTableName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_size(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeTableSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeTableSize",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_matches(&self) -> Result<IterableDlDpipeTableMatches<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeTableMatches(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeTableMatches",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_actions(&self) -> Result<IterableDlDpipeTableActions<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeTableActions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeTableActions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_counters_enabled(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeTableCountersEnabled(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeTableCountersEnabled",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_entries(&self) -> Result<IterableDlDpipeEntries<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeEntries(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeEntries",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_entry(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlDpipeEntry<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::DpipeEntry(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_dpipe_entry_index(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeEntryIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeEntryIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_entry_match_values(
        &self,
    ) -> Result<IterableDlDpipeEntryMatchValues<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeEntryMatchValues(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeEntryMatchValues",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_entry_action_values(
        &self,
    ) -> Result<IterableDlDpipeEntryActionValues<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeEntryActionValues(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeEntryActionValues",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_entry_counter(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeEntryCounter(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeEntryCounter",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_match(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlDpipeMatch<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::DpipeMatch(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_match_value(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlDpipeMatchValue<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::DpipeMatchValue(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Associated type: \"DpipeMatchType\" (enum)"]
    pub fn get_dpipe_match_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeMatchType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeMatchType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_action(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlDpipeAction<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::DpipeAction(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_action_value(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlDpipeActionValue<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::DpipeActionValue(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Associated type: \"DpipeActionType\" (enum)"]
    pub fn get_dpipe_action_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeActionType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeActionType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_value(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeValue(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeValue",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_value_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeValueMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeValueMask",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_value_mapping(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeValueMapping(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeValueMapping",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_headers(&self) -> Result<IterableDlDpipeHeaders<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeHeaders(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeHeaders",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_header(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlDpipeHeader<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::DpipeHeader(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_dpipe_header_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeHeaderName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeHeaderName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    pub fn get_dpipe_header_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeHeaderId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeHeaderId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_header_fields(&self) -> Result<IterableDlDpipeHeaderFields<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeHeaderFields(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeHeaderFields",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_header_global(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeHeaderGlobal(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeHeaderGlobal",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_header_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeHeaderIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeHeaderIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_field(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlDpipeField<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::DpipeField(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_dpipe_field_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeFieldName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeFieldName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_field_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeFieldId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeFieldId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_field_bitwidth(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeFieldBitwidth(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeFieldBitwidth",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"DpipeFieldMappingType\" (enum)"]
    pub fn get_dpipe_field_mapping_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeFieldMappingType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeFieldMappingType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_pad(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::Pad(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "Pad",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"EswitchEncapMode\" (enum)"]
    pub fn get_eswitch_encap_mode(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::EswitchEncapMode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "EswitchEncapMode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_list(&self) -> Result<IterableDlResourceList<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ResourceList(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ResourceList",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_resource(&self) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlResource<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::Resource(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_resource_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ResourceName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ResourceName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_id(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ResourceId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ResourceId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ResourceSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ResourceSize",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size_new(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ResourceSizeNew(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ResourceSizeNew",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size_valid(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ResourceSizeValid(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ResourceSizeValid",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size_min(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ResourceSizeMin(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ResourceSizeMin",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size_max(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ResourceSizeMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ResourceSizeMax",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size_gran(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ResourceSizeGran(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ResourceSizeGran",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"ResourceUnit\" (enum)"]
    pub fn get_resource_unit(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ResourceUnit(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ResourceUnit",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_occ(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ResourceOcc(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ResourceOcc",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_resource_id(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeTableResourceId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeTableResourceId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_resource_units(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DpipeTableResourceUnits(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DpipeTableResourceUnits",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"PortFlavour\" (enum)"]
    pub fn get_port_flavour(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortFlavour(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortFlavour",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_number(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_split_subport_number(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortSplitSubportNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortSplitSubportNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_param(&self) -> Result<IterableDlParam<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::Param(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "Param",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_param_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ParamName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ParamName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_param_generic(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ParamGeneric(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ParamGeneric",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    pub fn get_param_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ParamType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ParamType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"ParamCmode\" (enum)"]
    pub fn get_param_value_cmode(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ParamValueCmode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ParamValueCmode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_size(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionSize",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_snapshots(&self) -> Result<IterableDlRegionSnapshots<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionSnapshots(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionSnapshots",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_snapshot(&self) -> Result<IterableDlRegionSnapshot<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionSnapshot(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionSnapshot",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_snapshot_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionSnapshotId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionSnapshotId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_chunks(&self) -> Result<IterableDlRegionChunks<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionChunks(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionChunks",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_chunk(&self) -> Result<IterableDlRegionChunk<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionChunk(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionChunk",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_chunk_data(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionChunkData(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionChunkData",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_chunk_addr(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionChunkAddr(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionChunkAddr",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_chunk_len(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionChunkLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionChunkLen",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info_driver_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::InfoDriverName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "InfoDriverName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info_serial_number(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::InfoSerialNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "InfoSerialNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_info_version_fixed(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlInfoVersion<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::InfoVersionFixed(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_info_version_running(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlInfoVersion<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::InfoVersionRunning(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_info_version_stored(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlInfoVersion<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::InfoVersionStored(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_info_version_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::InfoVersionName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "InfoVersionName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info_version_value(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::InfoVersionValue(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "InfoVersionValue",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_cell_size(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::SbPoolCellSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "SbPoolCellSize",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_fmsg(&self) -> Result<IterableDlFmsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::Fmsg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "Fmsg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_fmsg_obj_nest_start(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FmsgObjNestStart(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FmsgObjNestStart",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_fmsg_pair_nest_start(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FmsgPairNestStart(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FmsgPairNestStart",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_fmsg_arr_nest_start(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FmsgArrNestStart(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FmsgArrNestStart",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_fmsg_nest_end(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FmsgNestEnd(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FmsgNestEnd",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_fmsg_obj_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FmsgObjName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FmsgObjName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    pub fn get_fmsg_obj_value_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FmsgObjValueType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FmsgObjValueType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter(&self) -> Result<IterableDlHealthReporter<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::HealthReporter(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "HealthReporter",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::HealthReporterName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "HealthReporterName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_state(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::HealthReporterState(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "HealthReporterState",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_err_count(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::HealthReporterErrCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "HealthReporterErrCount",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_recover_count(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::HealthReporterRecoverCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "HealthReporterRecoverCount",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_dump_ts(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::HealthReporterDumpTs(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "HealthReporterDumpTs",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_graceful_period(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::HealthReporterGracefulPeriod(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "HealthReporterGracefulPeriod",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_auto_recover(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::HealthReporterAutoRecover(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "HealthReporterAutoRecover",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flash_update_file_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FlashUpdateFileName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FlashUpdateFileName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flash_update_component(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FlashUpdateComponent(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FlashUpdateComponent",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flash_update_status_msg(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FlashUpdateStatusMsg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FlashUpdateStatusMsg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flash_update_status_done(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FlashUpdateStatusDone(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FlashUpdateStatusDone",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flash_update_status_total(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FlashUpdateStatusTotal(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FlashUpdateStatusTotal",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_pci_pf_number(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortPciPfNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortPciPfNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_pci_vf_number(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortPciVfNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortPciVfNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_stats(&self) -> Result<IterableDlAttrStats<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::Stats(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "Stats",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::TrapName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "TrapName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"TrapAction\" (enum)"]
    pub fn get_trap_action(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::TrapAction(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "TrapAction",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"TrapType\" (enum)"]
    pub fn get_trap_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::TrapType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "TrapType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_generic(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::TrapGeneric(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "TrapGeneric",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_metadata(&self) -> Result<IterableDlTrapMetadata<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::TrapMetadata(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "TrapMetadata",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_group_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::TrapGroupName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "TrapGroupName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reload_failed(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ReloadFailed(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ReloadFailed",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_dump_ts_ns(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::HealthReporterDumpTsNs(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "HealthReporterDumpTsNs",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_netns_fd(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::NetnsFd(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "NetnsFd",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_netns_pid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::NetnsPid(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "NetnsPid",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_netns_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::NetnsId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "NetnsId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_auto_dump(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::HealthReporterAutoDump(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "HealthReporterAutoDump",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_policer_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::TrapPolicerId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "TrapPolicerId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_policer_rate(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::TrapPolicerRate(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "TrapPolicerRate",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_policer_burst(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::TrapPolicerBurst(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "TrapPolicerBurst",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_function(&self) -> Result<IterableDlPortFunction<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortFunction(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortFunction",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info_board_serial_number(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::InfoBoardSerialNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "InfoBoardSerialNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_lanes(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortLanes(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortLanes",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_splittable(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortSplittable(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortSplittable",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_external(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortExternal(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortExternal",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_controller_number(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortControllerNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortControllerNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flash_update_status_timeout(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FlashUpdateStatusTimeout(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FlashUpdateStatusTimeout",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"FlashOverwrite\" (1 bit per enumeration)"]
    pub fn get_flash_update_overwrite_mask(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::FlashUpdateOverwriteMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "FlashUpdateOverwriteMask",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"ReloadAction\" (enum)"]
    pub fn get_reload_action(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ReloadAction(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ReloadAction",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    pub fn get_reload_actions_performed(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ReloadActionsPerformed(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ReloadActionsPerformed",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    pub fn get_reload_limits(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ReloadLimits(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ReloadLimits",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_stats(&self) -> Result<IterableDlDevStats<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::DevStats(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "DevStats",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reload_stats(&self) -> Result<IterableDlReloadStats<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ReloadStats(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ReloadStats",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_reload_stats_entry(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlReloadStatsEntry<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::ReloadStatsEntry(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_reload_stats_limit(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ReloadStatsLimit(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ReloadStatsLimit",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reload_stats_value(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::ReloadStatsValue(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "ReloadStatsValue",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_remote_reload_stats(&self) -> Result<IterableDlReloadStats<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RemoteReloadStats(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RemoteReloadStats",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_reload_action_info(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlReloadActInfo<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::ReloadActionInfo(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_reload_action_stats(
        &self,
    ) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlReloadActStats<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::ReloadActionStats(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_port_pci_sf_number(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::PortPciSfNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "PortPciSfNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"RateType\" (enum)"]
    pub fn get_rate_type(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RateType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RateType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_share(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RateTxShare(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RateTxShare",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_max(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RateTxMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RateTxMax",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_node_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RateNodeName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RateNodeName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_parent_node_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RateParentNodeName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RateParentNodeName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_max_snapshots(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionMaxSnapshots(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionMaxSnapshots",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_linecard_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::LinecardIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "LinecardIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_linecard_state(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::LinecardState(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "LinecardState",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_linecard_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::LinecardType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "LinecardType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_linecard_supported_types(
        &self,
    ) -> Result<IterableDlLinecardSupportedTypes<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::LinecardSupportedTypes(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "LinecardSupportedTypes",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_selftests(&self) -> Result<IterableDlSelftestId<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::Selftests(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "Selftests",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_priority(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RateTxPriority(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RateTxPriority",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_weight(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RateTxWeight(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RateTxWeight",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_direct(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::RegionDirect(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "RegionDirect",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_rate_tc_bws(&self) -> MultiAttrIterable<Self, Devlink<'a>, IterableDlRateTcBws<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let Devlink::RateTcBws(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Time (in msec) for recoveries before starting the grace period."]
    pub fn get_health_reporter_burst_period(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let Devlink::HealthReporterBurstPeriod(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "Devlink",
            "HealthReporterBurstPeriod",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl Devlink<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDevlink<'a> {
        IterableDevlink::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "BusName",
            2u16 => "DevName",
            3u16 => "PortIndex",
            4u16 => "PortType",
            5u16 => "PortDesiredType",
            6u16 => "PortNetdevIfindex",
            7u16 => "PortNetdevName",
            8u16 => "PortIbdevName",
            9u16 => "PortSplitCount",
            10u16 => "PortSplitGroup",
            11u16 => "SbIndex",
            12u16 => "SbSize",
            13u16 => "SbIngressPoolCount",
            14u16 => "SbEgressPoolCount",
            15u16 => "SbIngressTcCount",
            16u16 => "SbEgressTcCount",
            17u16 => "SbPoolIndex",
            18u16 => "SbPoolType",
            19u16 => "SbPoolSize",
            20u16 => "SbPoolThresholdType",
            21u16 => "SbThreshold",
            22u16 => "SbTcIndex",
            23u16 => "SbOccCur",
            24u16 => "SbOccMax",
            25u16 => "EswitchMode",
            26u16 => "EswitchInlineMode",
            27u16 => "DpipeTables",
            28u16 => "DpipeTable",
            29u16 => "DpipeTableName",
            30u16 => "DpipeTableSize",
            31u16 => "DpipeTableMatches",
            32u16 => "DpipeTableActions",
            33u16 => "DpipeTableCountersEnabled",
            34u16 => "DpipeEntries",
            35u16 => "DpipeEntry",
            36u16 => "DpipeEntryIndex",
            37u16 => "DpipeEntryMatchValues",
            38u16 => "DpipeEntryActionValues",
            39u16 => "DpipeEntryCounter",
            40u16 => "DpipeMatch",
            41u16 => "DpipeMatchValue",
            42u16 => "DpipeMatchType",
            43u16 => "DpipeAction",
            44u16 => "DpipeActionValue",
            45u16 => "DpipeActionType",
            46u16 => "DpipeValue",
            47u16 => "DpipeValueMask",
            48u16 => "DpipeValueMapping",
            49u16 => "DpipeHeaders",
            50u16 => "DpipeHeader",
            51u16 => "DpipeHeaderName",
            52u16 => "DpipeHeaderId",
            53u16 => "DpipeHeaderFields",
            54u16 => "DpipeHeaderGlobal",
            55u16 => "DpipeHeaderIndex",
            56u16 => "DpipeField",
            57u16 => "DpipeFieldName",
            58u16 => "DpipeFieldId",
            59u16 => "DpipeFieldBitwidth",
            60u16 => "DpipeFieldMappingType",
            61u16 => "Pad",
            62u16 => "EswitchEncapMode",
            63u16 => "ResourceList",
            64u16 => "Resource",
            65u16 => "ResourceName",
            66u16 => "ResourceId",
            67u16 => "ResourceSize",
            68u16 => "ResourceSizeNew",
            69u16 => "ResourceSizeValid",
            70u16 => "ResourceSizeMin",
            71u16 => "ResourceSizeMax",
            72u16 => "ResourceSizeGran",
            73u16 => "ResourceUnit",
            74u16 => "ResourceOcc",
            75u16 => "DpipeTableResourceId",
            76u16 => "DpipeTableResourceUnits",
            77u16 => "PortFlavour",
            78u16 => "PortNumber",
            79u16 => "PortSplitSubportNumber",
            80u16 => "Param",
            81u16 => "ParamName",
            82u16 => "ParamGeneric",
            83u16 => "ParamType",
            87u16 => "ParamValueCmode",
            88u16 => "RegionName",
            89u16 => "RegionSize",
            90u16 => "RegionSnapshots",
            91u16 => "RegionSnapshot",
            92u16 => "RegionSnapshotId",
            93u16 => "RegionChunks",
            94u16 => "RegionChunk",
            95u16 => "RegionChunkData",
            96u16 => "RegionChunkAddr",
            97u16 => "RegionChunkLen",
            98u16 => "InfoDriverName",
            99u16 => "InfoSerialNumber",
            100u16 => "InfoVersionFixed",
            101u16 => "InfoVersionRunning",
            102u16 => "InfoVersionStored",
            103u16 => "InfoVersionName",
            104u16 => "InfoVersionValue",
            105u16 => "SbPoolCellSize",
            106u16 => "Fmsg",
            107u16 => "FmsgObjNestStart",
            108u16 => "FmsgPairNestStart",
            109u16 => "FmsgArrNestStart",
            110u16 => "FmsgNestEnd",
            111u16 => "FmsgObjName",
            112u16 => "FmsgObjValueType",
            114u16 => "HealthReporter",
            115u16 => "HealthReporterName",
            116u16 => "HealthReporterState",
            117u16 => "HealthReporterErrCount",
            118u16 => "HealthReporterRecoverCount",
            119u16 => "HealthReporterDumpTs",
            120u16 => "HealthReporterGracefulPeriod",
            121u16 => "HealthReporterAutoRecover",
            122u16 => "FlashUpdateFileName",
            123u16 => "FlashUpdateComponent",
            124u16 => "FlashUpdateStatusMsg",
            125u16 => "FlashUpdateStatusDone",
            126u16 => "FlashUpdateStatusTotal",
            127u16 => "PortPciPfNumber",
            128u16 => "PortPciVfNumber",
            129u16 => "Stats",
            130u16 => "TrapName",
            131u16 => "TrapAction",
            132u16 => "TrapType",
            133u16 => "TrapGeneric",
            134u16 => "TrapMetadata",
            135u16 => "TrapGroupName",
            136u16 => "ReloadFailed",
            137u16 => "HealthReporterDumpTsNs",
            138u16 => "NetnsFd",
            139u16 => "NetnsPid",
            140u16 => "NetnsId",
            141u16 => "HealthReporterAutoDump",
            142u16 => "TrapPolicerId",
            143u16 => "TrapPolicerRate",
            144u16 => "TrapPolicerBurst",
            145u16 => "PortFunction",
            146u16 => "InfoBoardSerialNumber",
            147u16 => "PortLanes",
            148u16 => "PortSplittable",
            149u16 => "PortExternal",
            150u16 => "PortControllerNumber",
            151u16 => "FlashUpdateStatusTimeout",
            152u16 => "FlashUpdateOverwriteMask",
            153u16 => "ReloadAction",
            154u16 => "ReloadActionsPerformed",
            155u16 => "ReloadLimits",
            156u16 => "DevStats",
            157u16 => "ReloadStats",
            158u16 => "ReloadStatsEntry",
            159u16 => "ReloadStatsLimit",
            160u16 => "ReloadStatsValue",
            161u16 => "RemoteReloadStats",
            162u16 => "ReloadActionInfo",
            163u16 => "ReloadActionStats",
            164u16 => "PortPciSfNumber",
            165u16 => "RateType",
            166u16 => "RateTxShare",
            167u16 => "RateTxMax",
            168u16 => "RateNodeName",
            169u16 => "RateParentNodeName",
            170u16 => "RegionMaxSnapshots",
            171u16 => "LinecardIndex",
            172u16 => "LinecardState",
            173u16 => "LinecardType",
            174u16 => "LinecardSupportedTypes",
            176u16 => "Selftests",
            177u16 => "RateTxPriority",
            178u16 => "RateTxWeight",
            179u16 => "RegionDirect",
            180u16 => "RateTcBws",
            181u16 => "HealthReporterBurstPeriod",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDevlink<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDevlink<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDevlink<'a> {
    type Item = Result<Devlink<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => Devlink::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => Devlink::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => Devlink::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => Devlink::PortType({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                5u16 => Devlink::PortDesiredType({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                6u16 => Devlink::PortNetdevIfindex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                7u16 => Devlink::PortNetdevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                8u16 => Devlink::PortIbdevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => Devlink::PortSplitCount({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                10u16 => Devlink::PortSplitGroup({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => Devlink::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                12u16 => Devlink::SbSize({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                13u16 => Devlink::SbIngressPoolCount({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                14u16 => Devlink::SbEgressPoolCount({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                15u16 => Devlink::SbIngressTcCount({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                16u16 => Devlink::SbEgressTcCount({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => Devlink::SbPoolIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => Devlink::SbPoolType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                19u16 => Devlink::SbPoolSize({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                20u16 => Devlink::SbPoolThresholdType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                21u16 => Devlink::SbThreshold({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                22u16 => Devlink::SbTcIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                23u16 => Devlink::SbOccCur({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                24u16 => Devlink::SbOccMax({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                25u16 => Devlink::EswitchMode({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                26u16 => Devlink::EswitchInlineMode({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                27u16 => Devlink::DpipeTables({
                    let res = Some(IterableDlDpipeTables::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                28u16 => Devlink::DpipeTable({
                    let res = Some(IterableDlDpipeTable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                29u16 => Devlink::DpipeTableName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                30u16 => Devlink::DpipeTableSize({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                31u16 => Devlink::DpipeTableMatches({
                    let res = Some(IterableDlDpipeTableMatches::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                32u16 => Devlink::DpipeTableActions({
                    let res = Some(IterableDlDpipeTableActions::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                33u16 => Devlink::DpipeTableCountersEnabled({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                34u16 => Devlink::DpipeEntries({
                    let res = Some(IterableDlDpipeEntries::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                35u16 => Devlink::DpipeEntry({
                    let res = Some(IterableDlDpipeEntry::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                36u16 => Devlink::DpipeEntryIndex({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                37u16 => Devlink::DpipeEntryMatchValues({
                    let res = Some(IterableDlDpipeEntryMatchValues::with_loc(
                        next,
                        self.orig_loc,
                    ));
                    let Some(val) = res else { break };
                    val
                }),
                38u16 => Devlink::DpipeEntryActionValues({
                    let res = Some(IterableDlDpipeEntryActionValues::with_loc(
                        next,
                        self.orig_loc,
                    ));
                    let Some(val) = res else { break };
                    val
                }),
                39u16 => Devlink::DpipeEntryCounter({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                40u16 => Devlink::DpipeMatch({
                    let res = Some(IterableDlDpipeMatch::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                41u16 => Devlink::DpipeMatchValue({
                    let res = Some(IterableDlDpipeMatchValue::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                42u16 => Devlink::DpipeMatchType({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                43u16 => Devlink::DpipeAction({
                    let res = Some(IterableDlDpipeAction::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                44u16 => Devlink::DpipeActionValue({
                    let res = Some(IterableDlDpipeActionValue::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                45u16 => Devlink::DpipeActionType({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                46u16 => Devlink::DpipeValue({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                47u16 => Devlink::DpipeValueMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                48u16 => Devlink::DpipeValueMapping({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                49u16 => Devlink::DpipeHeaders({
                    let res = Some(IterableDlDpipeHeaders::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                50u16 => Devlink::DpipeHeader({
                    let res = Some(IterableDlDpipeHeader::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                51u16 => Devlink::DpipeHeaderName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                52u16 => Devlink::DpipeHeaderId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                53u16 => Devlink::DpipeHeaderFields({
                    let res = Some(IterableDlDpipeHeaderFields::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                54u16 => Devlink::DpipeHeaderGlobal({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                55u16 => Devlink::DpipeHeaderIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                56u16 => Devlink::DpipeField({
                    let res = Some(IterableDlDpipeField::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                57u16 => Devlink::DpipeFieldName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                58u16 => Devlink::DpipeFieldId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                59u16 => Devlink::DpipeFieldBitwidth({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                60u16 => Devlink::DpipeFieldMappingType({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                61u16 => Devlink::Pad({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                62u16 => Devlink::EswitchEncapMode({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                63u16 => Devlink::ResourceList({
                    let res = Some(IterableDlResourceList::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                64u16 => Devlink::Resource({
                    let res = Some(IterableDlResource::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                65u16 => Devlink::ResourceName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                66u16 => Devlink::ResourceId({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                67u16 => Devlink::ResourceSize({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                68u16 => Devlink::ResourceSizeNew({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                69u16 => Devlink::ResourceSizeValid({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                70u16 => Devlink::ResourceSizeMin({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                71u16 => Devlink::ResourceSizeMax({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                72u16 => Devlink::ResourceSizeGran({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                73u16 => Devlink::ResourceUnit({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                74u16 => Devlink::ResourceOcc({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                75u16 => Devlink::DpipeTableResourceId({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                76u16 => Devlink::DpipeTableResourceUnits({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                77u16 => Devlink::PortFlavour({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                78u16 => Devlink::PortNumber({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                79u16 => Devlink::PortSplitSubportNumber({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                80u16 => Devlink::Param({
                    let res = Some(IterableDlParam::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                81u16 => Devlink::ParamName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                82u16 => Devlink::ParamGeneric(()),
                83u16 => Devlink::ParamType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                87u16 => Devlink::ParamValueCmode({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                88u16 => Devlink::RegionName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                89u16 => Devlink::RegionSize({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                90u16 => Devlink::RegionSnapshots({
                    let res = Some(IterableDlRegionSnapshots::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                91u16 => Devlink::RegionSnapshot({
                    let res = Some(IterableDlRegionSnapshot::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                92u16 => Devlink::RegionSnapshotId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                93u16 => Devlink::RegionChunks({
                    let res = Some(IterableDlRegionChunks::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                94u16 => Devlink::RegionChunk({
                    let res = Some(IterableDlRegionChunk::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                95u16 => Devlink::RegionChunkData({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                96u16 => Devlink::RegionChunkAddr({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                97u16 => Devlink::RegionChunkLen({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                98u16 => Devlink::InfoDriverName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                99u16 => Devlink::InfoSerialNumber({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                100u16 => Devlink::InfoVersionFixed({
                    let res = Some(IterableDlInfoVersion::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                101u16 => Devlink::InfoVersionRunning({
                    let res = Some(IterableDlInfoVersion::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                102u16 => Devlink::InfoVersionStored({
                    let res = Some(IterableDlInfoVersion::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                103u16 => Devlink::InfoVersionName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                104u16 => Devlink::InfoVersionValue({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                105u16 => Devlink::SbPoolCellSize({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                106u16 => Devlink::Fmsg({
                    let res = Some(IterableDlFmsg::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                107u16 => Devlink::FmsgObjNestStart(()),
                108u16 => Devlink::FmsgPairNestStart(()),
                109u16 => Devlink::FmsgArrNestStart(()),
                110u16 => Devlink::FmsgNestEnd(()),
                111u16 => Devlink::FmsgObjName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                112u16 => Devlink::FmsgObjValueType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                114u16 => Devlink::HealthReporter({
                    let res = Some(IterableDlHealthReporter::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                115u16 => Devlink::HealthReporterName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                116u16 => Devlink::HealthReporterState({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                117u16 => Devlink::HealthReporterErrCount({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                118u16 => Devlink::HealthReporterRecoverCount({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                119u16 => Devlink::HealthReporterDumpTs({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                120u16 => Devlink::HealthReporterGracefulPeriod({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                121u16 => Devlink::HealthReporterAutoRecover({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                122u16 => Devlink::FlashUpdateFileName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                123u16 => Devlink::FlashUpdateComponent({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                124u16 => Devlink::FlashUpdateStatusMsg({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                125u16 => Devlink::FlashUpdateStatusDone({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                126u16 => Devlink::FlashUpdateStatusTotal({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                127u16 => Devlink::PortPciPfNumber({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                128u16 => Devlink::PortPciVfNumber({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                129u16 => Devlink::Stats({
                    let res = Some(IterableDlAttrStats::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                130u16 => Devlink::TrapName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                131u16 => Devlink::TrapAction({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                132u16 => Devlink::TrapType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                133u16 => Devlink::TrapGeneric(()),
                134u16 => Devlink::TrapMetadata({
                    let res = Some(IterableDlTrapMetadata::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                135u16 => Devlink::TrapGroupName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                136u16 => Devlink::ReloadFailed({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                137u16 => Devlink::HealthReporterDumpTsNs({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                138u16 => Devlink::NetnsFd({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                139u16 => Devlink::NetnsPid({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                140u16 => Devlink::NetnsId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                141u16 => Devlink::HealthReporterAutoDump({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                142u16 => Devlink::TrapPolicerId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                143u16 => Devlink::TrapPolicerRate({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                144u16 => Devlink::TrapPolicerBurst({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                145u16 => Devlink::PortFunction({
                    let res = Some(IterableDlPortFunction::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                146u16 => Devlink::InfoBoardSerialNumber({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                147u16 => Devlink::PortLanes({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                148u16 => Devlink::PortSplittable({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                149u16 => Devlink::PortExternal({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                150u16 => Devlink::PortControllerNumber({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                151u16 => Devlink::FlashUpdateStatusTimeout({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                152u16 => Devlink::FlashUpdateOverwriteMask({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                153u16 => Devlink::ReloadAction({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                154u16 => Devlink::ReloadActionsPerformed({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                155u16 => Devlink::ReloadLimits({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                156u16 => Devlink::DevStats({
                    let res = Some(IterableDlDevStats::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                157u16 => Devlink::ReloadStats({
                    let res = Some(IterableDlReloadStats::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                158u16 => Devlink::ReloadStatsEntry({
                    let res = Some(IterableDlReloadStatsEntry::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                159u16 => Devlink::ReloadStatsLimit({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                160u16 => Devlink::ReloadStatsValue({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                161u16 => Devlink::RemoteReloadStats({
                    let res = Some(IterableDlReloadStats::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                162u16 => Devlink::ReloadActionInfo({
                    let res = Some(IterableDlReloadActInfo::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                163u16 => Devlink::ReloadActionStats({
                    let res = Some(IterableDlReloadActStats::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                164u16 => Devlink::PortPciSfNumber({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                165u16 => Devlink::RateType({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                166u16 => Devlink::RateTxShare({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                167u16 => Devlink::RateTxMax({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                168u16 => Devlink::RateNodeName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                169u16 => Devlink::RateParentNodeName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                170u16 => Devlink::RegionMaxSnapshots({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                171u16 => Devlink::LinecardIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                172u16 => Devlink::LinecardState({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                173u16 => Devlink::LinecardType({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                174u16 => Devlink::LinecardSupportedTypes({
                    let res = Some(IterableDlLinecardSupportedTypes::with_loc(
                        next,
                        self.orig_loc,
                    ));
                    let Some(val) = res else { break };
                    val
                }),
                176u16 => Devlink::Selftests({
                    let res = Some(IterableDlSelftestId::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                177u16 => Devlink::RateTxPriority({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                178u16 => Devlink::RateTxWeight({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                179u16 => Devlink::RegionDirect(()),
                180u16 => Devlink::RateTcBws({
                    let res = Some(IterableDlRateTcBws::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                181u16 => Devlink::HealthReporterBurstPeriod({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "Devlink",
            r#type.and_then(|t| Devlink::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDevlink<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("Devlink");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                Devlink::BusName(val) => fmt.field("BusName", &val),
                Devlink::DevName(val) => fmt.field("DevName", &val),
                Devlink::PortIndex(val) => fmt.field("PortIndex", &val),
                Devlink::PortType(val) => {
                    fmt.field("PortType", &FormatEnum(val.into(), PortType::from_value))
                }
                Devlink::PortDesiredType(val) => fmt.field("PortDesiredType", &val),
                Devlink::PortNetdevIfindex(val) => fmt.field("PortNetdevIfindex", &val),
                Devlink::PortNetdevName(val) => fmt.field("PortNetdevName", &val),
                Devlink::PortIbdevName(val) => fmt.field("PortIbdevName", &val),
                Devlink::PortSplitCount(val) => fmt.field("PortSplitCount", &val),
                Devlink::PortSplitGroup(val) => fmt.field("PortSplitGroup", &val),
                Devlink::SbIndex(val) => fmt.field("SbIndex", &val),
                Devlink::SbSize(val) => fmt.field("SbSize", &val),
                Devlink::SbIngressPoolCount(val) => fmt.field("SbIngressPoolCount", &val),
                Devlink::SbEgressPoolCount(val) => fmt.field("SbEgressPoolCount", &val),
                Devlink::SbIngressTcCount(val) => fmt.field("SbIngressTcCount", &val),
                Devlink::SbEgressTcCount(val) => fmt.field("SbEgressTcCount", &val),
                Devlink::SbPoolIndex(val) => fmt.field("SbPoolIndex", &val),
                Devlink::SbPoolType(val) => fmt.field(
                    "SbPoolType",
                    &FormatEnum(val.into(), SbPoolType::from_value),
                ),
                Devlink::SbPoolSize(val) => fmt.field("SbPoolSize", &val),
                Devlink::SbPoolThresholdType(val) => fmt.field(
                    "SbPoolThresholdType",
                    &FormatEnum(val.into(), SbThresholdType::from_value),
                ),
                Devlink::SbThreshold(val) => fmt.field("SbThreshold", &val),
                Devlink::SbTcIndex(val) => fmt.field("SbTcIndex", &val),
                Devlink::SbOccCur(val) => fmt.field("SbOccCur", &val),
                Devlink::SbOccMax(val) => fmt.field("SbOccMax", &val),
                Devlink::EswitchMode(val) => fmt.field(
                    "EswitchMode",
                    &FormatEnum(val.into(), EswitchMode::from_value),
                ),
                Devlink::EswitchInlineMode(val) => fmt.field(
                    "EswitchInlineMode",
                    &FormatEnum(val.into(), EswitchInlineMode::from_value),
                ),
                Devlink::DpipeTables(val) => fmt.field("DpipeTables", &val),
                Devlink::DpipeTable(val) => fmt.field("DpipeTable", &val),
                Devlink::DpipeTableName(val) => fmt.field("DpipeTableName", &val),
                Devlink::DpipeTableSize(val) => fmt.field("DpipeTableSize", &val),
                Devlink::DpipeTableMatches(val) => fmt.field("DpipeTableMatches", &val),
                Devlink::DpipeTableActions(val) => fmt.field("DpipeTableActions", &val),
                Devlink::DpipeTableCountersEnabled(val) => {
                    fmt.field("DpipeTableCountersEnabled", &val)
                }
                Devlink::DpipeEntries(val) => fmt.field("DpipeEntries", &val),
                Devlink::DpipeEntry(val) => fmt.field("DpipeEntry", &val),
                Devlink::DpipeEntryIndex(val) => fmt.field("DpipeEntryIndex", &val),
                Devlink::DpipeEntryMatchValues(val) => fmt.field("DpipeEntryMatchValues", &val),
                Devlink::DpipeEntryActionValues(val) => fmt.field("DpipeEntryActionValues", &val),
                Devlink::DpipeEntryCounter(val) => fmt.field("DpipeEntryCounter", &val),
                Devlink::DpipeMatch(val) => fmt.field("DpipeMatch", &val),
                Devlink::DpipeMatchValue(val) => fmt.field("DpipeMatchValue", &val),
                Devlink::DpipeMatchType(val) => fmt.field(
                    "DpipeMatchType",
                    &FormatEnum(val.into(), DpipeMatchType::from_value),
                ),
                Devlink::DpipeAction(val) => fmt.field("DpipeAction", &val),
                Devlink::DpipeActionValue(val) => fmt.field("DpipeActionValue", &val),
                Devlink::DpipeActionType(val) => fmt.field(
                    "DpipeActionType",
                    &FormatEnum(val.into(), DpipeActionType::from_value),
                ),
                Devlink::DpipeValue(val) => fmt.field("DpipeValue", &val),
                Devlink::DpipeValueMask(val) => fmt.field("DpipeValueMask", &val),
                Devlink::DpipeValueMapping(val) => fmt.field("DpipeValueMapping", &val),
                Devlink::DpipeHeaders(val) => fmt.field("DpipeHeaders", &val),
                Devlink::DpipeHeader(val) => fmt.field("DpipeHeader", &val),
                Devlink::DpipeHeaderName(val) => fmt.field("DpipeHeaderName", &val),
                Devlink::DpipeHeaderId(val) => fmt.field(
                    "DpipeHeaderId",
                    &FormatEnum(val.into(), DpipeHeaderId::from_value),
                ),
                Devlink::DpipeHeaderFields(val) => fmt.field("DpipeHeaderFields", &val),
                Devlink::DpipeHeaderGlobal(val) => fmt.field("DpipeHeaderGlobal", &val),
                Devlink::DpipeHeaderIndex(val) => fmt.field("DpipeHeaderIndex", &val),
                Devlink::DpipeField(val) => fmt.field("DpipeField", &val),
                Devlink::DpipeFieldName(val) => fmt.field("DpipeFieldName", &val),
                Devlink::DpipeFieldId(val) => fmt.field("DpipeFieldId", &val),
                Devlink::DpipeFieldBitwidth(val) => fmt.field("DpipeFieldBitwidth", &val),
                Devlink::DpipeFieldMappingType(val) => fmt.field(
                    "DpipeFieldMappingType",
                    &FormatEnum(val.into(), DpipeFieldMappingType::from_value),
                ),
                Devlink::Pad(val) => fmt.field("Pad", &val),
                Devlink::EswitchEncapMode(val) => fmt.field(
                    "EswitchEncapMode",
                    &FormatEnum(val.into(), EswitchEncapMode::from_value),
                ),
                Devlink::ResourceList(val) => fmt.field("ResourceList", &val),
                Devlink::Resource(val) => fmt.field("Resource", &val),
                Devlink::ResourceName(val) => fmt.field("ResourceName", &val),
                Devlink::ResourceId(val) => fmt.field("ResourceId", &val),
                Devlink::ResourceSize(val) => fmt.field("ResourceSize", &val),
                Devlink::ResourceSizeNew(val) => fmt.field("ResourceSizeNew", &val),
                Devlink::ResourceSizeValid(val) => fmt.field("ResourceSizeValid", &val),
                Devlink::ResourceSizeMin(val) => fmt.field("ResourceSizeMin", &val),
                Devlink::ResourceSizeMax(val) => fmt.field("ResourceSizeMax", &val),
                Devlink::ResourceSizeGran(val) => fmt.field("ResourceSizeGran", &val),
                Devlink::ResourceUnit(val) => fmt.field(
                    "ResourceUnit",
                    &FormatEnum(val.into(), ResourceUnit::from_value),
                ),
                Devlink::ResourceOcc(val) => fmt.field("ResourceOcc", &val),
                Devlink::DpipeTableResourceId(val) => fmt.field("DpipeTableResourceId", &val),
                Devlink::DpipeTableResourceUnits(val) => fmt.field("DpipeTableResourceUnits", &val),
                Devlink::PortFlavour(val) => fmt.field(
                    "PortFlavour",
                    &FormatEnum(val.into(), PortFlavour::from_value),
                ),
                Devlink::PortNumber(val) => fmt.field("PortNumber", &val),
                Devlink::PortSplitSubportNumber(val) => fmt.field("PortSplitSubportNumber", &val),
                Devlink::Param(val) => fmt.field("Param", &val),
                Devlink::ParamName(val) => fmt.field("ParamName", &val),
                Devlink::ParamGeneric(val) => fmt.field("ParamGeneric", &val),
                Devlink::ParamType(val) => fmt.field(
                    "ParamType",
                    &FormatEnum(val.into(), VarAttrType::from_value),
                ),
                Devlink::ParamValueCmode(val) => fmt.field(
                    "ParamValueCmode",
                    &FormatEnum(val.into(), ParamCmode::from_value),
                ),
                Devlink::RegionName(val) => fmt.field("RegionName", &val),
                Devlink::RegionSize(val) => fmt.field("RegionSize", &val),
                Devlink::RegionSnapshots(val) => fmt.field("RegionSnapshots", &val),
                Devlink::RegionSnapshot(val) => fmt.field("RegionSnapshot", &val),
                Devlink::RegionSnapshotId(val) => fmt.field("RegionSnapshotId", &val),
                Devlink::RegionChunks(val) => fmt.field("RegionChunks", &val),
                Devlink::RegionChunk(val) => fmt.field("RegionChunk", &val),
                Devlink::RegionChunkData(val) => fmt.field("RegionChunkData", &val),
                Devlink::RegionChunkAddr(val) => fmt.field("RegionChunkAddr", &val),
                Devlink::RegionChunkLen(val) => fmt.field("RegionChunkLen", &val),
                Devlink::InfoDriverName(val) => fmt.field("InfoDriverName", &val),
                Devlink::InfoSerialNumber(val) => fmt.field("InfoSerialNumber", &val),
                Devlink::InfoVersionFixed(val) => fmt.field("InfoVersionFixed", &val),
                Devlink::InfoVersionRunning(val) => fmt.field("InfoVersionRunning", &val),
                Devlink::InfoVersionStored(val) => fmt.field("InfoVersionStored", &val),
                Devlink::InfoVersionName(val) => fmt.field("InfoVersionName", &val),
                Devlink::InfoVersionValue(val) => fmt.field("InfoVersionValue", &val),
                Devlink::SbPoolCellSize(val) => fmt.field("SbPoolCellSize", &val),
                Devlink::Fmsg(val) => fmt.field("Fmsg", &val),
                Devlink::FmsgObjNestStart(val) => fmt.field("FmsgObjNestStart", &val),
                Devlink::FmsgPairNestStart(val) => fmt.field("FmsgPairNestStart", &val),
                Devlink::FmsgArrNestStart(val) => fmt.field("FmsgArrNestStart", &val),
                Devlink::FmsgNestEnd(val) => fmt.field("FmsgNestEnd", &val),
                Devlink::FmsgObjName(val) => fmt.field("FmsgObjName", &val),
                Devlink::FmsgObjValueType(val) => fmt.field(
                    "FmsgObjValueType",
                    &FormatEnum(val.into(), VarAttrType::from_value),
                ),
                Devlink::HealthReporter(val) => fmt.field("HealthReporter", &val),
                Devlink::HealthReporterName(val) => fmt.field("HealthReporterName", &val),
                Devlink::HealthReporterState(val) => fmt.field("HealthReporterState", &val),
                Devlink::HealthReporterErrCount(val) => fmt.field("HealthReporterErrCount", &val),
                Devlink::HealthReporterRecoverCount(val) => {
                    fmt.field("HealthReporterRecoverCount", &val)
                }
                Devlink::HealthReporterDumpTs(val) => fmt.field("HealthReporterDumpTs", &val),
                Devlink::HealthReporterGracefulPeriod(val) => {
                    fmt.field("HealthReporterGracefulPeriod", &val)
                }
                Devlink::HealthReporterAutoRecover(val) => {
                    fmt.field("HealthReporterAutoRecover", &val)
                }
                Devlink::FlashUpdateFileName(val) => fmt.field("FlashUpdateFileName", &val),
                Devlink::FlashUpdateComponent(val) => fmt.field("FlashUpdateComponent", &val),
                Devlink::FlashUpdateStatusMsg(val) => fmt.field("FlashUpdateStatusMsg", &val),
                Devlink::FlashUpdateStatusDone(val) => fmt.field("FlashUpdateStatusDone", &val),
                Devlink::FlashUpdateStatusTotal(val) => fmt.field("FlashUpdateStatusTotal", &val),
                Devlink::PortPciPfNumber(val) => fmt.field("PortPciPfNumber", &val),
                Devlink::PortPciVfNumber(val) => fmt.field("PortPciVfNumber", &val),
                Devlink::Stats(val) => fmt.field("Stats", &val),
                Devlink::TrapName(val) => fmt.field("TrapName", &val),
                Devlink::TrapAction(val) => fmt.field(
                    "TrapAction",
                    &FormatEnum(val.into(), TrapAction::from_value),
                ),
                Devlink::TrapType(val) => {
                    fmt.field("TrapType", &FormatEnum(val.into(), TrapType::from_value))
                }
                Devlink::TrapGeneric(val) => fmt.field("TrapGeneric", &val),
                Devlink::TrapMetadata(val) => fmt.field("TrapMetadata", &val),
                Devlink::TrapGroupName(val) => fmt.field("TrapGroupName", &val),
                Devlink::ReloadFailed(val) => fmt.field("ReloadFailed", &val),
                Devlink::HealthReporterDumpTsNs(val) => fmt.field("HealthReporterDumpTsNs", &val),
                Devlink::NetnsFd(val) => fmt.field("NetnsFd", &val),
                Devlink::NetnsPid(val) => fmt.field("NetnsPid", &val),
                Devlink::NetnsId(val) => fmt.field("NetnsId", &val),
                Devlink::HealthReporterAutoDump(val) => fmt.field("HealthReporterAutoDump", &val),
                Devlink::TrapPolicerId(val) => fmt.field("TrapPolicerId", &val),
                Devlink::TrapPolicerRate(val) => fmt.field("TrapPolicerRate", &val),
                Devlink::TrapPolicerBurst(val) => fmt.field("TrapPolicerBurst", &val),
                Devlink::PortFunction(val) => fmt.field("PortFunction", &val),
                Devlink::InfoBoardSerialNumber(val) => fmt.field("InfoBoardSerialNumber", &val),
                Devlink::PortLanes(val) => fmt.field("PortLanes", &val),
                Devlink::PortSplittable(val) => fmt.field("PortSplittable", &val),
                Devlink::PortExternal(val) => fmt.field("PortExternal", &val),
                Devlink::PortControllerNumber(val) => fmt.field("PortControllerNumber", &val),
                Devlink::FlashUpdateStatusTimeout(val) => {
                    fmt.field("FlashUpdateStatusTimeout", &val)
                }
                Devlink::FlashUpdateOverwriteMask(val) => fmt.field(
                    "FlashUpdateOverwriteMask",
                    &FormatFlags(val.value().into(), |val| {
                        FlashOverwrite::from_value(val.trailing_zeros().into())
                    }),
                ),
                Devlink::ReloadAction(val) => fmt.field(
                    "ReloadAction",
                    &FormatEnum(val.into(), ReloadAction::from_value),
                ),
                Devlink::ReloadActionsPerformed(val) => fmt.field(
                    "ReloadActionsPerformed",
                    &FormatFlags(val.value().into(), |val| {
                        ReloadAction::from_value(val.trailing_zeros().into())
                    }),
                ),
                Devlink::ReloadLimits(val) => fmt.field(
                    "ReloadLimits",
                    &FormatFlags(val.value().into(), |val| {
                        ReloadAction::from_value(val.trailing_zeros().into())
                    }),
                ),
                Devlink::DevStats(val) => fmt.field("DevStats", &val),
                Devlink::ReloadStats(val) => fmt.field("ReloadStats", &val),
                Devlink::ReloadStatsEntry(val) => fmt.field("ReloadStatsEntry", &val),
                Devlink::ReloadStatsLimit(val) => fmt.field("ReloadStatsLimit", &val),
                Devlink::ReloadStatsValue(val) => fmt.field("ReloadStatsValue", &val),
                Devlink::RemoteReloadStats(val) => fmt.field("RemoteReloadStats", &val),
                Devlink::ReloadActionInfo(val) => fmt.field("ReloadActionInfo", &val),
                Devlink::ReloadActionStats(val) => fmt.field("ReloadActionStats", &val),
                Devlink::PortPciSfNumber(val) => fmt.field("PortPciSfNumber", &val),
                Devlink::RateType(val) => {
                    fmt.field("RateType", &FormatEnum(val.into(), RateType::from_value))
                }
                Devlink::RateTxShare(val) => fmt.field("RateTxShare", &val),
                Devlink::RateTxMax(val) => fmt.field("RateTxMax", &val),
                Devlink::RateNodeName(val) => fmt.field("RateNodeName", &val),
                Devlink::RateParentNodeName(val) => fmt.field("RateParentNodeName", &val),
                Devlink::RegionMaxSnapshots(val) => fmt.field("RegionMaxSnapshots", &val),
                Devlink::LinecardIndex(val) => fmt.field("LinecardIndex", &val),
                Devlink::LinecardState(val) => fmt.field("LinecardState", &val),
                Devlink::LinecardType(val) => fmt.field("LinecardType", &val),
                Devlink::LinecardSupportedTypes(val) => fmt.field("LinecardSupportedTypes", &val),
                Devlink::Selftests(val) => fmt.field("Selftests", &val),
                Devlink::RateTxPriority(val) => fmt.field("RateTxPriority", &val),
                Devlink::RateTxWeight(val) => fmt.field("RateTxWeight", &val),
                Devlink::RegionDirect(val) => fmt.field("RegionDirect", &val),
                Devlink::RateTcBws(val) => fmt.field("RateTcBws", &val),
                Devlink::HealthReporterBurstPeriod(val) => {
                    fmt.field("HealthReporterBurstPeriod", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableDevlink<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("Devlink", offset));
            return (stack, missing_type.and_then(|t| Devlink::attr_from_type(t)));
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                Devlink::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                Devlink::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                Devlink::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                Devlink::PortType(val) => {
                    if last_off == offset {
                        stack.push(("PortType", last_off));
                        break;
                    }
                }
                Devlink::PortDesiredType(val) => {
                    if last_off == offset {
                        stack.push(("PortDesiredType", last_off));
                        break;
                    }
                }
                Devlink::PortNetdevIfindex(val) => {
                    if last_off == offset {
                        stack.push(("PortNetdevIfindex", last_off));
                        break;
                    }
                }
                Devlink::PortNetdevName(val) => {
                    if last_off == offset {
                        stack.push(("PortNetdevName", last_off));
                        break;
                    }
                }
                Devlink::PortIbdevName(val) => {
                    if last_off == offset {
                        stack.push(("PortIbdevName", last_off));
                        break;
                    }
                }
                Devlink::PortSplitCount(val) => {
                    if last_off == offset {
                        stack.push(("PortSplitCount", last_off));
                        break;
                    }
                }
                Devlink::PortSplitGroup(val) => {
                    if last_off == offset {
                        stack.push(("PortSplitGroup", last_off));
                        break;
                    }
                }
                Devlink::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                Devlink::SbSize(val) => {
                    if last_off == offset {
                        stack.push(("SbSize", last_off));
                        break;
                    }
                }
                Devlink::SbIngressPoolCount(val) => {
                    if last_off == offset {
                        stack.push(("SbIngressPoolCount", last_off));
                        break;
                    }
                }
                Devlink::SbEgressPoolCount(val) => {
                    if last_off == offset {
                        stack.push(("SbEgressPoolCount", last_off));
                        break;
                    }
                }
                Devlink::SbIngressTcCount(val) => {
                    if last_off == offset {
                        stack.push(("SbIngressTcCount", last_off));
                        break;
                    }
                }
                Devlink::SbEgressTcCount(val) => {
                    if last_off == offset {
                        stack.push(("SbEgressTcCount", last_off));
                        break;
                    }
                }
                Devlink::SbPoolIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolIndex", last_off));
                        break;
                    }
                }
                Devlink::SbPoolType(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolType", last_off));
                        break;
                    }
                }
                Devlink::SbPoolSize(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolSize", last_off));
                        break;
                    }
                }
                Devlink::SbPoolThresholdType(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolThresholdType", last_off));
                        break;
                    }
                }
                Devlink::SbThreshold(val) => {
                    if last_off == offset {
                        stack.push(("SbThreshold", last_off));
                        break;
                    }
                }
                Devlink::SbTcIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbTcIndex", last_off));
                        break;
                    }
                }
                Devlink::SbOccCur(val) => {
                    if last_off == offset {
                        stack.push(("SbOccCur", last_off));
                        break;
                    }
                }
                Devlink::SbOccMax(val) => {
                    if last_off == offset {
                        stack.push(("SbOccMax", last_off));
                        break;
                    }
                }
                Devlink::EswitchMode(val) => {
                    if last_off == offset {
                        stack.push(("EswitchMode", last_off));
                        break;
                    }
                }
                Devlink::EswitchInlineMode(val) => {
                    if last_off == offset {
                        stack.push(("EswitchInlineMode", last_off));
                        break;
                    }
                }
                Devlink::DpipeTables(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeTable(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeTableName(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableName", last_off));
                        break;
                    }
                }
                Devlink::DpipeTableSize(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableSize", last_off));
                        break;
                    }
                }
                Devlink::DpipeTableMatches(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeTableActions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeTableCountersEnabled(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableCountersEnabled", last_off));
                        break;
                    }
                }
                Devlink::DpipeEntries(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeEntry(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeEntryIndex(val) => {
                    if last_off == offset {
                        stack.push(("DpipeEntryIndex", last_off));
                        break;
                    }
                }
                Devlink::DpipeEntryMatchValues(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeEntryActionValues(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeEntryCounter(val) => {
                    if last_off == offset {
                        stack.push(("DpipeEntryCounter", last_off));
                        break;
                    }
                }
                Devlink::DpipeMatch(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeMatchValue(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeMatchType(val) => {
                    if last_off == offset {
                        stack.push(("DpipeMatchType", last_off));
                        break;
                    }
                }
                Devlink::DpipeAction(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeActionValue(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeActionType(val) => {
                    if last_off == offset {
                        stack.push(("DpipeActionType", last_off));
                        break;
                    }
                }
                Devlink::DpipeValue(val) => {
                    if last_off == offset {
                        stack.push(("DpipeValue", last_off));
                        break;
                    }
                }
                Devlink::DpipeValueMask(val) => {
                    if last_off == offset {
                        stack.push(("DpipeValueMask", last_off));
                        break;
                    }
                }
                Devlink::DpipeValueMapping(val) => {
                    if last_off == offset {
                        stack.push(("DpipeValueMapping", last_off));
                        break;
                    }
                }
                Devlink::DpipeHeaders(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeHeader(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeHeaderName(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderName", last_off));
                        break;
                    }
                }
                Devlink::DpipeHeaderId(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderId", last_off));
                        break;
                    }
                }
                Devlink::DpipeHeaderFields(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeHeaderGlobal(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderGlobal", last_off));
                        break;
                    }
                }
                Devlink::DpipeHeaderIndex(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderIndex", last_off));
                        break;
                    }
                }
                Devlink::DpipeField(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::DpipeFieldName(val) => {
                    if last_off == offset {
                        stack.push(("DpipeFieldName", last_off));
                        break;
                    }
                }
                Devlink::DpipeFieldId(val) => {
                    if last_off == offset {
                        stack.push(("DpipeFieldId", last_off));
                        break;
                    }
                }
                Devlink::DpipeFieldBitwidth(val) => {
                    if last_off == offset {
                        stack.push(("DpipeFieldBitwidth", last_off));
                        break;
                    }
                }
                Devlink::DpipeFieldMappingType(val) => {
                    if last_off == offset {
                        stack.push(("DpipeFieldMappingType", last_off));
                        break;
                    }
                }
                Devlink::Pad(val) => {
                    if last_off == offset {
                        stack.push(("Pad", last_off));
                        break;
                    }
                }
                Devlink::EswitchEncapMode(val) => {
                    if last_off == offset {
                        stack.push(("EswitchEncapMode", last_off));
                        break;
                    }
                }
                Devlink::ResourceList(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::Resource(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::ResourceName(val) => {
                    if last_off == offset {
                        stack.push(("ResourceName", last_off));
                        break;
                    }
                }
                Devlink::ResourceId(val) => {
                    if last_off == offset {
                        stack.push(("ResourceId", last_off));
                        break;
                    }
                }
                Devlink::ResourceSize(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSize", last_off));
                        break;
                    }
                }
                Devlink::ResourceSizeNew(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSizeNew", last_off));
                        break;
                    }
                }
                Devlink::ResourceSizeValid(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSizeValid", last_off));
                        break;
                    }
                }
                Devlink::ResourceSizeMin(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSizeMin", last_off));
                        break;
                    }
                }
                Devlink::ResourceSizeMax(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSizeMax", last_off));
                        break;
                    }
                }
                Devlink::ResourceSizeGran(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSizeGran", last_off));
                        break;
                    }
                }
                Devlink::ResourceUnit(val) => {
                    if last_off == offset {
                        stack.push(("ResourceUnit", last_off));
                        break;
                    }
                }
                Devlink::ResourceOcc(val) => {
                    if last_off == offset {
                        stack.push(("ResourceOcc", last_off));
                        break;
                    }
                }
                Devlink::DpipeTableResourceId(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableResourceId", last_off));
                        break;
                    }
                }
                Devlink::DpipeTableResourceUnits(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableResourceUnits", last_off));
                        break;
                    }
                }
                Devlink::PortFlavour(val) => {
                    if last_off == offset {
                        stack.push(("PortFlavour", last_off));
                        break;
                    }
                }
                Devlink::PortNumber(val) => {
                    if last_off == offset {
                        stack.push(("PortNumber", last_off));
                        break;
                    }
                }
                Devlink::PortSplitSubportNumber(val) => {
                    if last_off == offset {
                        stack.push(("PortSplitSubportNumber", last_off));
                        break;
                    }
                }
                Devlink::Param(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::ParamName(val) => {
                    if last_off == offset {
                        stack.push(("ParamName", last_off));
                        break;
                    }
                }
                Devlink::ParamGeneric(val) => {
                    if last_off == offset {
                        stack.push(("ParamGeneric", last_off));
                        break;
                    }
                }
                Devlink::ParamType(val) => {
                    if last_off == offset {
                        stack.push(("ParamType", last_off));
                        break;
                    }
                }
                Devlink::ParamValueCmode(val) => {
                    if last_off == offset {
                        stack.push(("ParamValueCmode", last_off));
                        break;
                    }
                }
                Devlink::RegionName(val) => {
                    if last_off == offset {
                        stack.push(("RegionName", last_off));
                        break;
                    }
                }
                Devlink::RegionSize(val) => {
                    if last_off == offset {
                        stack.push(("RegionSize", last_off));
                        break;
                    }
                }
                Devlink::RegionSnapshots(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::RegionSnapshot(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::RegionSnapshotId(val) => {
                    if last_off == offset {
                        stack.push(("RegionSnapshotId", last_off));
                        break;
                    }
                }
                Devlink::RegionChunks(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::RegionChunk(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::RegionChunkData(val) => {
                    if last_off == offset {
                        stack.push(("RegionChunkData", last_off));
                        break;
                    }
                }
                Devlink::RegionChunkAddr(val) => {
                    if last_off == offset {
                        stack.push(("RegionChunkAddr", last_off));
                        break;
                    }
                }
                Devlink::RegionChunkLen(val) => {
                    if last_off == offset {
                        stack.push(("RegionChunkLen", last_off));
                        break;
                    }
                }
                Devlink::InfoDriverName(val) => {
                    if last_off == offset {
                        stack.push(("InfoDriverName", last_off));
                        break;
                    }
                }
                Devlink::InfoSerialNumber(val) => {
                    if last_off == offset {
                        stack.push(("InfoSerialNumber", last_off));
                        break;
                    }
                }
                Devlink::InfoVersionFixed(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::InfoVersionRunning(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::InfoVersionStored(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::InfoVersionName(val) => {
                    if last_off == offset {
                        stack.push(("InfoVersionName", last_off));
                        break;
                    }
                }
                Devlink::InfoVersionValue(val) => {
                    if last_off == offset {
                        stack.push(("InfoVersionValue", last_off));
                        break;
                    }
                }
                Devlink::SbPoolCellSize(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolCellSize", last_off));
                        break;
                    }
                }
                Devlink::Fmsg(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::FmsgObjNestStart(val) => {
                    if last_off == offset {
                        stack.push(("FmsgObjNestStart", last_off));
                        break;
                    }
                }
                Devlink::FmsgPairNestStart(val) => {
                    if last_off == offset {
                        stack.push(("FmsgPairNestStart", last_off));
                        break;
                    }
                }
                Devlink::FmsgArrNestStart(val) => {
                    if last_off == offset {
                        stack.push(("FmsgArrNestStart", last_off));
                        break;
                    }
                }
                Devlink::FmsgNestEnd(val) => {
                    if last_off == offset {
                        stack.push(("FmsgNestEnd", last_off));
                        break;
                    }
                }
                Devlink::FmsgObjName(val) => {
                    if last_off == offset {
                        stack.push(("FmsgObjName", last_off));
                        break;
                    }
                }
                Devlink::FmsgObjValueType(val) => {
                    if last_off == offset {
                        stack.push(("FmsgObjValueType", last_off));
                        break;
                    }
                }
                Devlink::HealthReporter(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::HealthReporterName(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterName", last_off));
                        break;
                    }
                }
                Devlink::HealthReporterState(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterState", last_off));
                        break;
                    }
                }
                Devlink::HealthReporterErrCount(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterErrCount", last_off));
                        break;
                    }
                }
                Devlink::HealthReporterRecoverCount(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterRecoverCount", last_off));
                        break;
                    }
                }
                Devlink::HealthReporterDumpTs(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterDumpTs", last_off));
                        break;
                    }
                }
                Devlink::HealthReporterGracefulPeriod(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterGracefulPeriod", last_off));
                        break;
                    }
                }
                Devlink::HealthReporterAutoRecover(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterAutoRecover", last_off));
                        break;
                    }
                }
                Devlink::FlashUpdateFileName(val) => {
                    if last_off == offset {
                        stack.push(("FlashUpdateFileName", last_off));
                        break;
                    }
                }
                Devlink::FlashUpdateComponent(val) => {
                    if last_off == offset {
                        stack.push(("FlashUpdateComponent", last_off));
                        break;
                    }
                }
                Devlink::FlashUpdateStatusMsg(val) => {
                    if last_off == offset {
                        stack.push(("FlashUpdateStatusMsg", last_off));
                        break;
                    }
                }
                Devlink::FlashUpdateStatusDone(val) => {
                    if last_off == offset {
                        stack.push(("FlashUpdateStatusDone", last_off));
                        break;
                    }
                }
                Devlink::FlashUpdateStatusTotal(val) => {
                    if last_off == offset {
                        stack.push(("FlashUpdateStatusTotal", last_off));
                        break;
                    }
                }
                Devlink::PortPciPfNumber(val) => {
                    if last_off == offset {
                        stack.push(("PortPciPfNumber", last_off));
                        break;
                    }
                }
                Devlink::PortPciVfNumber(val) => {
                    if last_off == offset {
                        stack.push(("PortPciVfNumber", last_off));
                        break;
                    }
                }
                Devlink::Stats(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::TrapName(val) => {
                    if last_off == offset {
                        stack.push(("TrapName", last_off));
                        break;
                    }
                }
                Devlink::TrapAction(val) => {
                    if last_off == offset {
                        stack.push(("TrapAction", last_off));
                        break;
                    }
                }
                Devlink::TrapType(val) => {
                    if last_off == offset {
                        stack.push(("TrapType", last_off));
                        break;
                    }
                }
                Devlink::TrapGeneric(val) => {
                    if last_off == offset {
                        stack.push(("TrapGeneric", last_off));
                        break;
                    }
                }
                Devlink::TrapMetadata(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::TrapGroupName(val) => {
                    if last_off == offset {
                        stack.push(("TrapGroupName", last_off));
                        break;
                    }
                }
                Devlink::ReloadFailed(val) => {
                    if last_off == offset {
                        stack.push(("ReloadFailed", last_off));
                        break;
                    }
                }
                Devlink::HealthReporterDumpTsNs(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterDumpTsNs", last_off));
                        break;
                    }
                }
                Devlink::NetnsFd(val) => {
                    if last_off == offset {
                        stack.push(("NetnsFd", last_off));
                        break;
                    }
                }
                Devlink::NetnsPid(val) => {
                    if last_off == offset {
                        stack.push(("NetnsPid", last_off));
                        break;
                    }
                }
                Devlink::NetnsId(val) => {
                    if last_off == offset {
                        stack.push(("NetnsId", last_off));
                        break;
                    }
                }
                Devlink::HealthReporterAutoDump(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterAutoDump", last_off));
                        break;
                    }
                }
                Devlink::TrapPolicerId(val) => {
                    if last_off == offset {
                        stack.push(("TrapPolicerId", last_off));
                        break;
                    }
                }
                Devlink::TrapPolicerRate(val) => {
                    if last_off == offset {
                        stack.push(("TrapPolicerRate", last_off));
                        break;
                    }
                }
                Devlink::TrapPolicerBurst(val) => {
                    if last_off == offset {
                        stack.push(("TrapPolicerBurst", last_off));
                        break;
                    }
                }
                Devlink::PortFunction(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::InfoBoardSerialNumber(val) => {
                    if last_off == offset {
                        stack.push(("InfoBoardSerialNumber", last_off));
                        break;
                    }
                }
                Devlink::PortLanes(val) => {
                    if last_off == offset {
                        stack.push(("PortLanes", last_off));
                        break;
                    }
                }
                Devlink::PortSplittable(val) => {
                    if last_off == offset {
                        stack.push(("PortSplittable", last_off));
                        break;
                    }
                }
                Devlink::PortExternal(val) => {
                    if last_off == offset {
                        stack.push(("PortExternal", last_off));
                        break;
                    }
                }
                Devlink::PortControllerNumber(val) => {
                    if last_off == offset {
                        stack.push(("PortControllerNumber", last_off));
                        break;
                    }
                }
                Devlink::FlashUpdateStatusTimeout(val) => {
                    if last_off == offset {
                        stack.push(("FlashUpdateStatusTimeout", last_off));
                        break;
                    }
                }
                Devlink::FlashUpdateOverwriteMask(val) => {
                    if last_off == offset {
                        stack.push(("FlashUpdateOverwriteMask", last_off));
                        break;
                    }
                }
                Devlink::ReloadAction(val) => {
                    if last_off == offset {
                        stack.push(("ReloadAction", last_off));
                        break;
                    }
                }
                Devlink::ReloadActionsPerformed(val) => {
                    if last_off == offset {
                        stack.push(("ReloadActionsPerformed", last_off));
                        break;
                    }
                }
                Devlink::ReloadLimits(val) => {
                    if last_off == offset {
                        stack.push(("ReloadLimits", last_off));
                        break;
                    }
                }
                Devlink::DevStats(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::ReloadStats(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::ReloadStatsEntry(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::ReloadStatsLimit(val) => {
                    if last_off == offset {
                        stack.push(("ReloadStatsLimit", last_off));
                        break;
                    }
                }
                Devlink::ReloadStatsValue(val) => {
                    if last_off == offset {
                        stack.push(("ReloadStatsValue", last_off));
                        break;
                    }
                }
                Devlink::RemoteReloadStats(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::ReloadActionInfo(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::ReloadActionStats(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::PortPciSfNumber(val) => {
                    if last_off == offset {
                        stack.push(("PortPciSfNumber", last_off));
                        break;
                    }
                }
                Devlink::RateType(val) => {
                    if last_off == offset {
                        stack.push(("RateType", last_off));
                        break;
                    }
                }
                Devlink::RateTxShare(val) => {
                    if last_off == offset {
                        stack.push(("RateTxShare", last_off));
                        break;
                    }
                }
                Devlink::RateTxMax(val) => {
                    if last_off == offset {
                        stack.push(("RateTxMax", last_off));
                        break;
                    }
                }
                Devlink::RateNodeName(val) => {
                    if last_off == offset {
                        stack.push(("RateNodeName", last_off));
                        break;
                    }
                }
                Devlink::RateParentNodeName(val) => {
                    if last_off == offset {
                        stack.push(("RateParentNodeName", last_off));
                        break;
                    }
                }
                Devlink::RegionMaxSnapshots(val) => {
                    if last_off == offset {
                        stack.push(("RegionMaxSnapshots", last_off));
                        break;
                    }
                }
                Devlink::LinecardIndex(val) => {
                    if last_off == offset {
                        stack.push(("LinecardIndex", last_off));
                        break;
                    }
                }
                Devlink::LinecardState(val) => {
                    if last_off == offset {
                        stack.push(("LinecardState", last_off));
                        break;
                    }
                }
                Devlink::LinecardType(val) => {
                    if last_off == offset {
                        stack.push(("LinecardType", last_off));
                        break;
                    }
                }
                Devlink::LinecardSupportedTypes(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::Selftests(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::RateTxPriority(val) => {
                    if last_off == offset {
                        stack.push(("RateTxPriority", last_off));
                        break;
                    }
                }
                Devlink::RateTxWeight(val) => {
                    if last_off == offset {
                        stack.push(("RateTxWeight", last_off));
                        break;
                    }
                }
                Devlink::RegionDirect(val) => {
                    if last_off == offset {
                        stack.push(("RegionDirect", last_off));
                        break;
                    }
                }
                Devlink::RateTcBws(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                Devlink::HealthReporterBurstPeriod(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterBurstPeriod", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("Devlink", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDevStats<'a> {
    ReloadStats(IterableDlReloadStats<'a>),
    RemoteReloadStats(IterableDlReloadStats<'a>),
}
impl<'a> IterableDlDevStats<'a> {
    pub fn get_reload_stats(&self) -> Result<IterableDlReloadStats<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDevStats::ReloadStats(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDevStats",
            "ReloadStats",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_remote_reload_stats(&self) -> Result<IterableDlReloadStats<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDevStats::RemoteReloadStats(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDevStats",
            "RemoteReloadStats",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlDevStats<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDevStats<'a> {
        IterableDlDevStats::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDevStats<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDevStats<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDevStats<'a> {
    type Item = Result<DlDevStats<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                157u16 => DlDevStats::ReloadStats({
                    let res = Some(IterableDlReloadStats::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                161u16 => DlDevStats::RemoteReloadStats({
                    let res = Some(IterableDlReloadStats::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDevStats",
            r#type.and_then(|t| DlDevStats::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDevStats<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDevStats");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDevStats::ReloadStats(val) => fmt.field("ReloadStats", &val),
                DlDevStats::RemoteReloadStats(val) => fmt.field("RemoteReloadStats", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDevStats<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDevStats", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDevStats::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDevStats::ReloadStats(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                DlDevStats::RemoteReloadStats(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDevStats", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlReloadStats<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    ReloadActionInfo(IterableDlReloadActInfo<'a>),
}
impl<'a> IterableDlReloadStats<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_reload_action_info(
        &self,
    ) -> MultiAttrIterable<Self, DlReloadStats<'a>, IterableDlReloadActInfo<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlReloadStats::ReloadActionInfo(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlReloadStats<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlReloadStats<'a> {
        IterableDlReloadStats::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlReloadStats<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlReloadStats<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlReloadStats<'a> {
    type Item = Result<DlReloadStats<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                162u16 => DlReloadStats::ReloadActionInfo({
                    let res = Some(IterableDlReloadActInfo::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlReloadStats",
            r#type.and_then(|t| DlReloadStats::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlReloadStats<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlReloadStats");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlReloadStats::ReloadActionInfo(val) => fmt.field("ReloadActionInfo", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlReloadStats<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlReloadStats", offset));
            return (
                stack,
                missing_type.and_then(|t| DlReloadStats::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlReloadStats::ReloadActionInfo(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlReloadStats", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlReloadActInfo<'a> {
    #[doc = "Associated type: \"ReloadAction\" (enum)"]
    ReloadAction(u8),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    ReloadActionStats(IterableDlReloadActStats<'a>),
}
impl<'a> IterableDlReloadActInfo<'a> {
    #[doc = "Associated type: \"ReloadAction\" (enum)"]
    pub fn get_reload_action(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlReloadActInfo::ReloadAction(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlReloadActInfo",
            "ReloadAction",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_reload_action_stats(
        &self,
    ) -> MultiAttrIterable<Self, DlReloadActInfo<'a>, IterableDlReloadActStats<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlReloadActInfo::ReloadActionStats(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlReloadActInfo<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlReloadActInfo<'a> {
        IterableDlReloadActInfo::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlReloadActInfo<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlReloadActInfo<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlReloadActInfo<'a> {
    type Item = Result<DlReloadActInfo<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                153u16 => DlReloadActInfo::ReloadAction({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                163u16 => DlReloadActInfo::ReloadActionStats({
                    let res = Some(IterableDlReloadActStats::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlReloadActInfo",
            r#type.and_then(|t| DlReloadActInfo::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlReloadActInfo<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlReloadActInfo");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlReloadActInfo::ReloadAction(val) => fmt.field(
                    "ReloadAction",
                    &FormatEnum(val.into(), ReloadAction::from_value),
                ),
                DlReloadActInfo::ReloadActionStats(val) => fmt.field("ReloadActionStats", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlReloadActInfo<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlReloadActInfo", offset));
            return (
                stack,
                missing_type.and_then(|t| DlReloadActInfo::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlReloadActInfo::ReloadAction(val) => {
                    if last_off == offset {
                        stack.push(("ReloadAction", last_off));
                        break;
                    }
                }
                DlReloadActInfo::ReloadActionStats(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlReloadActInfo", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlReloadActStats<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    ReloadStatsEntry(IterableDlReloadStatsEntry<'a>),
}
impl<'a> IterableDlReloadActStats<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_reload_stats_entry(
        &self,
    ) -> MultiAttrIterable<Self, DlReloadActStats<'a>, IterableDlReloadStatsEntry<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlReloadActStats::ReloadStatsEntry(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlReloadActStats<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlReloadActStats<'a> {
        IterableDlReloadActStats::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlReloadActStats<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlReloadActStats<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlReloadActStats<'a> {
    type Item = Result<DlReloadActStats<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                158u16 => DlReloadActStats::ReloadStatsEntry({
                    let res = Some(IterableDlReloadStatsEntry::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlReloadActStats",
            r#type.and_then(|t| DlReloadActStats::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlReloadActStats<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlReloadActStats");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlReloadActStats::ReloadStatsEntry(val) => fmt.field("ReloadStatsEntry", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlReloadActStats<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlReloadActStats", offset));
            return (
                stack,
                missing_type.and_then(|t| DlReloadActStats::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlReloadActStats::ReloadStatsEntry(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlReloadActStats", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlReloadStatsEntry {
    ReloadStatsLimit(u8),
    ReloadStatsValue(u32),
}
impl<'a> IterableDlReloadStatsEntry<'a> {
    pub fn get_reload_stats_limit(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlReloadStatsEntry::ReloadStatsLimit(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlReloadStatsEntry",
            "ReloadStatsLimit",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reload_stats_value(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlReloadStatsEntry::ReloadStatsValue(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlReloadStatsEntry",
            "ReloadStatsValue",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlReloadStatsEntry {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlReloadStatsEntry<'a> {
        IterableDlReloadStatsEntry::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlReloadStatsEntry<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlReloadStatsEntry<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlReloadStatsEntry<'a> {
    type Item = Result<DlReloadStatsEntry, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                159u16 => DlReloadStatsEntry::ReloadStatsLimit({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                160u16 => DlReloadStatsEntry::ReloadStatsValue({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlReloadStatsEntry",
            r#type.and_then(|t| DlReloadStatsEntry::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableDlReloadStatsEntry<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlReloadStatsEntry");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlReloadStatsEntry::ReloadStatsLimit(val) => fmt.field("ReloadStatsLimit", &val),
                DlReloadStatsEntry::ReloadStatsValue(val) => fmt.field("ReloadStatsValue", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlReloadStatsEntry<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlReloadStatsEntry", offset));
            return (
                stack,
                missing_type.and_then(|t| DlReloadStatsEntry::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlReloadStatsEntry::ReloadStatsLimit(val) => {
                    if last_off == offset {
                        stack.push(("ReloadStatsLimit", last_off));
                        break;
                    }
                }
                DlReloadStatsEntry::ReloadStatsValue(val) => {
                    if last_off == offset {
                        stack.push(("ReloadStatsValue", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlReloadStatsEntry", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlInfoVersion<'a> {
    InfoVersionName(&'a CStr),
    InfoVersionValue(&'a CStr),
}
impl<'a> IterableDlInfoVersion<'a> {
    pub fn get_info_version_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlInfoVersion::InfoVersionName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlInfoVersion",
            "InfoVersionName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info_version_value(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlInfoVersion::InfoVersionValue(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlInfoVersion",
            "InfoVersionValue",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlInfoVersion<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlInfoVersion<'a> {
        IterableDlInfoVersion::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlInfoVersion<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlInfoVersion<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlInfoVersion<'a> {
    type Item = Result<DlInfoVersion<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                103u16 => DlInfoVersion::InfoVersionName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                104u16 => DlInfoVersion::InfoVersionValue({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlInfoVersion",
            r#type.and_then(|t| DlInfoVersion::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlInfoVersion<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlInfoVersion");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlInfoVersion::InfoVersionName(val) => fmt.field("InfoVersionName", &val),
                DlInfoVersion::InfoVersionValue(val) => fmt.field("InfoVersionValue", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlInfoVersion<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlInfoVersion", offset));
            return (
                stack,
                missing_type.and_then(|t| DlInfoVersion::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlInfoVersion::InfoVersionName(val) => {
                    if last_off == offset {
                        stack.push(("InfoVersionName", last_off));
                        break;
                    }
                }
                DlInfoVersion::InfoVersionValue(val) => {
                    if last_off == offset {
                        stack.push(("InfoVersionValue", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlInfoVersion", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlPortFunction<'a> {
    HwAddr(&'a [u8]),
    #[doc = "Associated type: \"PortFnState\" (enum)"]
    State(u8),
    #[doc = "Associated type: \"PortFnOpstate\" (enum)"]
    Opstate(u8),
    #[doc = "Associated type: \"PortFnAttrCap\" (1 bit per enumeration)"]
    Caps(PushBuiltinBitfield32),
}
impl<'a> IterableDlPortFunction<'a> {
    pub fn get_hw_addr(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlPortFunction::HwAddr(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlPortFunction",
            "HwAddr",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"PortFnState\" (enum)"]
    pub fn get_state(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlPortFunction::State(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlPortFunction",
            "State",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"PortFnOpstate\" (enum)"]
    pub fn get_opstate(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlPortFunction::Opstate(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlPortFunction",
            "Opstate",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"PortFnAttrCap\" (1 bit per enumeration)"]
    pub fn get_caps(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlPortFunction::Caps(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlPortFunction",
            "Caps",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlPortFunction<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlPortFunction<'a> {
        IterableDlPortFunction::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "HwAddr",
            2u16 => "State",
            3u16 => "Opstate",
            4u16 => "Caps",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlPortFunction<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlPortFunction<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlPortFunction<'a> {
    type Item = Result<DlPortFunction<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => DlPortFunction::HwAddr({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => DlPortFunction::State({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => DlPortFunction::Opstate({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => DlPortFunction::Caps({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlPortFunction",
            r#type.and_then(|t| DlPortFunction::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlPortFunction<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlPortFunction");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlPortFunction::HwAddr(val) => fmt.field("HwAddr", &val),
                DlPortFunction::State(val) => {
                    fmt.field("State", &FormatEnum(val.into(), PortFnState::from_value))
                }
                DlPortFunction::Opstate(val) => fmt.field(
                    "Opstate",
                    &FormatEnum(val.into(), PortFnOpstate::from_value),
                ),
                DlPortFunction::Caps(val) => fmt.field(
                    "Caps",
                    &FormatFlags(val.value().into(), |val| {
                        PortFnAttrCap::from_value(val.trailing_zeros().into())
                    }),
                ),
            };
        }
        fmt.finish()
    }
}
impl IterableDlPortFunction<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlPortFunction", offset));
            return (
                stack,
                missing_type.and_then(|t| DlPortFunction::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlPortFunction::HwAddr(val) => {
                    if last_off == offset {
                        stack.push(("HwAddr", last_off));
                        break;
                    }
                }
                DlPortFunction::State(val) => {
                    if last_off == offset {
                        stack.push(("State", last_off));
                        break;
                    }
                }
                DlPortFunction::Opstate(val) => {
                    if last_off == offset {
                        stack.push(("Opstate", last_off));
                        break;
                    }
                }
                DlPortFunction::Caps(val) => {
                    if last_off == offset {
                        stack.push(("Caps", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlPortFunction", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlDpipeTables<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeTable(IterableDlDpipeTable<'a>),
}
impl<'a> IterableDlDpipeTables<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_table(
        &self,
    ) -> MultiAttrIterable<Self, DlDpipeTables<'a>, IterableDlDpipeTable<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlDpipeTables::DpipeTable(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlDpipeTables<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeTables<'a> {
        IterableDlDpipeTables::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeTables<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeTables<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeTables<'a> {
    type Item = Result<DlDpipeTables<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                28u16 => DlDpipeTables::DpipeTable({
                    let res = Some(IterableDlDpipeTable::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeTables",
            r#type.and_then(|t| DlDpipeTables::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeTables<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeTables");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeTables::DpipeTable(val) => fmt.field("DpipeTable", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeTables<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeTables", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeTables::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeTables::DpipeTable(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeTables", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeTable<'a> {
    DpipeTableName(&'a CStr),
    DpipeTableSize(u64),
    DpipeTableMatches(IterableDlDpipeTableMatches<'a>),
    DpipeTableActions(IterableDlDpipeTableActions<'a>),
    DpipeTableCountersEnabled(u8),
    DpipeTableResourceId(u64),
    DpipeTableResourceUnits(u64),
}
impl<'a> IterableDlDpipeTable<'a> {
    pub fn get_dpipe_table_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeTable::DpipeTableName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeTable",
            "DpipeTableName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_size(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeTable::DpipeTableSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeTable",
            "DpipeTableSize",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_matches(&self) -> Result<IterableDlDpipeTableMatches<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeTable::DpipeTableMatches(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeTable",
            "DpipeTableMatches",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_actions(&self) -> Result<IterableDlDpipeTableActions<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeTable::DpipeTableActions(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeTable",
            "DpipeTableActions",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_counters_enabled(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeTable::DpipeTableCountersEnabled(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeTable",
            "DpipeTableCountersEnabled",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_resource_id(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeTable::DpipeTableResourceId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeTable",
            "DpipeTableResourceId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_resource_units(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeTable::DpipeTableResourceUnits(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeTable",
            "DpipeTableResourceUnits",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlDpipeTable<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeTable<'a> {
        IterableDlDpipeTable::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeTable<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeTable<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeTable<'a> {
    type Item = Result<DlDpipeTable<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                29u16 => DlDpipeTable::DpipeTableName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                30u16 => DlDpipeTable::DpipeTableSize({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                31u16 => DlDpipeTable::DpipeTableMatches({
                    let res = Some(IterableDlDpipeTableMatches::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                32u16 => DlDpipeTable::DpipeTableActions({
                    let res = Some(IterableDlDpipeTableActions::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                33u16 => DlDpipeTable::DpipeTableCountersEnabled({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                75u16 => DlDpipeTable::DpipeTableResourceId({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                76u16 => DlDpipeTable::DpipeTableResourceUnits({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeTable",
            r#type.and_then(|t| DlDpipeTable::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeTable<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeTable");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeTable::DpipeTableName(val) => fmt.field("DpipeTableName", &val),
                DlDpipeTable::DpipeTableSize(val) => fmt.field("DpipeTableSize", &val),
                DlDpipeTable::DpipeTableMatches(val) => fmt.field("DpipeTableMatches", &val),
                DlDpipeTable::DpipeTableActions(val) => fmt.field("DpipeTableActions", &val),
                DlDpipeTable::DpipeTableCountersEnabled(val) => {
                    fmt.field("DpipeTableCountersEnabled", &val)
                }
                DlDpipeTable::DpipeTableResourceId(val) => fmt.field("DpipeTableResourceId", &val),
                DlDpipeTable::DpipeTableResourceUnits(val) => {
                    fmt.field("DpipeTableResourceUnits", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeTable<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeTable", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeTable::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeTable::DpipeTableName(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableName", last_off));
                        break;
                    }
                }
                DlDpipeTable::DpipeTableSize(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableSize", last_off));
                        break;
                    }
                }
                DlDpipeTable::DpipeTableMatches(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                DlDpipeTable::DpipeTableActions(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                DlDpipeTable::DpipeTableCountersEnabled(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableCountersEnabled", last_off));
                        break;
                    }
                }
                DlDpipeTable::DpipeTableResourceId(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableResourceId", last_off));
                        break;
                    }
                }
                DlDpipeTable::DpipeTableResourceUnits(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableResourceUnits", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeTable", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeTableMatches<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeMatch(IterableDlDpipeMatch<'a>),
}
impl<'a> IterableDlDpipeTableMatches<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_match(
        &self,
    ) -> MultiAttrIterable<Self, DlDpipeTableMatches<'a>, IterableDlDpipeMatch<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlDpipeTableMatches::DpipeMatch(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlDpipeTableMatches<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeTableMatches<'a> {
        IterableDlDpipeTableMatches::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeTableMatches<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeTableMatches<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeTableMatches<'a> {
    type Item = Result<DlDpipeTableMatches<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                40u16 => DlDpipeTableMatches::DpipeMatch({
                    let res = Some(IterableDlDpipeMatch::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeTableMatches",
            r#type.and_then(|t| DlDpipeTableMatches::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeTableMatches<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeTableMatches");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeTableMatches::DpipeMatch(val) => fmt.field("DpipeMatch", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeTableMatches<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeTableMatches", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeTableMatches::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeTableMatches::DpipeMatch(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeTableMatches", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeTableActions<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeAction(IterableDlDpipeAction<'a>),
}
impl<'a> IterableDlDpipeTableActions<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_action(
        &self,
    ) -> MultiAttrIterable<Self, DlDpipeTableActions<'a>, IterableDlDpipeAction<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlDpipeTableActions::DpipeAction(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlDpipeTableActions<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeTableActions<'a> {
        IterableDlDpipeTableActions::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeTableActions<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeTableActions<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeTableActions<'a> {
    type Item = Result<DlDpipeTableActions<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                43u16 => DlDpipeTableActions::DpipeAction({
                    let res = Some(IterableDlDpipeAction::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeTableActions",
            r#type.and_then(|t| DlDpipeTableActions::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeTableActions<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeTableActions");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeTableActions::DpipeAction(val) => fmt.field("DpipeAction", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeTableActions<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeTableActions", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeTableActions::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeTableActions::DpipeAction(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeTableActions", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeEntries<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeEntry(IterableDlDpipeEntry<'a>),
}
impl<'a> IterableDlDpipeEntries<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_entry(
        &self,
    ) -> MultiAttrIterable<Self, DlDpipeEntries<'a>, IterableDlDpipeEntry<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlDpipeEntries::DpipeEntry(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlDpipeEntries<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeEntries<'a> {
        IterableDlDpipeEntries::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeEntries<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeEntries<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeEntries<'a> {
    type Item = Result<DlDpipeEntries<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                35u16 => DlDpipeEntries::DpipeEntry({
                    let res = Some(IterableDlDpipeEntry::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeEntries",
            r#type.and_then(|t| DlDpipeEntries::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeEntries<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeEntries");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeEntries::DpipeEntry(val) => fmt.field("DpipeEntry", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeEntries<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeEntries", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeEntries::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeEntries::DpipeEntry(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeEntries", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeEntry<'a> {
    DpipeEntryIndex(u64),
    DpipeEntryMatchValues(IterableDlDpipeEntryMatchValues<'a>),
    DpipeEntryActionValues(IterableDlDpipeEntryActionValues<'a>),
    DpipeEntryCounter(u64),
}
impl<'a> IterableDlDpipeEntry<'a> {
    pub fn get_dpipe_entry_index(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeEntry::DpipeEntryIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeEntry",
            "DpipeEntryIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_entry_match_values(
        &self,
    ) -> Result<IterableDlDpipeEntryMatchValues<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeEntry::DpipeEntryMatchValues(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeEntry",
            "DpipeEntryMatchValues",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_entry_action_values(
        &self,
    ) -> Result<IterableDlDpipeEntryActionValues<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeEntry::DpipeEntryActionValues(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeEntry",
            "DpipeEntryActionValues",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_entry_counter(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeEntry::DpipeEntryCounter(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeEntry",
            "DpipeEntryCounter",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlDpipeEntry<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeEntry<'a> {
        IterableDlDpipeEntry::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeEntry<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeEntry<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeEntry<'a> {
    type Item = Result<DlDpipeEntry<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                36u16 => DlDpipeEntry::DpipeEntryIndex({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                37u16 => DlDpipeEntry::DpipeEntryMatchValues({
                    let res = Some(IterableDlDpipeEntryMatchValues::with_loc(
                        next,
                        self.orig_loc,
                    ));
                    let Some(val) = res else { break };
                    val
                }),
                38u16 => DlDpipeEntry::DpipeEntryActionValues({
                    let res = Some(IterableDlDpipeEntryActionValues::with_loc(
                        next,
                        self.orig_loc,
                    ));
                    let Some(val) = res else { break };
                    val
                }),
                39u16 => DlDpipeEntry::DpipeEntryCounter({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeEntry",
            r#type.and_then(|t| DlDpipeEntry::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeEntry<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeEntry");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeEntry::DpipeEntryIndex(val) => fmt.field("DpipeEntryIndex", &val),
                DlDpipeEntry::DpipeEntryMatchValues(val) => {
                    fmt.field("DpipeEntryMatchValues", &val)
                }
                DlDpipeEntry::DpipeEntryActionValues(val) => {
                    fmt.field("DpipeEntryActionValues", &val)
                }
                DlDpipeEntry::DpipeEntryCounter(val) => fmt.field("DpipeEntryCounter", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeEntry<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeEntry", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeEntry::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeEntry::DpipeEntryIndex(val) => {
                    if last_off == offset {
                        stack.push(("DpipeEntryIndex", last_off));
                        break;
                    }
                }
                DlDpipeEntry::DpipeEntryMatchValues(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                DlDpipeEntry::DpipeEntryActionValues(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                DlDpipeEntry::DpipeEntryCounter(val) => {
                    if last_off == offset {
                        stack.push(("DpipeEntryCounter", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeEntry", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeEntryMatchValues<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeMatchValue(IterableDlDpipeMatchValue<'a>),
}
impl<'a> IterableDlDpipeEntryMatchValues<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_match_value(
        &self,
    ) -> MultiAttrIterable<Self, DlDpipeEntryMatchValues<'a>, IterableDlDpipeMatchValue<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlDpipeEntryMatchValues::DpipeMatchValue(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlDpipeEntryMatchValues<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeEntryMatchValues<'a> {
        IterableDlDpipeEntryMatchValues::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeEntryMatchValues<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeEntryMatchValues<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeEntryMatchValues<'a> {
    type Item = Result<DlDpipeEntryMatchValues<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                41u16 => DlDpipeEntryMatchValues::DpipeMatchValue({
                    let res = Some(IterableDlDpipeMatchValue::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeEntryMatchValues",
            r#type.and_then(|t| DlDpipeEntryMatchValues::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeEntryMatchValues<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeEntryMatchValues");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeEntryMatchValues::DpipeMatchValue(val) => fmt.field("DpipeMatchValue", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeEntryMatchValues<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeEntryMatchValues", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeEntryMatchValues::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeEntryMatchValues::DpipeMatchValue(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeEntryMatchValues", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeEntryActionValues<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeActionValue(IterableDlDpipeActionValue<'a>),
}
impl<'a> IterableDlDpipeEntryActionValues<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_action_value(
        &self,
    ) -> MultiAttrIterable<Self, DlDpipeEntryActionValues<'a>, IterableDlDpipeActionValue<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlDpipeEntryActionValues::DpipeActionValue(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlDpipeEntryActionValues<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeEntryActionValues<'a> {
        IterableDlDpipeEntryActionValues::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeEntryActionValues<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeEntryActionValues<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeEntryActionValues<'a> {
    type Item = Result<DlDpipeEntryActionValues<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                44u16 => DlDpipeEntryActionValues::DpipeActionValue({
                    let res = Some(IterableDlDpipeActionValue::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeEntryActionValues",
            r#type.and_then(|t| DlDpipeEntryActionValues::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeEntryActionValues<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeEntryActionValues");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeEntryActionValues::DpipeActionValue(val) => {
                    fmt.field("DpipeActionValue", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeEntryActionValues<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeEntryActionValues", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeEntryActionValues::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeEntryActionValues::DpipeActionValue(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeEntryActionValues", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeMatch {
    #[doc = "Associated type: \"DpipeMatchType\" (enum)"]
    DpipeMatchType(u32),
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    DpipeHeaderId(u32),
    DpipeHeaderGlobal(u8),
    DpipeHeaderIndex(u32),
    DpipeFieldId(u32),
}
impl<'a> IterableDlDpipeMatch<'a> {
    #[doc = "Associated type: \"DpipeMatchType\" (enum)"]
    pub fn get_dpipe_match_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeMatch::DpipeMatchType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeMatch",
            "DpipeMatchType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    pub fn get_dpipe_header_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeMatch::DpipeHeaderId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeMatch",
            "DpipeHeaderId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_header_global(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeMatch::DpipeHeaderGlobal(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeMatch",
            "DpipeHeaderGlobal",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_header_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeMatch::DpipeHeaderIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeMatch",
            "DpipeHeaderIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_field_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeMatch::DpipeFieldId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeMatch",
            "DpipeFieldId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlDpipeMatch {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeMatch<'a> {
        IterableDlDpipeMatch::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeMatch<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeMatch<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeMatch<'a> {
    type Item = Result<DlDpipeMatch, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                42u16 => DlDpipeMatch::DpipeMatchType({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                52u16 => DlDpipeMatch::DpipeHeaderId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                54u16 => DlDpipeMatch::DpipeHeaderGlobal({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                55u16 => DlDpipeMatch::DpipeHeaderIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                58u16 => DlDpipeMatch::DpipeFieldId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeMatch",
            r#type.and_then(|t| DlDpipeMatch::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableDlDpipeMatch<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeMatch");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeMatch::DpipeMatchType(val) => fmt.field(
                    "DpipeMatchType",
                    &FormatEnum(val.into(), DpipeMatchType::from_value),
                ),
                DlDpipeMatch::DpipeHeaderId(val) => fmt.field(
                    "DpipeHeaderId",
                    &FormatEnum(val.into(), DpipeHeaderId::from_value),
                ),
                DlDpipeMatch::DpipeHeaderGlobal(val) => fmt.field("DpipeHeaderGlobal", &val),
                DlDpipeMatch::DpipeHeaderIndex(val) => fmt.field("DpipeHeaderIndex", &val),
                DlDpipeMatch::DpipeFieldId(val) => fmt.field("DpipeFieldId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeMatch<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeMatch", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeMatch::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeMatch::DpipeMatchType(val) => {
                    if last_off == offset {
                        stack.push(("DpipeMatchType", last_off));
                        break;
                    }
                }
                DlDpipeMatch::DpipeHeaderId(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderId", last_off));
                        break;
                    }
                }
                DlDpipeMatch::DpipeHeaderGlobal(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderGlobal", last_off));
                        break;
                    }
                }
                DlDpipeMatch::DpipeHeaderIndex(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderIndex", last_off));
                        break;
                    }
                }
                DlDpipeMatch::DpipeFieldId(val) => {
                    if last_off == offset {
                        stack.push(("DpipeFieldId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeMatch", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlDpipeMatchValue<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeMatch(IterableDlDpipeMatch<'a>),
    DpipeValue(&'a [u8]),
    DpipeValueMask(&'a [u8]),
    DpipeValueMapping(u32),
}
impl<'a> IterableDlDpipeMatchValue<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_match(
        &self,
    ) -> MultiAttrIterable<Self, DlDpipeMatchValue<'a>, IterableDlDpipeMatch<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlDpipeMatchValue::DpipeMatch(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_dpipe_value(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeMatchValue::DpipeValue(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeMatchValue",
            "DpipeValue",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_value_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeMatchValue::DpipeValueMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeMatchValue",
            "DpipeValueMask",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_value_mapping(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeMatchValue::DpipeValueMapping(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeMatchValue",
            "DpipeValueMapping",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlDpipeMatchValue<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeMatchValue<'a> {
        IterableDlDpipeMatchValue::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeMatchValue<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeMatchValue<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeMatchValue<'a> {
    type Item = Result<DlDpipeMatchValue<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                40u16 => DlDpipeMatchValue::DpipeMatch({
                    let res = Some(IterableDlDpipeMatch::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                46u16 => DlDpipeMatchValue::DpipeValue({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                47u16 => DlDpipeMatchValue::DpipeValueMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                48u16 => DlDpipeMatchValue::DpipeValueMapping({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeMatchValue",
            r#type.and_then(|t| DlDpipeMatchValue::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeMatchValue<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeMatchValue");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeMatchValue::DpipeMatch(val) => fmt.field("DpipeMatch", &val),
                DlDpipeMatchValue::DpipeValue(val) => fmt.field("DpipeValue", &val),
                DlDpipeMatchValue::DpipeValueMask(val) => fmt.field("DpipeValueMask", &val),
                DlDpipeMatchValue::DpipeValueMapping(val) => fmt.field("DpipeValueMapping", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeMatchValue<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeMatchValue", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeMatchValue::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeMatchValue::DpipeMatch(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                DlDpipeMatchValue::DpipeValue(val) => {
                    if last_off == offset {
                        stack.push(("DpipeValue", last_off));
                        break;
                    }
                }
                DlDpipeMatchValue::DpipeValueMask(val) => {
                    if last_off == offset {
                        stack.push(("DpipeValueMask", last_off));
                        break;
                    }
                }
                DlDpipeMatchValue::DpipeValueMapping(val) => {
                    if last_off == offset {
                        stack.push(("DpipeValueMapping", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeMatchValue", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeAction {
    #[doc = "Associated type: \"DpipeActionType\" (enum)"]
    DpipeActionType(u32),
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    DpipeHeaderId(u32),
    DpipeHeaderGlobal(u8),
    DpipeHeaderIndex(u32),
    DpipeFieldId(u32),
}
impl<'a> IterableDlDpipeAction<'a> {
    #[doc = "Associated type: \"DpipeActionType\" (enum)"]
    pub fn get_dpipe_action_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeAction::DpipeActionType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeAction",
            "DpipeActionType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    pub fn get_dpipe_header_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeAction::DpipeHeaderId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeAction",
            "DpipeHeaderId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_header_global(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeAction::DpipeHeaderGlobal(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeAction",
            "DpipeHeaderGlobal",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_header_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeAction::DpipeHeaderIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeAction",
            "DpipeHeaderIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_field_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeAction::DpipeFieldId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeAction",
            "DpipeFieldId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlDpipeAction {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeAction<'a> {
        IterableDlDpipeAction::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeAction<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeAction<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeAction<'a> {
    type Item = Result<DlDpipeAction, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                45u16 => DlDpipeAction::DpipeActionType({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                52u16 => DlDpipeAction::DpipeHeaderId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                54u16 => DlDpipeAction::DpipeHeaderGlobal({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                55u16 => DlDpipeAction::DpipeHeaderIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                58u16 => DlDpipeAction::DpipeFieldId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeAction",
            r#type.and_then(|t| DlDpipeAction::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableDlDpipeAction<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeAction");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeAction::DpipeActionType(val) => fmt.field(
                    "DpipeActionType",
                    &FormatEnum(val.into(), DpipeActionType::from_value),
                ),
                DlDpipeAction::DpipeHeaderId(val) => fmt.field(
                    "DpipeHeaderId",
                    &FormatEnum(val.into(), DpipeHeaderId::from_value),
                ),
                DlDpipeAction::DpipeHeaderGlobal(val) => fmt.field("DpipeHeaderGlobal", &val),
                DlDpipeAction::DpipeHeaderIndex(val) => fmt.field("DpipeHeaderIndex", &val),
                DlDpipeAction::DpipeFieldId(val) => fmt.field("DpipeFieldId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeAction<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeAction", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeAction::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeAction::DpipeActionType(val) => {
                    if last_off == offset {
                        stack.push(("DpipeActionType", last_off));
                        break;
                    }
                }
                DlDpipeAction::DpipeHeaderId(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderId", last_off));
                        break;
                    }
                }
                DlDpipeAction::DpipeHeaderGlobal(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderGlobal", last_off));
                        break;
                    }
                }
                DlDpipeAction::DpipeHeaderIndex(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderIndex", last_off));
                        break;
                    }
                }
                DlDpipeAction::DpipeFieldId(val) => {
                    if last_off == offset {
                        stack.push(("DpipeFieldId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeAction", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlDpipeActionValue<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeAction(IterableDlDpipeAction<'a>),
    DpipeValue(&'a [u8]),
    DpipeValueMask(&'a [u8]),
    DpipeValueMapping(u32),
}
impl<'a> IterableDlDpipeActionValue<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_action(
        &self,
    ) -> MultiAttrIterable<Self, DlDpipeActionValue<'a>, IterableDlDpipeAction<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlDpipeActionValue::DpipeAction(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_dpipe_value(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeActionValue::DpipeValue(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeActionValue",
            "DpipeValue",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_value_mask(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeActionValue::DpipeValueMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeActionValue",
            "DpipeValueMask",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_value_mapping(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeActionValue::DpipeValueMapping(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeActionValue",
            "DpipeValueMapping",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlDpipeActionValue<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeActionValue<'a> {
        IterableDlDpipeActionValue::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeActionValue<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeActionValue<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeActionValue<'a> {
    type Item = Result<DlDpipeActionValue<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                43u16 => DlDpipeActionValue::DpipeAction({
                    let res = Some(IterableDlDpipeAction::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                46u16 => DlDpipeActionValue::DpipeValue({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                47u16 => DlDpipeActionValue::DpipeValueMask({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                48u16 => DlDpipeActionValue::DpipeValueMapping({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeActionValue",
            r#type.and_then(|t| DlDpipeActionValue::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeActionValue<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeActionValue");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeActionValue::DpipeAction(val) => fmt.field("DpipeAction", &val),
                DlDpipeActionValue::DpipeValue(val) => fmt.field("DpipeValue", &val),
                DlDpipeActionValue::DpipeValueMask(val) => fmt.field("DpipeValueMask", &val),
                DlDpipeActionValue::DpipeValueMapping(val) => fmt.field("DpipeValueMapping", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeActionValue<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeActionValue", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeActionValue::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeActionValue::DpipeAction(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                DlDpipeActionValue::DpipeValue(val) => {
                    if last_off == offset {
                        stack.push(("DpipeValue", last_off));
                        break;
                    }
                }
                DlDpipeActionValue::DpipeValueMask(val) => {
                    if last_off == offset {
                        stack.push(("DpipeValueMask", last_off));
                        break;
                    }
                }
                DlDpipeActionValue::DpipeValueMapping(val) => {
                    if last_off == offset {
                        stack.push(("DpipeValueMapping", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeActionValue", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeHeaders<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeHeader(IterableDlDpipeHeader<'a>),
}
impl<'a> IterableDlDpipeHeaders<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_header(
        &self,
    ) -> MultiAttrIterable<Self, DlDpipeHeaders<'a>, IterableDlDpipeHeader<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlDpipeHeaders::DpipeHeader(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlDpipeHeaders<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeHeaders<'a> {
        IterableDlDpipeHeaders::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeHeaders<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeHeaders<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeHeaders<'a> {
    type Item = Result<DlDpipeHeaders<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                50u16 => DlDpipeHeaders::DpipeHeader({
                    let res = Some(IterableDlDpipeHeader::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeHeaders",
            r#type.and_then(|t| DlDpipeHeaders::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeHeaders<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeHeaders");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeHeaders::DpipeHeader(val) => fmt.field("DpipeHeader", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeHeaders<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeHeaders", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeHeaders::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeHeaders::DpipeHeader(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeHeaders", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeHeader<'a> {
    DpipeHeaderName(&'a CStr),
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    DpipeHeaderId(u32),
    DpipeHeaderFields(IterableDlDpipeHeaderFields<'a>),
    DpipeHeaderGlobal(u8),
}
impl<'a> IterableDlDpipeHeader<'a> {
    pub fn get_dpipe_header_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeHeader::DpipeHeaderName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeHeader",
            "DpipeHeaderName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    pub fn get_dpipe_header_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeHeader::DpipeHeaderId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeHeader",
            "DpipeHeaderId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_header_fields(&self) -> Result<IterableDlDpipeHeaderFields<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeHeader::DpipeHeaderFields(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeHeader",
            "DpipeHeaderFields",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_header_global(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeHeader::DpipeHeaderGlobal(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeHeader",
            "DpipeHeaderGlobal",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlDpipeHeader<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeHeader<'a> {
        IterableDlDpipeHeader::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeHeader<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeHeader<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeHeader<'a> {
    type Item = Result<DlDpipeHeader<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                51u16 => DlDpipeHeader::DpipeHeaderName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                52u16 => DlDpipeHeader::DpipeHeaderId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                53u16 => DlDpipeHeader::DpipeHeaderFields({
                    let res = Some(IterableDlDpipeHeaderFields::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                54u16 => DlDpipeHeader::DpipeHeaderGlobal({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeHeader",
            r#type.and_then(|t| DlDpipeHeader::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeHeader<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeHeader");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeHeader::DpipeHeaderName(val) => fmt.field("DpipeHeaderName", &val),
                DlDpipeHeader::DpipeHeaderId(val) => fmt.field(
                    "DpipeHeaderId",
                    &FormatEnum(val.into(), DpipeHeaderId::from_value),
                ),
                DlDpipeHeader::DpipeHeaderFields(val) => fmt.field("DpipeHeaderFields", &val),
                DlDpipeHeader::DpipeHeaderGlobal(val) => fmt.field("DpipeHeaderGlobal", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeHeader<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeHeader", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeHeader::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeHeader::DpipeHeaderName(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderName", last_off));
                        break;
                    }
                }
                DlDpipeHeader::DpipeHeaderId(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderId", last_off));
                        break;
                    }
                }
                DlDpipeHeader::DpipeHeaderFields(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                DlDpipeHeader::DpipeHeaderGlobal(val) => {
                    if last_off == offset {
                        stack.push(("DpipeHeaderGlobal", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeHeader", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeHeaderFields<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    DpipeField(IterableDlDpipeField<'a>),
}
impl<'a> IterableDlDpipeHeaderFields<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_dpipe_field(
        &self,
    ) -> MultiAttrIterable<Self, DlDpipeHeaderFields<'a>, IterableDlDpipeField<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlDpipeHeaderFields::DpipeField(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlDpipeHeaderFields<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeHeaderFields<'a> {
        IterableDlDpipeHeaderFields::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeHeaderFields<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeHeaderFields<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeHeaderFields<'a> {
    type Item = Result<DlDpipeHeaderFields<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                56u16 => DlDpipeHeaderFields::DpipeField({
                    let res = Some(IterableDlDpipeField::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeHeaderFields",
            r#type.and_then(|t| DlDpipeHeaderFields::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeHeaderFields<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeHeaderFields");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeHeaderFields::DpipeField(val) => fmt.field("DpipeField", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeHeaderFields<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeHeaderFields", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeHeaderFields::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeHeaderFields::DpipeField(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeHeaderFields", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlDpipeField<'a> {
    DpipeFieldName(&'a CStr),
    DpipeFieldId(u32),
    DpipeFieldBitwidth(u32),
    #[doc = "Associated type: \"DpipeFieldMappingType\" (enum)"]
    DpipeFieldMappingType(u32),
}
impl<'a> IterableDlDpipeField<'a> {
    pub fn get_dpipe_field_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeField::DpipeFieldName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeField",
            "DpipeFieldName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_field_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeField::DpipeFieldId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeField",
            "DpipeFieldId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_field_bitwidth(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeField::DpipeFieldBitwidth(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeField",
            "DpipeFieldBitwidth",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"DpipeFieldMappingType\" (enum)"]
    pub fn get_dpipe_field_mapping_type(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlDpipeField::DpipeFieldMappingType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlDpipeField",
            "DpipeFieldMappingType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlDpipeField<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlDpipeField<'a> {
        IterableDlDpipeField::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlDpipeField<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlDpipeField<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlDpipeField<'a> {
    type Item = Result<DlDpipeField<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                57u16 => DlDpipeField::DpipeFieldName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                58u16 => DlDpipeField::DpipeFieldId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                59u16 => DlDpipeField::DpipeFieldBitwidth({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                60u16 => DlDpipeField::DpipeFieldMappingType({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlDpipeField",
            r#type.and_then(|t| DlDpipeField::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlDpipeField<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlDpipeField");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlDpipeField::DpipeFieldName(val) => fmt.field("DpipeFieldName", &val),
                DlDpipeField::DpipeFieldId(val) => fmt.field("DpipeFieldId", &val),
                DlDpipeField::DpipeFieldBitwidth(val) => fmt.field("DpipeFieldBitwidth", &val),
                DlDpipeField::DpipeFieldMappingType(val) => fmt.field(
                    "DpipeFieldMappingType",
                    &FormatEnum(val.into(), DpipeFieldMappingType::from_value),
                ),
            };
        }
        fmt.finish()
    }
}
impl IterableDlDpipeField<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlDpipeField", offset));
            return (
                stack,
                missing_type.and_then(|t| DlDpipeField::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlDpipeField::DpipeFieldName(val) => {
                    if last_off == offset {
                        stack.push(("DpipeFieldName", last_off));
                        break;
                    }
                }
                DlDpipeField::DpipeFieldId(val) => {
                    if last_off == offset {
                        stack.push(("DpipeFieldId", last_off));
                        break;
                    }
                }
                DlDpipeField::DpipeFieldBitwidth(val) => {
                    if last_off == offset {
                        stack.push(("DpipeFieldBitwidth", last_off));
                        break;
                    }
                }
                DlDpipeField::DpipeFieldMappingType(val) => {
                    if last_off == offset {
                        stack.push(("DpipeFieldMappingType", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlDpipeField", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlResource<'a> {
    ResourceName(&'a CStr),
    ResourceId(u64),
    ResourceSize(u64),
    ResourceSizeNew(u64),
    ResourceSizeValid(u8),
    ResourceSizeMin(u64),
    ResourceSizeMax(u64),
    ResourceSizeGran(u64),
    #[doc = "Associated type: \"ResourceUnit\" (enum)"]
    ResourceUnit(u8),
    ResourceOcc(u64),
}
impl<'a> IterableDlResource<'a> {
    pub fn get_resource_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlResource::ResourceName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlResource",
            "ResourceName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_id(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlResource::ResourceId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlResource",
            "ResourceId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlResource::ResourceSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlResource",
            "ResourceSize",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size_new(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlResource::ResourceSizeNew(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlResource",
            "ResourceSizeNew",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size_valid(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlResource::ResourceSizeValid(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlResource",
            "ResourceSizeValid",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size_min(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlResource::ResourceSizeMin(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlResource",
            "ResourceSizeMin",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size_max(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlResource::ResourceSizeMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlResource",
            "ResourceSizeMax",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size_gran(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlResource::ResourceSizeGran(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlResource",
            "ResourceSizeGran",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"ResourceUnit\" (enum)"]
    pub fn get_resource_unit(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlResource::ResourceUnit(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlResource",
            "ResourceUnit",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_occ(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlResource::ResourceOcc(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlResource",
            "ResourceOcc",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlResource<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlResource<'a> {
        IterableDlResource::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlResource<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlResource<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlResource<'a> {
    type Item = Result<DlResource<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                65u16 => DlResource::ResourceName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                66u16 => DlResource::ResourceId({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                67u16 => DlResource::ResourceSize({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                68u16 => DlResource::ResourceSizeNew({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                69u16 => DlResource::ResourceSizeValid({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                70u16 => DlResource::ResourceSizeMin({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                71u16 => DlResource::ResourceSizeMax({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                72u16 => DlResource::ResourceSizeGran({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                73u16 => DlResource::ResourceUnit({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                74u16 => DlResource::ResourceOcc({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlResource",
            r#type.and_then(|t| DlResource::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlResource<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlResource");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlResource::ResourceName(val) => fmt.field("ResourceName", &val),
                DlResource::ResourceId(val) => fmt.field("ResourceId", &val),
                DlResource::ResourceSize(val) => fmt.field("ResourceSize", &val),
                DlResource::ResourceSizeNew(val) => fmt.field("ResourceSizeNew", &val),
                DlResource::ResourceSizeValid(val) => fmt.field("ResourceSizeValid", &val),
                DlResource::ResourceSizeMin(val) => fmt.field("ResourceSizeMin", &val),
                DlResource::ResourceSizeMax(val) => fmt.field("ResourceSizeMax", &val),
                DlResource::ResourceSizeGran(val) => fmt.field("ResourceSizeGran", &val),
                DlResource::ResourceUnit(val) => fmt.field(
                    "ResourceUnit",
                    &FormatEnum(val.into(), ResourceUnit::from_value),
                ),
                DlResource::ResourceOcc(val) => fmt.field("ResourceOcc", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlResource<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlResource", offset));
            return (
                stack,
                missing_type.and_then(|t| DlResource::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlResource::ResourceName(val) => {
                    if last_off == offset {
                        stack.push(("ResourceName", last_off));
                        break;
                    }
                }
                DlResource::ResourceId(val) => {
                    if last_off == offset {
                        stack.push(("ResourceId", last_off));
                        break;
                    }
                }
                DlResource::ResourceSize(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSize", last_off));
                        break;
                    }
                }
                DlResource::ResourceSizeNew(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSizeNew", last_off));
                        break;
                    }
                }
                DlResource::ResourceSizeValid(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSizeValid", last_off));
                        break;
                    }
                }
                DlResource::ResourceSizeMin(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSizeMin", last_off));
                        break;
                    }
                }
                DlResource::ResourceSizeMax(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSizeMax", last_off));
                        break;
                    }
                }
                DlResource::ResourceSizeGran(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSizeGran", last_off));
                        break;
                    }
                }
                DlResource::ResourceUnit(val) => {
                    if last_off == offset {
                        stack.push(("ResourceUnit", last_off));
                        break;
                    }
                }
                DlResource::ResourceOcc(val) => {
                    if last_off == offset {
                        stack.push(("ResourceOcc", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlResource", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlResourceList<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    Resource(IterableDlResource<'a>),
}
impl<'a> IterableDlResourceList<'a> {
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_resource(
        &self,
    ) -> MultiAttrIterable<Self, DlResourceList<'a>, IterableDlResource<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let DlResourceList::Resource(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl DlResourceList<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlResourceList<'a> {
        IterableDlResourceList::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlResourceList<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlResourceList<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlResourceList<'a> {
    type Item = Result<DlResourceList<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                64u16 => DlResourceList::Resource({
                    let res = Some(IterableDlResource::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlResourceList",
            r#type.and_then(|t| DlResourceList::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlResourceList<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlResourceList");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlResourceList::Resource(val) => fmt.field("Resource", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlResourceList<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlResourceList", offset));
            return (
                stack,
                missing_type.and_then(|t| DlResourceList::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlResourceList::Resource(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlResourceList", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlParam<'a> {
    ParamName(&'a CStr),
    ParamGeneric(()),
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    ParamType(u8),
}
impl<'a> IterableDlParam<'a> {
    pub fn get_param_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlParam::ParamName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlParam",
            "ParamName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_param_generic(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlParam::ParamGeneric(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlParam",
            "ParamGeneric",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    pub fn get_param_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlParam::ParamType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlParam",
            "ParamType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlParam<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlParam<'a> {
        IterableDlParam::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlParam<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlParam<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlParam<'a> {
    type Item = Result<DlParam<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                81u16 => DlParam::ParamName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                82u16 => DlParam::ParamGeneric(()),
                83u16 => DlParam::ParamType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlParam",
            r#type.and_then(|t| DlParam::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlParam<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlParam");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlParam::ParamName(val) => fmt.field("ParamName", &val),
                DlParam::ParamGeneric(val) => fmt.field("ParamGeneric", &val),
                DlParam::ParamType(val) => fmt.field(
                    "ParamType",
                    &FormatEnum(val.into(), VarAttrType::from_value),
                ),
            };
        }
        fmt.finish()
    }
}
impl IterableDlParam<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlParam", offset));
            return (stack, missing_type.and_then(|t| DlParam::attr_from_type(t)));
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlParam::ParamName(val) => {
                    if last_off == offset {
                        stack.push(("ParamName", last_off));
                        break;
                    }
                }
                DlParam::ParamGeneric(val) => {
                    if last_off == offset {
                        stack.push(("ParamGeneric", last_off));
                        break;
                    }
                }
                DlParam::ParamType(val) => {
                    if last_off == offset {
                        stack.push(("ParamType", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlParam", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlRegionSnapshots<'a> {
    RegionSnapshot(IterableDlRegionSnapshot<'a>),
}
impl<'a> IterableDlRegionSnapshots<'a> {
    pub fn get_region_snapshot(&self) -> Result<IterableDlRegionSnapshot<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlRegionSnapshots::RegionSnapshot(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlRegionSnapshots",
            "RegionSnapshot",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlRegionSnapshots<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlRegionSnapshots<'a> {
        IterableDlRegionSnapshots::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlRegionSnapshots<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlRegionSnapshots<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlRegionSnapshots<'a> {
    type Item = Result<DlRegionSnapshots<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                91u16 => DlRegionSnapshots::RegionSnapshot({
                    let res = Some(IterableDlRegionSnapshot::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlRegionSnapshots",
            r#type.and_then(|t| DlRegionSnapshots::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlRegionSnapshots<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlRegionSnapshots");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlRegionSnapshots::RegionSnapshot(val) => fmt.field("RegionSnapshot", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlRegionSnapshots<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlRegionSnapshots", offset));
            return (
                stack,
                missing_type.and_then(|t| DlRegionSnapshots::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlRegionSnapshots::RegionSnapshot(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlRegionSnapshots", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlRegionSnapshot {
    RegionSnapshotId(u32),
}
impl<'a> IterableDlRegionSnapshot<'a> {
    pub fn get_region_snapshot_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlRegionSnapshot::RegionSnapshotId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlRegionSnapshot",
            "RegionSnapshotId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlRegionSnapshot {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlRegionSnapshot<'a> {
        IterableDlRegionSnapshot::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlRegionSnapshot<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlRegionSnapshot<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlRegionSnapshot<'a> {
    type Item = Result<DlRegionSnapshot, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                92u16 => DlRegionSnapshot::RegionSnapshotId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlRegionSnapshot",
            r#type.and_then(|t| DlRegionSnapshot::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableDlRegionSnapshot<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlRegionSnapshot");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlRegionSnapshot::RegionSnapshotId(val) => fmt.field("RegionSnapshotId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlRegionSnapshot<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlRegionSnapshot", offset));
            return (
                stack,
                missing_type.and_then(|t| DlRegionSnapshot::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlRegionSnapshot::RegionSnapshotId(val) => {
                    if last_off == offset {
                        stack.push(("RegionSnapshotId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlRegionSnapshot", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlRegionChunks<'a> {
    RegionChunk(IterableDlRegionChunk<'a>),
}
impl<'a> IterableDlRegionChunks<'a> {
    pub fn get_region_chunk(&self) -> Result<IterableDlRegionChunk<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlRegionChunks::RegionChunk(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlRegionChunks",
            "RegionChunk",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlRegionChunks<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlRegionChunks<'a> {
        IterableDlRegionChunks::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlRegionChunks<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlRegionChunks<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlRegionChunks<'a> {
    type Item = Result<DlRegionChunks<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                94u16 => DlRegionChunks::RegionChunk({
                    let res = Some(IterableDlRegionChunk::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlRegionChunks",
            r#type.and_then(|t| DlRegionChunks::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlRegionChunks<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlRegionChunks");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlRegionChunks::RegionChunk(val) => fmt.field("RegionChunk", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlRegionChunks<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlRegionChunks", offset));
            return (
                stack,
                missing_type.and_then(|t| DlRegionChunks::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlRegionChunks::RegionChunk(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlRegionChunks", cur));
        }
        (stack, missing)
    }
}
#[derive(Clone)]
pub enum DlRegionChunk<'a> {
    RegionChunkData(&'a [u8]),
    RegionChunkAddr(u64),
}
impl<'a> IterableDlRegionChunk<'a> {
    pub fn get_region_chunk_data(&self) -> Result<&'a [u8], ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlRegionChunk::RegionChunkData(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlRegionChunk",
            "RegionChunkData",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_chunk_addr(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlRegionChunk::RegionChunkAddr(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlRegionChunk",
            "RegionChunkAddr",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlRegionChunk<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlRegionChunk<'a> {
        IterableDlRegionChunk::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlRegionChunk<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlRegionChunk<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlRegionChunk<'a> {
    type Item = Result<DlRegionChunk<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                95u16 => DlRegionChunk::RegionChunkData({
                    let res = Some(next);
                    let Some(val) = res else { break };
                    val
                }),
                96u16 => DlRegionChunk::RegionChunkAddr({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlRegionChunk",
            r#type.and_then(|t| DlRegionChunk::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlRegionChunk<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlRegionChunk");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlRegionChunk::RegionChunkData(val) => fmt.field("RegionChunkData", &val),
                DlRegionChunk::RegionChunkAddr(val) => fmt.field("RegionChunkAddr", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlRegionChunk<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlRegionChunk", offset));
            return (
                stack,
                missing_type.and_then(|t| DlRegionChunk::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlRegionChunk::RegionChunkData(val) => {
                    if last_off == offset {
                        stack.push(("RegionChunkData", last_off));
                        break;
                    }
                }
                DlRegionChunk::RegionChunkAddr(val) => {
                    if last_off == offset {
                        stack.push(("RegionChunkAddr", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlRegionChunk", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlFmsg<'a> {
    FmsgObjNestStart(()),
    FmsgPairNestStart(()),
    FmsgArrNestStart(()),
    FmsgNestEnd(()),
    FmsgObjName(&'a CStr),
}
impl<'a> IterableDlFmsg<'a> {
    pub fn get_fmsg_obj_nest_start(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlFmsg::FmsgObjNestStart(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlFmsg",
            "FmsgObjNestStart",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_fmsg_pair_nest_start(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlFmsg::FmsgPairNestStart(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlFmsg",
            "FmsgPairNestStart",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_fmsg_arr_nest_start(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlFmsg::FmsgArrNestStart(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlFmsg",
            "FmsgArrNestStart",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_fmsg_nest_end(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlFmsg::FmsgNestEnd(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlFmsg",
            "FmsgNestEnd",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_fmsg_obj_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlFmsg::FmsgObjName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlFmsg",
            "FmsgObjName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlFmsg<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlFmsg<'a> {
        IterableDlFmsg::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlFmsg<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlFmsg<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlFmsg<'a> {
    type Item = Result<DlFmsg<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                107u16 => DlFmsg::FmsgObjNestStart(()),
                108u16 => DlFmsg::FmsgPairNestStart(()),
                109u16 => DlFmsg::FmsgArrNestStart(()),
                110u16 => DlFmsg::FmsgNestEnd(()),
                111u16 => DlFmsg::FmsgObjName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlFmsg",
            r#type.and_then(|t| DlFmsg::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlFmsg<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlFmsg");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlFmsg::FmsgObjNestStart(val) => fmt.field("FmsgObjNestStart", &val),
                DlFmsg::FmsgPairNestStart(val) => fmt.field("FmsgPairNestStart", &val),
                DlFmsg::FmsgArrNestStart(val) => fmt.field("FmsgArrNestStart", &val),
                DlFmsg::FmsgNestEnd(val) => fmt.field("FmsgNestEnd", &val),
                DlFmsg::FmsgObjName(val) => fmt.field("FmsgObjName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlFmsg<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlFmsg", offset));
            return (stack, missing_type.and_then(|t| DlFmsg::attr_from_type(t)));
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlFmsg::FmsgObjNestStart(val) => {
                    if last_off == offset {
                        stack.push(("FmsgObjNestStart", last_off));
                        break;
                    }
                }
                DlFmsg::FmsgPairNestStart(val) => {
                    if last_off == offset {
                        stack.push(("FmsgPairNestStart", last_off));
                        break;
                    }
                }
                DlFmsg::FmsgArrNestStart(val) => {
                    if last_off == offset {
                        stack.push(("FmsgArrNestStart", last_off));
                        break;
                    }
                }
                DlFmsg::FmsgNestEnd(val) => {
                    if last_off == offset {
                        stack.push(("FmsgNestEnd", last_off));
                        break;
                    }
                }
                DlFmsg::FmsgObjName(val) => {
                    if last_off == offset {
                        stack.push(("FmsgObjName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlFmsg", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlHealthReporter<'a> {
    HealthReporterName(&'a CStr),
    HealthReporterState(u8),
    HealthReporterErrCount(u64),
    HealthReporterRecoverCount(u64),
    HealthReporterDumpTs(u64),
    HealthReporterGracefulPeriod(u64),
    HealthReporterAutoRecover(u8),
    HealthReporterDumpTsNs(u64),
    HealthReporterAutoDump(u8),
    #[doc = "Time (in msec) for recoveries before starting the grace period."]
    HealthReporterBurstPeriod(u64),
}
impl<'a> IterableDlHealthReporter<'a> {
    pub fn get_health_reporter_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlHealthReporter::HealthReporterName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlHealthReporter",
            "HealthReporterName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_state(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlHealthReporter::HealthReporterState(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlHealthReporter",
            "HealthReporterState",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_err_count(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlHealthReporter::HealthReporterErrCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlHealthReporter",
            "HealthReporterErrCount",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_recover_count(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlHealthReporter::HealthReporterRecoverCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlHealthReporter",
            "HealthReporterRecoverCount",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_dump_ts(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlHealthReporter::HealthReporterDumpTs(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlHealthReporter",
            "HealthReporterDumpTs",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_graceful_period(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlHealthReporter::HealthReporterGracefulPeriod(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlHealthReporter",
            "HealthReporterGracefulPeriod",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_auto_recover(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlHealthReporter::HealthReporterAutoRecover(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlHealthReporter",
            "HealthReporterAutoRecover",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_dump_ts_ns(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlHealthReporter::HealthReporterDumpTsNs(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlHealthReporter",
            "HealthReporterDumpTsNs",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_auto_dump(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlHealthReporter::HealthReporterAutoDump(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlHealthReporter",
            "HealthReporterAutoDump",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Time (in msec) for recoveries before starting the grace period."]
    pub fn get_health_reporter_burst_period(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlHealthReporter::HealthReporterBurstPeriod(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlHealthReporter",
            "HealthReporterBurstPeriod",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlHealthReporter<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlHealthReporter<'a> {
        IterableDlHealthReporter::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlHealthReporter<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlHealthReporter<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlHealthReporter<'a> {
    type Item = Result<DlHealthReporter<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                115u16 => DlHealthReporter::HealthReporterName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                116u16 => DlHealthReporter::HealthReporterState({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                117u16 => DlHealthReporter::HealthReporterErrCount({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                118u16 => DlHealthReporter::HealthReporterRecoverCount({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                119u16 => DlHealthReporter::HealthReporterDumpTs({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                120u16 => DlHealthReporter::HealthReporterGracefulPeriod({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                121u16 => DlHealthReporter::HealthReporterAutoRecover({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                137u16 => DlHealthReporter::HealthReporterDumpTsNs({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                141u16 => DlHealthReporter::HealthReporterAutoDump({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                181u16 => DlHealthReporter::HealthReporterBurstPeriod({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlHealthReporter",
            r#type.and_then(|t| DlHealthReporter::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlHealthReporter<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlHealthReporter");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlHealthReporter::HealthReporterName(val) => fmt.field("HealthReporterName", &val),
                DlHealthReporter::HealthReporterState(val) => {
                    fmt.field("HealthReporterState", &val)
                }
                DlHealthReporter::HealthReporterErrCount(val) => {
                    fmt.field("HealthReporterErrCount", &val)
                }
                DlHealthReporter::HealthReporterRecoverCount(val) => {
                    fmt.field("HealthReporterRecoverCount", &val)
                }
                DlHealthReporter::HealthReporterDumpTs(val) => {
                    fmt.field("HealthReporterDumpTs", &val)
                }
                DlHealthReporter::HealthReporterGracefulPeriod(val) => {
                    fmt.field("HealthReporterGracefulPeriod", &val)
                }
                DlHealthReporter::HealthReporterAutoRecover(val) => {
                    fmt.field("HealthReporterAutoRecover", &val)
                }
                DlHealthReporter::HealthReporterDumpTsNs(val) => {
                    fmt.field("HealthReporterDumpTsNs", &val)
                }
                DlHealthReporter::HealthReporterAutoDump(val) => {
                    fmt.field("HealthReporterAutoDump", &val)
                }
                DlHealthReporter::HealthReporterBurstPeriod(val) => {
                    fmt.field("HealthReporterBurstPeriod", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableDlHealthReporter<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlHealthReporter", offset));
            return (
                stack,
                missing_type.and_then(|t| DlHealthReporter::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlHealthReporter::HealthReporterName(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterName", last_off));
                        break;
                    }
                }
                DlHealthReporter::HealthReporterState(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterState", last_off));
                        break;
                    }
                }
                DlHealthReporter::HealthReporterErrCount(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterErrCount", last_off));
                        break;
                    }
                }
                DlHealthReporter::HealthReporterRecoverCount(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterRecoverCount", last_off));
                        break;
                    }
                }
                DlHealthReporter::HealthReporterDumpTs(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterDumpTs", last_off));
                        break;
                    }
                }
                DlHealthReporter::HealthReporterGracefulPeriod(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterGracefulPeriod", last_off));
                        break;
                    }
                }
                DlHealthReporter::HealthReporterAutoRecover(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterAutoRecover", last_off));
                        break;
                    }
                }
                DlHealthReporter::HealthReporterDumpTsNs(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterDumpTsNs", last_off));
                        break;
                    }
                }
                DlHealthReporter::HealthReporterAutoDump(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterAutoDump", last_off));
                        break;
                    }
                }
                DlHealthReporter::HealthReporterBurstPeriod(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterBurstPeriod", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlHealthReporter", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlAttrStats {
    StatsRxPackets(u64),
    StatsRxBytes(u64),
    StatsRxDropped(u64),
}
impl<'a> IterableDlAttrStats<'a> {
    pub fn get_stats_rx_packets(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlAttrStats::StatsRxPackets(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlAttrStats",
            "StatsRxPackets",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_stats_rx_bytes(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlAttrStats::StatsRxBytes(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlAttrStats",
            "StatsRxBytes",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_stats_rx_dropped(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlAttrStats::StatsRxDropped(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlAttrStats",
            "StatsRxDropped",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlAttrStats {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlAttrStats<'a> {
        IterableDlAttrStats::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            0u16 => "StatsRxPackets",
            1u16 => "StatsRxBytes",
            2u16 => "StatsRxDropped",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlAttrStats<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlAttrStats<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlAttrStats<'a> {
    type Item = Result<DlAttrStats, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                0u16 => DlAttrStats::StatsRxPackets({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                1u16 => DlAttrStats::StatsRxBytes({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => DlAttrStats::StatsRxDropped({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlAttrStats",
            r#type.and_then(|t| DlAttrStats::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableDlAttrStats<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlAttrStats");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlAttrStats::StatsRxPackets(val) => fmt.field("StatsRxPackets", &val),
                DlAttrStats::StatsRxBytes(val) => fmt.field("StatsRxBytes", &val),
                DlAttrStats::StatsRxDropped(val) => fmt.field("StatsRxDropped", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlAttrStats<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlAttrStats", offset));
            return (
                stack,
                missing_type.and_then(|t| DlAttrStats::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlAttrStats::StatsRxPackets(val) => {
                    if last_off == offset {
                        stack.push(("StatsRxPackets", last_off));
                        break;
                    }
                }
                DlAttrStats::StatsRxBytes(val) => {
                    if last_off == offset {
                        stack.push(("StatsRxBytes", last_off));
                        break;
                    }
                }
                DlAttrStats::StatsRxDropped(val) => {
                    if last_off == offset {
                        stack.push(("StatsRxDropped", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlAttrStats", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlTrapMetadata {
    TrapMetadataTypeInPort(()),
    TrapMetadataTypeFaCookie(()),
}
impl<'a> IterableDlTrapMetadata<'a> {
    pub fn get_trap_metadata_type_in_port(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlTrapMetadata::TrapMetadataTypeInPort(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlTrapMetadata",
            "TrapMetadataTypeInPort",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_metadata_type_fa_cookie(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlTrapMetadata::TrapMetadataTypeFaCookie(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlTrapMetadata",
            "TrapMetadataTypeFaCookie",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlTrapMetadata {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlTrapMetadata<'a> {
        IterableDlTrapMetadata::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            0u16 => "TrapMetadataTypeInPort",
            1u16 => "TrapMetadataTypeFaCookie",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlTrapMetadata<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlTrapMetadata<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlTrapMetadata<'a> {
    type Item = Result<DlTrapMetadata, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                0u16 => DlTrapMetadata::TrapMetadataTypeInPort(()),
                1u16 => DlTrapMetadata::TrapMetadataTypeFaCookie(()),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlTrapMetadata",
            r#type.and_then(|t| DlTrapMetadata::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableDlTrapMetadata<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlTrapMetadata");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlTrapMetadata::TrapMetadataTypeInPort(val) => {
                    fmt.field("TrapMetadataTypeInPort", &val)
                }
                DlTrapMetadata::TrapMetadataTypeFaCookie(val) => {
                    fmt.field("TrapMetadataTypeFaCookie", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableDlTrapMetadata<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlTrapMetadata", offset));
            return (
                stack,
                missing_type.and_then(|t| DlTrapMetadata::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlTrapMetadata::TrapMetadataTypeInPort(val) => {
                    if last_off == offset {
                        stack.push(("TrapMetadataTypeInPort", last_off));
                        break;
                    }
                }
                DlTrapMetadata::TrapMetadataTypeFaCookie(val) => {
                    if last_off == offset {
                        stack.push(("TrapMetadataTypeFaCookie", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlTrapMetadata", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlLinecardSupportedTypes<'a> {
    LinecardType(&'a CStr),
}
impl<'a> IterableDlLinecardSupportedTypes<'a> {
    pub fn get_linecard_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlLinecardSupportedTypes::LinecardType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlLinecardSupportedTypes",
            "LinecardType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlLinecardSupportedTypes<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlLinecardSupportedTypes<'a> {
        IterableDlLinecardSupportedTypes::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlLinecardSupportedTypes<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlLinecardSupportedTypes<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlLinecardSupportedTypes<'a> {
    type Item = Result<DlLinecardSupportedTypes<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                173u16 => DlLinecardSupportedTypes::LinecardType({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlLinecardSupportedTypes",
            r#type.and_then(|t| DlLinecardSupportedTypes::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableDlLinecardSupportedTypes<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlLinecardSupportedTypes");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlLinecardSupportedTypes::LinecardType(val) => fmt.field("LinecardType", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlLinecardSupportedTypes<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlLinecardSupportedTypes", offset));
            return (
                stack,
                missing_type.and_then(|t| DlLinecardSupportedTypes::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlLinecardSupportedTypes::LinecardType(val) => {
                    if last_off == offset {
                        stack.push(("LinecardType", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlLinecardSupportedTypes", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlSelftestId {
    Flash(()),
}
impl<'a> IterableDlSelftestId<'a> {
    pub fn get_flash(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlSelftestId::Flash(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlSelftestId",
            "Flash",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlSelftestId {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlSelftestId<'a> {
        IterableDlSelftestId::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Flash",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlSelftestId<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlSelftestId<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlSelftestId<'a> {
    type Item = Result<DlSelftestId, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => DlSelftestId::Flash(()),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlSelftestId",
            r#type.and_then(|t| DlSelftestId::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableDlSelftestId<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlSelftestId");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlSelftestId::Flash(val) => fmt.field("Flash", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlSelftestId<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlSelftestId", offset));
            return (
                stack,
                missing_type.and_then(|t| DlSelftestId::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlSelftestId::Flash(val) => {
                    if last_off == offset {
                        stack.push(("Flash", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlSelftestId", cur));
        }
        (stack, None)
    }
}
#[derive(Clone)]
pub enum DlRateTcBws {
    Index(u8),
    #[doc = "Specifies the bandwidth share assigned to the Traffic Class.\nThe bandwidth for the traffic class is determined\nin proportion to the sum of the shares of all configured classes.\n"]
    Bw(u32),
}
impl<'a> IterableDlRateTcBws<'a> {
    pub fn get_index(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlRateTcBws::Index(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlRateTcBws",
            "Index",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Specifies the bandwidth share assigned to the Traffic Class.\nThe bandwidth for the traffic class is determined\nin proportion to the sum of the shares of all configured classes.\n"]
    pub fn get_bw(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let DlRateTcBws::Bw(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "DlRateTcBws",
            "Bw",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl DlRateTcBws {
    pub fn new<'a>(buf: &'a [u8]) -> IterableDlRateTcBws<'a> {
        IterableDlRateTcBws::with_loc(buf, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        let res = match r#type {
            1u16 => "Index",
            2u16 => "Bw",
            _ => return None,
        };
        Some(res)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableDlRateTcBws<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableDlRateTcBws<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableDlRateTcBws<'a> {
    type Item = Result<DlRateTcBws, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => DlRateTcBws::Index({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => DlRateTcBws::Bw({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "DlRateTcBws",
            r#type.and_then(|t| DlRateTcBws::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableDlRateTcBws<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("DlRateTcBws");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                DlRateTcBws::Index(val) => fmt.field("Index", &val),
                DlRateTcBws::Bw(val) => fmt.field("Bw", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableDlRateTcBws<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset {
            stack.push(("DlRateTcBws", offset));
            return (
                stack,
                missing_type.and_then(|t| DlRateTcBws::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                DlRateTcBws::Index(val) => {
                    if last_off == offset {
                        stack.push(("Index", last_off));
                        break;
                    }
                }
                DlRateTcBws::Bw(val) => {
                    if last_off == offset {
                        stack.push(("Bw", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("DlRateTcBws", cur));
        }
        (stack, None)
    }
}
pub struct PushDevlink<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDevlink<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDevlink<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"PortType\" (enum)"]
    pub fn push_port_type(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 4u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_desired_type(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 5u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_netdev_ifindex(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 6u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_netdev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            7u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_port_netdev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 7u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_ibdev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            8u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_port_ibdev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 8u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_split_count(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_split_group(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 10u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_size(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 12u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_ingress_pool_count(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 13u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_egress_pool_count(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 14u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_ingress_tc_count(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 15u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_egress_tc_count(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 16u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 17u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    pub fn push_sb_pool_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 18u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_size(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 19u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"SbThresholdType\" (enum)"]
    pub fn push_sb_pool_threshold_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 20u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_threshold(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 21u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_tc_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 22u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_occ_cur(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 23u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_occ_max(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 24u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"EswitchMode\" (enum)"]
    pub fn push_eswitch_mode(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 25u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"EswitchInlineMode\" (enum)"]
    pub fn push_eswitch_inline_mode(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 26u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_dpipe_tables(mut self) -> PushDlDpipeTables<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 27u16);
        PushDlDpipeTables {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_table(mut self) -> PushDlDpipeTable<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 28u16);
        PushDlDpipeTable {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_table_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            29u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dpipe_table_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 29u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dpipe_table_size(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 30u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_dpipe_table_matches(mut self) -> PushDlDpipeTableMatches<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 31u16);
        PushDlDpipeTableMatches {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_dpipe_table_actions(mut self) -> PushDlDpipeTableActions<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 32u16);
        PushDlDpipeTableActions {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_table_counters_enabled(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 33u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_dpipe_entries(mut self) -> PushDlDpipeEntries<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 34u16);
        PushDlDpipeEntries {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_entry(mut self) -> PushDlDpipeEntry<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 35u16);
        PushDlDpipeEntry {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_entry_index(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 36u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_dpipe_entry_match_values(mut self) -> PushDlDpipeEntryMatchValues<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 37u16);
        PushDlDpipeEntryMatchValues {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_dpipe_entry_action_values(mut self) -> PushDlDpipeEntryActionValues<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 38u16);
        PushDlDpipeEntryActionValues {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_entry_counter(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 39u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_match(mut self) -> PushDlDpipeMatch<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 40u16);
        PushDlDpipeMatch {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_match_value(mut self) -> PushDlDpipeMatchValue<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 41u16);
        PushDlDpipeMatchValue {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Associated type: \"DpipeMatchType\" (enum)"]
    pub fn push_dpipe_match_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 42u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_action(mut self) -> PushDlDpipeAction<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 43u16);
        PushDlDpipeAction {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_action_value(mut self) -> PushDlDpipeActionValue<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 44u16);
        PushDlDpipeActionValue {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Associated type: \"DpipeActionType\" (enum)"]
    pub fn push_dpipe_action_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 45u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_value(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 46u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_dpipe_value_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 47u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_dpipe_value_mapping(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 48u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_dpipe_headers(mut self) -> PushDlDpipeHeaders<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 49u16);
        PushDlDpipeHeaders {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_header(mut self) -> PushDlDpipeHeader<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 50u16);
        PushDlDpipeHeader {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_header_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            51u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dpipe_header_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 51u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    pub fn push_dpipe_header_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 52u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_dpipe_header_fields(mut self) -> PushDlDpipeHeaderFields<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 53u16);
        PushDlDpipeHeaderFields {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_header_global(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 54u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_header_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 55u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_field(mut self) -> PushDlDpipeField<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 56u16);
        PushDlDpipeField {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_field_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            57u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dpipe_field_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 57u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dpipe_field_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 58u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_field_bitwidth(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 59u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"DpipeFieldMappingType\" (enum)"]
    pub fn push_dpipe_field_mapping_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 60u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_pad(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 61u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "Associated type: \"EswitchEncapMode\" (enum)"]
    pub fn push_eswitch_encap_mode(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 62u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_resource_list(mut self) -> PushDlResourceList<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 63u16);
        PushDlResourceList {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_resource(mut self) -> PushDlResource<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 64u16);
        PushDlResource {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_resource_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            65u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_resource_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 65u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_resource_id(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 66u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 67u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size_new(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 68u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size_valid(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 69u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size_min(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 70u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size_max(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 71u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size_gran(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 72u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"ResourceUnit\" (enum)"]
    pub fn push_resource_unit(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 73u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_occ(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 74u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_table_resource_id(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 75u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_table_resource_units(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 76u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"PortFlavour\" (enum)"]
    pub fn push_port_flavour(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 77u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_number(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 78u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_split_subport_number(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 79u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_param(mut self) -> PushDlParam<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 80u16);
        PushDlParam {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_param_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            81u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_param_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 81u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_param_generic(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 82u16, 0 as u16);
        self
    }
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    pub fn push_param_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 83u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"ParamCmode\" (enum)"]
    pub fn push_param_value_cmode(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 87u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            88u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_region_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 88u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_region_size(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 89u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_region_snapshots(mut self) -> PushDlRegionSnapshots<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 90u16);
        PushDlRegionSnapshots {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_region_snapshot(mut self) -> PushDlRegionSnapshot<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 91u16);
        PushDlRegionSnapshot {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_region_snapshot_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 92u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_region_chunks(mut self) -> PushDlRegionChunks<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 93u16);
        PushDlRegionChunks {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_region_chunk(mut self) -> PushDlRegionChunk<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 94u16);
        PushDlRegionChunk {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_region_chunk_data(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 95u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_region_chunk_addr(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 96u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_chunk_len(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 97u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_info_driver_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            98u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_driver_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 98u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_info_serial_number(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            99u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_serial_number_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 99u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_info_version_fixed(mut self) -> PushDlInfoVersion<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 100u16);
        PushDlInfoVersion {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_info_version_running(mut self) -> PushDlInfoVersion<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 101u16);
        PushDlInfoVersion {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_info_version_stored(mut self) -> PushDlInfoVersion<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 102u16);
        PushDlInfoVersion {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_info_version_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            103u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_version_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 103u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_info_version_value(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            104u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_version_value_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 104u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_sb_pool_cell_size(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 105u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_fmsg(mut self) -> PushDlFmsg<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 106u16);
        PushDlFmsg {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_fmsg_obj_nest_start(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 107u16, 0 as u16);
        self
    }
    pub fn push_fmsg_pair_nest_start(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 108u16, 0 as u16);
        self
    }
    pub fn push_fmsg_arr_nest_start(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 109u16, 0 as u16);
        self
    }
    pub fn push_fmsg_nest_end(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 110u16, 0 as u16);
        self
    }
    pub fn push_fmsg_obj_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            111u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_fmsg_obj_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 111u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    pub fn push_fmsg_obj_value_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 112u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_health_reporter(mut self) -> PushDlHealthReporter<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 114u16);
        PushDlHealthReporter {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_health_reporter_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            115u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_health_reporter_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 115u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_health_reporter_state(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 116u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_err_count(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 117u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_recover_count(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 118u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_dump_ts(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 119u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_graceful_period(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 120u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_auto_recover(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 121u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flash_update_file_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            122u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_flash_update_file_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 122u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_flash_update_component(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            123u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_flash_update_component_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 123u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_flash_update_status_msg(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            124u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_flash_update_status_msg_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 124u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_flash_update_status_done(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 125u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flash_update_status_total(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 126u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_pci_pf_number(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 127u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_pci_vf_number(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 128u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_stats(mut self) -> PushDlAttrStats<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 129u16);
        PushDlAttrStats {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_trap_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            130u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_trap_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 130u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Associated type: \"TrapAction\" (enum)"]
    pub fn push_trap_action(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 131u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"TrapType\" (enum)"]
    pub fn push_trap_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 132u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_trap_generic(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 133u16, 0 as u16);
        self
    }
    pub fn nested_trap_metadata(mut self) -> PushDlTrapMetadata<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 134u16);
        PushDlTrapMetadata {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_trap_group_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            135u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_trap_group_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 135u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_reload_failed(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 136u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_dump_ts_ns(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 137u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_netns_fd(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 138u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_netns_pid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 139u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_netns_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 140u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_auto_dump(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 141u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_trap_policer_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 142u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_trap_policer_rate(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 143u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_trap_policer_burst(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 144u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_port_function(mut self) -> PushDlPortFunction<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 145u16);
        PushDlPortFunction {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_info_board_serial_number(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            146u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_board_serial_number_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 146u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_lanes(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 147u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_splittable(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 148u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_external(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 149u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_controller_number(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 150u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_flash_update_status_timeout(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 151u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"FlashOverwrite\" (1 bit per enumeration)"]
    pub fn push_flash_update_overwrite_mask(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 152u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    #[doc = "Associated type: \"ReloadAction\" (enum)"]
    pub fn push_reload_action(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 153u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    pub fn push_reload_actions_performed(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 154u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    pub fn push_reload_limits(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 155u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
    pub fn nested_dev_stats(mut self) -> PushDlDevStats<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 156u16);
        PushDlDevStats {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_reload_stats(mut self) -> PushDlReloadStats<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 157u16);
        PushDlReloadStats {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_reload_stats_entry(mut self) -> PushDlReloadStatsEntry<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 158u16);
        PushDlReloadStatsEntry {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_reload_stats_limit(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 159u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_reload_stats_value(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 160u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_remote_reload_stats(mut self) -> PushDlReloadStats<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 161u16);
        PushDlReloadStats {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_reload_action_info(mut self) -> PushDlReloadActInfo<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 162u16);
        PushDlReloadActInfo {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_reload_action_stats(mut self) -> PushDlReloadActStats<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 163u16);
        PushDlReloadActStats {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_port_pci_sf_number(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 164u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"RateType\" (enum)"]
    pub fn push_rate_type(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 165u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_tx_share(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 166u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_tx_max(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 167u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_node_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            168u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_rate_node_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 168u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rate_parent_node_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            169u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_rate_parent_node_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 169u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_region_max_snapshots(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 170u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_linecard_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 171u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_linecard_state(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 172u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_linecard_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            173u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_linecard_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 173u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_linecard_supported_types(mut self) -> PushDlLinecardSupportedTypes<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 174u16);
        PushDlLinecardSupportedTypes {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_selftests(mut self) -> PushDlSelftestId<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 176u16);
        PushDlSelftestId {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_rate_tx_priority(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 177u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_tx_weight(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 178u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_direct(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 179u16, 0 as u16);
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_rate_tc_bws(mut self) -> PushDlRateTcBws<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 180u16);
        PushDlRateTcBws {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Time (in msec) for recoveries before starting the grace period."]
    pub fn push_health_reporter_burst_period(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 181u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDevlink<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDevStats<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDevStats<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDevStats<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn nested_reload_stats(mut self) -> PushDlReloadStats<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 157u16);
        PushDlReloadStats {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_remote_reload_stats(mut self) -> PushDlReloadStats<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 161u16);
        PushDlReloadStats {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlDevStats<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlReloadStats<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlReloadStats<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlReloadStats<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_reload_action_info(mut self) -> PushDlReloadActInfo<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 162u16);
        PushDlReloadActInfo {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlReloadStats<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlReloadActInfo<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlReloadActInfo<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlReloadActInfo<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Associated type: \"ReloadAction\" (enum)"]
    pub fn push_reload_action(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 153u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_reload_action_stats(mut self) -> PushDlReloadActStats<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 163u16);
        PushDlReloadActStats {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlReloadActInfo<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlReloadActStats<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlReloadActStats<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlReloadActStats<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_reload_stats_entry(mut self) -> PushDlReloadStatsEntry<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 158u16);
        PushDlReloadStatsEntry {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlReloadActStats<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlReloadStatsEntry<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlReloadStatsEntry<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlReloadStatsEntry<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_reload_stats_limit(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 159u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_reload_stats_value(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 160u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlReloadStatsEntry<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlInfoVersion<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlInfoVersion<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlInfoVersion<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_info_version_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            103u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_version_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 103u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_info_version_value(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            104u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_version_value_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 104u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushDlInfoVersion<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlPortFunction<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlPortFunction<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlPortFunction<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_hw_addr(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    #[doc = "Associated type: \"PortFnState\" (enum)"]
    pub fn push_state(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 2u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"PortFnOpstate\" (enum)"]
    pub fn push_opstate(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 3u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"PortFnAttrCap\" (1 bit per enumeration)"]
    pub fn push_caps(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 4u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
}
impl<Prev: Rec> Drop for PushDlPortFunction<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeTables<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeTables<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeTables<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_table(mut self) -> PushDlDpipeTable<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 28u16);
        PushDlDpipeTable {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlDpipeTables<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeTable<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeTable<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeTable<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dpipe_table_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            29u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dpipe_table_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 29u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dpipe_table_size(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 30u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_dpipe_table_matches(mut self) -> PushDlDpipeTableMatches<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 31u16);
        PushDlDpipeTableMatches {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_dpipe_table_actions(mut self) -> PushDlDpipeTableActions<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 32u16);
        PushDlDpipeTableActions {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_table_counters_enabled(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 33u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_table_resource_id(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 75u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_table_resource_units(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 76u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlDpipeTable<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeTableMatches<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeTableMatches<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeTableMatches<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_match(mut self) -> PushDlDpipeMatch<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 40u16);
        PushDlDpipeMatch {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlDpipeTableMatches<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeTableActions<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeTableActions<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeTableActions<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_action(mut self) -> PushDlDpipeAction<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 43u16);
        PushDlDpipeAction {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlDpipeTableActions<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeEntries<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeEntries<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeEntries<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_entry(mut self) -> PushDlDpipeEntry<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 35u16);
        PushDlDpipeEntry {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlDpipeEntries<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeEntry<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeEntry<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeEntry<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dpipe_entry_index(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 36u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_dpipe_entry_match_values(mut self) -> PushDlDpipeEntryMatchValues<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 37u16);
        PushDlDpipeEntryMatchValues {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn nested_dpipe_entry_action_values(mut self) -> PushDlDpipeEntryActionValues<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 38u16);
        PushDlDpipeEntryActionValues {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_entry_counter(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 39u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlDpipeEntry<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeEntryMatchValues<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeEntryMatchValues<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeEntryMatchValues<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_match_value(mut self) -> PushDlDpipeMatchValue<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 41u16);
        PushDlDpipeMatchValue {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlDpipeEntryMatchValues<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeEntryActionValues<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeEntryActionValues<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeEntryActionValues<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_action_value(mut self) -> PushDlDpipeActionValue<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 44u16);
        PushDlDpipeActionValue {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlDpipeEntryActionValues<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeMatch<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeMatch<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeMatch<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Associated type: \"DpipeMatchType\" (enum)"]
    pub fn push_dpipe_match_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 42u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    pub fn push_dpipe_header_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 52u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_header_global(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 54u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_header_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 55u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_field_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 58u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlDpipeMatch<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeMatchValue<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeMatchValue<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeMatchValue<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_match(mut self) -> PushDlDpipeMatch<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 40u16);
        PushDlDpipeMatch {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_value(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 46u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_dpipe_value_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 47u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_dpipe_value_mapping(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 48u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlDpipeMatchValue<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeAction<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeAction<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeAction<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Associated type: \"DpipeActionType\" (enum)"]
    pub fn push_dpipe_action_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 45u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    pub fn push_dpipe_header_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 52u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_header_global(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 54u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_header_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 55u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_field_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 58u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlDpipeAction<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeActionValue<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeActionValue<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeActionValue<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_action(mut self) -> PushDlDpipeAction<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 43u16);
        PushDlDpipeAction {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_value(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 46u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_dpipe_value_mask(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 47u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_dpipe_value_mapping(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 48u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlDpipeActionValue<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeHeaders<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeHeaders<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeHeaders<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_header(mut self) -> PushDlDpipeHeader<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 50u16);
        PushDlDpipeHeader {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlDpipeHeaders<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeHeader<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeHeader<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeHeader<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dpipe_header_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            51u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dpipe_header_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 51u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Associated type: \"DpipeHeaderId\" (enum)"]
    pub fn push_dpipe_header_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 52u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_dpipe_header_fields(mut self) -> PushDlDpipeHeaderFields<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 53u16);
        PushDlDpipeHeaderFields {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_dpipe_header_global(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 54u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlDpipeHeader<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeHeaderFields<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeHeaderFields<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeHeaderFields<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_dpipe_field(mut self) -> PushDlDpipeField<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 56u16);
        PushDlDpipeField {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlDpipeHeaderFields<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlDpipeField<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlDpipeField<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlDpipeField<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_dpipe_field_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            57u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dpipe_field_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 57u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dpipe_field_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 58u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_dpipe_field_bitwidth(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 59u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"DpipeFieldMappingType\" (enum)"]
    pub fn push_dpipe_field_mapping_type(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 60u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlDpipeField<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlResource<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlResource<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlResource<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_resource_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            65u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_resource_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 65u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_resource_id(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 66u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 67u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size_new(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 68u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size_valid(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 69u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size_min(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 70u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size_max(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 71u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size_gran(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 72u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"ResourceUnit\" (enum)"]
    pub fn push_resource_unit(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 73u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_occ(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 74u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlResource<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlResourceList<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlResourceList<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlResourceList<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_resource(mut self) -> PushDlResource<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 64u16);
        PushDlResource {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlResourceList<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlParam<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlParam<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlParam<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_param_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            81u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_param_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 81u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_param_generic(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 82u16, 0 as u16);
        self
    }
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    pub fn push_param_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 83u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlParam<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlRegionSnapshots<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlRegionSnapshots<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlRegionSnapshots<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn nested_region_snapshot(mut self) -> PushDlRegionSnapshot<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 91u16);
        PushDlRegionSnapshot {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlRegionSnapshots<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlRegionSnapshot<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlRegionSnapshot<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlRegionSnapshot<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_region_snapshot_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 92u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlRegionSnapshot<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlRegionChunks<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlRegionChunks<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlRegionChunks<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn nested_region_chunk(mut self) -> PushDlRegionChunk<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 94u16);
        PushDlRegionChunk {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushDlRegionChunks<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlRegionChunk<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlRegionChunk<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlRegionChunk<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_region_chunk_data(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 95u16, value.len() as u16);
        self.as_rec_mut().extend(value);
        self
    }
    pub fn push_region_chunk_addr(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 96u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlRegionChunk<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlFmsg<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlFmsg<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlFmsg<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_fmsg_obj_nest_start(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 107u16, 0 as u16);
        self
    }
    pub fn push_fmsg_pair_nest_start(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 108u16, 0 as u16);
        self
    }
    pub fn push_fmsg_arr_nest_start(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 109u16, 0 as u16);
        self
    }
    pub fn push_fmsg_nest_end(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 110u16, 0 as u16);
        self
    }
    pub fn push_fmsg_obj_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            111u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_fmsg_obj_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 111u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushDlFmsg<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlHealthReporter<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlHealthReporter<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlHealthReporter<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_health_reporter_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            115u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_health_reporter_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 115u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_health_reporter_state(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 116u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_err_count(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 117u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_recover_count(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 118u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_dump_ts(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 119u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_graceful_period(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 120u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_auto_recover(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 121u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_dump_ts_ns(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 137u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_auto_dump(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 141u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Time (in msec) for recoveries before starting the grace period."]
    pub fn push_health_reporter_burst_period(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 181u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlHealthReporter<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlAttrStats<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlAttrStats<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlAttrStats<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_stats_rx_packets(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 0u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stats_rx_bytes(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 1u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_stats_rx_dropped(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 2u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlAttrStats<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlTrapMetadata<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlTrapMetadata<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlTrapMetadata<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_trap_metadata_type_in_port(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 0u16, 0 as u16);
        self
    }
    pub fn push_trap_metadata_type_fa_cookie(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 1u16, 0 as u16);
        self
    }
}
impl<Prev: Rec> Drop for PushDlTrapMetadata<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlLinecardSupportedTypes<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlLinecardSupportedTypes<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlLinecardSupportedTypes<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_linecard_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            173u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_linecard_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 173u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushDlLinecardSupportedTypes<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlSelftestId<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlSelftestId<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlSelftestId<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_flash(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 1u16, 0 as u16);
        self
    }
}
impl<Prev: Rec> Drop for PushDlSelftestId<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
pub struct PushDlRateTcBws<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushDlRateTcBws<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushDlRateTcBws<Prev> {
    pub fn new(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_index(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 1u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Specifies the bandwidth share assigned to the Traffic Class.\nThe bandwidth for the traffic class is determined\nin proportion to the sum of the shares of all configured classes.\n"]
    pub fn push_bw(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 2u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushDlRateTcBws<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get devlink instances."]
pub struct PushOpGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(1u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get devlink instances."]
#[derive(Clone)]
pub enum OpGetDumpRequest {}
impl<'a> IterableOpGetDumpRequest<'a> {}
impl OpGetDumpRequest {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetDumpRequest<'a> {
    type Item = Result<OpGetDumpRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetDumpRequest",
            r#type.and_then(|t| OpGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetDumpRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get devlink instances."]
pub struct PushOpGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(3u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_reload_failed(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 136u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_dev_stats(mut self) -> PushDlDevStats<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 156u16);
        PushDlDevStats {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get devlink instances."]
#[derive(Clone)]
pub enum OpGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    ReloadFailed(u8),
    DevStats(IterableDlDevStats<'a>),
}
impl<'a> IterableOpGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reload_failed(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetDumpReply::ReloadFailed(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetDumpReply",
            "ReloadFailed",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_stats(&self) -> Result<IterableDlDevStats<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetDumpReply::DevStats(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetDumpReply",
            "DevStats",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetDumpReply<'a> {
    type Item = Result<OpGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                136u16 => OpGetDumpReply::ReloadFailed({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                156u16 => OpGetDumpReply::DevStats({
                    let res = Some(IterableDlDevStats::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetDumpReply",
            r#type.and_then(|t| OpGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpGetDumpReply::ReloadFailed(val) => fmt.field("ReloadFailed", &val),
                OpGetDumpReply::DevStats(val) => fmt.field("DevStats", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpGetDumpReply::ReloadFailed(val) => {
                    if last_off == offset {
                        stack.push(("ReloadFailed", last_off));
                        break;
                    }
                }
                OpGetDumpReply::DevStats(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpGetDumpRequest<&mut Vec<u8>> {
        PushOpGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetDumpRequest<RequestBuf<'r>> {
        PushOpGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get devlink instances."]
pub struct PushOpGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(1u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get devlink instances."]
#[derive(Clone)]
pub enum OpGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetDoRequest<'a> {
    type Item = Result<OpGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetDoRequest",
            r#type.and_then(|t| OpGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpGetDoRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get devlink instances."]
pub struct PushOpGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(3u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_reload_failed(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 136u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_dev_stats(mut self) -> PushDlDevStats<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 156u16);
        PushDlDevStats {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get devlink instances."]
#[derive(Clone)]
pub enum OpGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    ReloadFailed(u8),
    DevStats(IterableDlDevStats<'a>),
}
impl<'a> IterableOpGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_reload_failed(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetDoReply::ReloadFailed(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetDoReply",
            "ReloadFailed",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_stats(&self) -> Result<IterableDlDevStats<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpGetDoReply::DevStats(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpGetDoReply",
            "DevStats",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpGetDoReply<'a> {
    type Item = Result<OpGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                136u16 => OpGetDoReply::ReloadFailed({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                156u16 => OpGetDoReply::DevStats({
                    let res = Some(IterableDlDevStats::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpGetDoReply",
            r#type.and_then(|t| OpGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpGetDoReply::ReloadFailed(val) => fmt.field("ReloadFailed", &val),
                OpGetDoReply::DevStats(val) => fmt.field("DevStats", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpGetDoReply::ReloadFailed(val) => {
                    if last_off == offset {
                        stack.push(("ReloadFailed", last_off));
                        break;
                    }
                }
                OpGetDoReply::DevStats(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpGetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpGetDoRequest<&mut Vec<u8>> {
        PushOpGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpGetDoRequest<RequestBuf<'r>> {
        PushOpGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get devlink port instances."]
pub struct PushOpPortGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(5u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get devlink port instances."]
#[derive(Clone)]
pub enum OpPortGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpPortGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortGetDumpRequest<'a> {
    type Item = Result<OpPortGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortGetDumpRequest",
            r#type.and_then(|t| OpPortGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpPortGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get devlink port instances."]
pub struct PushOpPortGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(3u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get devlink port instances."]
#[derive(Clone)]
pub enum OpPortGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpPortGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortGetDumpReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortGetDumpReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortGetDumpReply<'a> {
    type Item = Result<OpPortGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortGetDumpReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortGetDumpReply",
            r#type.and_then(|t| OpPortGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpPortGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpPortGetDumpReply::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortGetDumpReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpPortGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpPortGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpPortGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpPortGetDumpRequest<&mut Vec<u8>> {
        PushOpPortGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpPortGetDumpRequest<RequestBuf<'r>> {
        PushOpPortGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpPortGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpPortGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpPortGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpPortGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get devlink port instances."]
pub struct PushOpPortGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(5u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get devlink port instances."]
#[derive(Clone)]
pub enum OpPortGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpPortGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortGetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortGetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortGetDoRequest<'a> {
    type Item = Result<OpPortGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortGetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortGetDoRequest",
            r#type.and_then(|t| OpPortGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpPortGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpPortGetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortGetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get devlink port instances."]
pub struct PushOpPortGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(7u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get devlink port instances."]
#[derive(Clone)]
pub enum OpPortGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpPortGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortGetDoReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortGetDoReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortGetDoReply<'a> {
    type Item = Result<OpPortGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortGetDoReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortGetDoReply",
            r#type.and_then(|t| OpPortGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpPortGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpPortGetDoReply::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortGetDoReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpPortGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpPortGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpPortGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpPortGetDoRequest<&mut Vec<u8>> {
        PushOpPortGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpPortGetDoRequest<RequestBuf<'r>> {
        PushOpPortGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpPortGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpPortGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpPortGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpPortGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set devlink port instances."]
pub struct PushOpPortSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(6u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"PortType\" (enum)"]
    pub fn push_port_type(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 4u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn nested_port_function(mut self) -> PushDlPortFunction<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 145u16);
        PushDlPortFunction {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpPortSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set devlink port instances."]
#[derive(Clone)]
pub enum OpPortSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    #[doc = "Associated type: \"PortType\" (enum)"]
    PortType(u16),
    PortFunction(IterableDlPortFunction<'a>),
}
impl<'a> IterableOpPortSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortSetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortSetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"PortType\" (enum)"]
    pub fn get_port_type(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortSetDoRequest::PortType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortSetDoRequest",
            "PortType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_function(&self) -> Result<IterableDlPortFunction<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortSetDoRequest::PortFunction(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortSetDoRequest",
            "PortFunction",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortSetDoRequest<'a> {
    type Item = Result<OpPortSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortSetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                4u16 => OpPortSetDoRequest::PortType({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                145u16 => OpPortSetDoRequest::PortFunction({
                    let res = Some(IterableDlPortFunction::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortSetDoRequest",
            r#type.and_then(|t| OpPortSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpPortSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpPortSetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpPortSetDoRequest::PortType(val) => {
                    fmt.field("PortType", &FormatEnum(val.into(), PortType::from_value))
                }
                OpPortSetDoRequest::PortFunction(val) => fmt.field("PortFunction", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortSetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpPortSetDoRequest::PortType(val) => {
                    if last_off == offset {
                        stack.push(("PortType", last_off));
                        break;
                    }
                }
                OpPortSetDoRequest::PortFunction(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortSetDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Set devlink port instances."]
pub struct PushOpPortSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(6u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpPortSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set devlink port instances."]
#[derive(Clone)]
pub enum OpPortSetDoReply {}
impl<'a> IterableOpPortSetDoReply<'a> {}
impl OpPortSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortSetDoReply<'a> {
    type Item = Result<OpPortSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortSetDoReply",
            r#type.and_then(|t| OpPortSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpPortSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpPortSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpPortSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpPortSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpPortSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpPortSetDoRequest<&mut Vec<u8>> {
        PushOpPortSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpPortSetDoRequest<RequestBuf<'r>> {
        PushOpPortSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpPortSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpPortSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpPortSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpPortSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Create devlink port instances."]
pub struct PushOpPortNewDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortNewDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortNewDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(7u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"PortFlavour\" (enum)"]
    pub fn push_port_flavour(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 77u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_pci_pf_number(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 127u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_controller_number(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 150u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_pci_sf_number(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 164u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortNewDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create devlink port instances."]
#[derive(Clone)]
pub enum OpPortNewDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    #[doc = "Associated type: \"PortFlavour\" (enum)"]
    PortFlavour(u16),
    PortPciPfNumber(u16),
    PortControllerNumber(u32),
    PortPciSfNumber(u32),
}
impl<'a> IterableOpPortNewDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortNewDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortNewDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortNewDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortNewDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortNewDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortNewDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"PortFlavour\" (enum)"]
    pub fn get_port_flavour(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortNewDoRequest::PortFlavour(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortNewDoRequest",
            "PortFlavour",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_pci_pf_number(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortNewDoRequest::PortPciPfNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortNewDoRequest",
            "PortPciPfNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_controller_number(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortNewDoRequest::PortControllerNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortNewDoRequest",
            "PortControllerNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_pci_sf_number(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortNewDoRequest::PortPciSfNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortNewDoRequest",
            "PortPciSfNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortNewDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortNewDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortNewDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortNewDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortNewDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortNewDoRequest<'a> {
    type Item = Result<OpPortNewDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortNewDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortNewDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortNewDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                77u16 => OpPortNewDoRequest::PortFlavour({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                127u16 => OpPortNewDoRequest::PortPciPfNumber({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                150u16 => OpPortNewDoRequest::PortControllerNumber({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                164u16 => OpPortNewDoRequest::PortPciSfNumber({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortNewDoRequest",
            r#type.and_then(|t| OpPortNewDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortNewDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortNewDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortNewDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpPortNewDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpPortNewDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpPortNewDoRequest::PortFlavour(val) => fmt.field(
                    "PortFlavour",
                    &FormatEnum(val.into(), PortFlavour::from_value),
                ),
                OpPortNewDoRequest::PortPciPfNumber(val) => fmt.field("PortPciPfNumber", &val),
                OpPortNewDoRequest::PortControllerNumber(val) => {
                    fmt.field("PortControllerNumber", &val)
                }
                OpPortNewDoRequest::PortPciSfNumber(val) => fmt.field("PortPciSfNumber", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortNewDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortNewDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortNewDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortNewDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortNewDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortNewDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpPortNewDoRequest::PortFlavour(val) => {
                    if last_off == offset {
                        stack.push(("PortFlavour", last_off));
                        break;
                    }
                }
                OpPortNewDoRequest::PortPciPfNumber(val) => {
                    if last_off == offset {
                        stack.push(("PortPciPfNumber", last_off));
                        break;
                    }
                }
                OpPortNewDoRequest::PortControllerNumber(val) => {
                    if last_off == offset {
                        stack.push(("PortControllerNumber", last_off));
                        break;
                    }
                }
                OpPortNewDoRequest::PortPciSfNumber(val) => {
                    if last_off == offset {
                        stack.push(("PortPciSfNumber", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortNewDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Create devlink port instances."]
pub struct PushOpPortNewDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortNewDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortNewDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(7u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortNewDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create devlink port instances."]
#[derive(Clone)]
pub enum OpPortNewDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpPortNewDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortNewDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortNewDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortNewDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortNewDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortNewDoReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortNewDoReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortNewDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortNewDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortNewDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortNewDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortNewDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortNewDoReply<'a> {
    type Item = Result<OpPortNewDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortNewDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortNewDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortNewDoReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortNewDoReply",
            r#type.and_then(|t| OpPortNewDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortNewDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortNewDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortNewDoReply::BusName(val) => fmt.field("BusName", &val),
                OpPortNewDoReply::DevName(val) => fmt.field("DevName", &val),
                OpPortNewDoReply::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortNewDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortNewDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortNewDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortNewDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortNewDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortNewDoReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortNewDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpPortNewDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpPortNewDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpPortNewDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpPortNewDoRequest<&mut Vec<u8>> {
        PushOpPortNewDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpPortNewDoRequest<RequestBuf<'r>> {
        PushOpPortNewDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpPortNewDoRequest<'_> {
    type ReplyType<'buf> = IterableOpPortNewDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpPortNewDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpPortNewDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete devlink port instances."]
pub struct PushOpPortDelDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortDelDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortDelDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(8u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortDelDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete devlink port instances."]
#[derive(Clone)]
pub enum OpPortDelDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpPortDelDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortDelDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortDelDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortDelDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortDelDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortDelDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortDelDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortDelDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortDelDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortDelDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortDelDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortDelDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortDelDoRequest<'a> {
    type Item = Result<OpPortDelDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortDelDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortDelDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortDelDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortDelDoRequest",
            r#type.and_then(|t| OpPortDelDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortDelDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortDelDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortDelDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpPortDelDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpPortDelDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortDelDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortDelDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortDelDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortDelDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortDelDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortDelDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortDelDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete devlink port instances."]
pub struct PushOpPortDelDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortDelDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortDelDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(8u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpPortDelDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete devlink port instances."]
#[derive(Clone)]
pub enum OpPortDelDoReply {}
impl<'a> IterableOpPortDelDoReply<'a> {}
impl OpPortDelDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortDelDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortDelDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortDelDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortDelDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortDelDoReply<'a> {
    type Item = Result<OpPortDelDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortDelDoReply",
            r#type.and_then(|t| OpPortDelDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpPortDelDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortDelDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpPortDelDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortDelDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortDelDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpPortDelDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpPortDelDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpPortDelDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpPortDelDoRequest<&mut Vec<u8>> {
        PushOpPortDelDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpPortDelDoRequest<RequestBuf<'r>> {
        PushOpPortDelDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpPortDelDoRequest<'_> {
    type ReplyType<'buf> = IterableOpPortDelDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpPortDelDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpPortDelDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Split devlink port instances."]
pub struct PushOpPortSplitDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortSplitDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortSplitDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(9u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_port_split_count(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 9u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortSplitDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Split devlink port instances."]
#[derive(Clone)]
pub enum OpPortSplitDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    PortSplitCount(u32),
}
impl<'a> IterableOpPortSplitDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortSplitDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortSplitDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortSplitDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortSplitDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortSplitDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortSplitDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_split_count(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortSplitDoRequest::PortSplitCount(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortSplitDoRequest",
            "PortSplitCount",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortSplitDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortSplitDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortSplitDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortSplitDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortSplitDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortSplitDoRequest<'a> {
    type Item = Result<OpPortSplitDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortSplitDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortSplitDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortSplitDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                9u16 => OpPortSplitDoRequest::PortSplitCount({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortSplitDoRequest",
            r#type.and_then(|t| OpPortSplitDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortSplitDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortSplitDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortSplitDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpPortSplitDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpPortSplitDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpPortSplitDoRequest::PortSplitCount(val) => fmt.field("PortSplitCount", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortSplitDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortSplitDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortSplitDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortSplitDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortSplitDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortSplitDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpPortSplitDoRequest::PortSplitCount(val) => {
                    if last_off == offset {
                        stack.push(("PortSplitCount", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortSplitDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Split devlink port instances."]
pub struct PushOpPortSplitDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortSplitDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortSplitDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(9u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpPortSplitDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Split devlink port instances."]
#[derive(Clone)]
pub enum OpPortSplitDoReply {}
impl<'a> IterableOpPortSplitDoReply<'a> {}
impl OpPortSplitDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortSplitDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortSplitDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortSplitDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortSplitDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortSplitDoReply<'a> {
    type Item = Result<OpPortSplitDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortSplitDoReply",
            r#type.and_then(|t| OpPortSplitDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpPortSplitDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortSplitDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpPortSplitDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortSplitDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortSplitDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpPortSplitDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpPortSplitDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpPortSplitDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpPortSplitDoRequest<&mut Vec<u8>> {
        PushOpPortSplitDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpPortSplitDoRequest<RequestBuf<'r>> {
        PushOpPortSplitDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpPortSplitDoRequest<'_> {
    type ReplyType<'buf> = IterableOpPortSplitDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpPortSplitDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpPortSplitDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Unplit devlink port instances."]
pub struct PushOpPortUnsplitDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortUnsplitDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortUnsplitDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(10u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortUnsplitDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Unplit devlink port instances."]
#[derive(Clone)]
pub enum OpPortUnsplitDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpPortUnsplitDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortUnsplitDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortUnsplitDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortUnsplitDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortUnsplitDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortUnsplitDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortUnsplitDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortUnsplitDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortUnsplitDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortUnsplitDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortUnsplitDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortUnsplitDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortUnsplitDoRequest<'a> {
    type Item = Result<OpPortUnsplitDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortUnsplitDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortUnsplitDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortUnsplitDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortUnsplitDoRequest",
            r#type.and_then(|t| OpPortUnsplitDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortUnsplitDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortUnsplitDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortUnsplitDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpPortUnsplitDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpPortUnsplitDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortUnsplitDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortUnsplitDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortUnsplitDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortUnsplitDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortUnsplitDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortUnsplitDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortUnsplitDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Unplit devlink port instances."]
pub struct PushOpPortUnsplitDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortUnsplitDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortUnsplitDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(10u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpPortUnsplitDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Unplit devlink port instances."]
#[derive(Clone)]
pub enum OpPortUnsplitDoReply {}
impl<'a> IterableOpPortUnsplitDoReply<'a> {}
impl OpPortUnsplitDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortUnsplitDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortUnsplitDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortUnsplitDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortUnsplitDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortUnsplitDoReply<'a> {
    type Item = Result<OpPortUnsplitDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortUnsplitDoReply",
            r#type.and_then(|t| OpPortUnsplitDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpPortUnsplitDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortUnsplitDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpPortUnsplitDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortUnsplitDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortUnsplitDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpPortUnsplitDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpPortUnsplitDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpPortUnsplitDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpPortUnsplitDoRequest<&mut Vec<u8>> {
        PushOpPortUnsplitDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpPortUnsplitDoRequest<RequestBuf<'r>> {
        PushOpPortUnsplitDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpPortUnsplitDoRequest<'_> {
    type ReplyType<'buf> = IterableOpPortUnsplitDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpPortUnsplitDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpPortUnsplitDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get shared buffer instances."]
pub struct PushOpSbGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(11u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer instances."]
#[derive(Clone)]
pub enum OpSbGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpSbGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbGetDumpRequest<'a> {
    type Item = Result<OpSbGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbGetDumpRequest",
            r#type.and_then(|t| OpSbGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get shared buffer instances."]
pub struct PushOpSbGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(13u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer instances."]
#[derive(Clone)]
pub enum OpSbGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    SbIndex(u32),
}
impl<'a> IterableOpSbGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbGetDumpReply::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbGetDumpReply",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbGetDumpReply<'a> {
    type Item = Result<OpSbGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbGetDumpReply::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbGetDumpReply",
            r#type.and_then(|t| OpSbGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpSbGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpSbGetDumpReply::SbIndex(val) => fmt.field("SbIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbGetDumpReply::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpSbGetDumpRequest<&mut Vec<u8>> {
        PushOpSbGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbGetDumpRequest<RequestBuf<'r>> {
        PushOpSbGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpSbGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get shared buffer instances."]
pub struct PushOpSbGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(11u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer instances."]
#[derive(Clone)]
pub enum OpSbGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    SbIndex(u32),
}
impl<'a> IterableOpSbGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbGetDoRequest::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbGetDoRequest",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbGetDoRequest<'a> {
    type Item = Result<OpSbGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbGetDoRequest::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbGetDoRequest",
            r#type.and_then(|t| OpSbGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpSbGetDoRequest::SbIndex(val) => fmt.field("SbIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbGetDoRequest::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get shared buffer instances."]
pub struct PushOpSbGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(13u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer instances."]
#[derive(Clone)]
pub enum OpSbGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    SbIndex(u32),
}
impl<'a> IterableOpSbGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbGetDoReply::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbGetDoReply",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbGetDoReply<'a> {
    type Item = Result<OpSbGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbGetDoReply::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbGetDoReply",
            r#type.and_then(|t| OpSbGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpSbGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpSbGetDoReply::SbIndex(val) => fmt.field("SbIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbGetDoReply::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpSbGetDoRequest<&mut Vec<u8>> {
        PushOpSbGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbGetDoRequest<RequestBuf<'r>> {
        PushOpSbGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpSbGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get shared buffer pool instances."]
pub struct PushOpSbPoolGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPoolGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPoolGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(15u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbPoolGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer pool instances."]
#[derive(Clone)]
pub enum OpSbPoolGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpSbPoolGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbPoolGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPoolGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPoolGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPoolGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPoolGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPoolGetDumpRequest<'a> {
    type Item = Result<OpSbPoolGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbPoolGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbPoolGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPoolGetDumpRequest",
            r#type.and_then(|t| OpSbPoolGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbPoolGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPoolGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbPoolGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbPoolGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbPoolGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPoolGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPoolGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbPoolGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbPoolGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbPoolGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get shared buffer pool instances."]
pub struct PushOpSbPoolGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPoolGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPoolGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(17u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 17u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbPoolGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer pool instances."]
#[derive(Clone)]
pub enum OpSbPoolGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    SbIndex(u32),
    SbPoolIndex(u16),
}
impl<'a> IterableOpSbPoolGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDumpReply::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDumpReply",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDumpReply::SbPoolIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDumpReply",
            "SbPoolIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbPoolGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPoolGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPoolGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPoolGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPoolGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPoolGetDumpReply<'a> {
    type Item = Result<OpSbPoolGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbPoolGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbPoolGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbPoolGetDumpReply::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpSbPoolGetDumpReply::SbPoolIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPoolGetDumpReply",
            r#type.and_then(|t| OpSbPoolGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbPoolGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPoolGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbPoolGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpSbPoolGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpSbPoolGetDumpReply::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbPoolGetDumpReply::SbPoolIndex(val) => fmt.field("SbPoolIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbPoolGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPoolGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPoolGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbPoolGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbPoolGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbPoolGetDumpReply::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbPoolGetDumpReply::SbPoolIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbPoolGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbPoolGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbPoolGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbPoolGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpSbPoolGetDumpRequest<&mut Vec<u8>> {
        PushOpSbPoolGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbPoolGetDumpRequest<RequestBuf<'r>> {
        PushOpSbPoolGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbPoolGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpSbPoolGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbPoolGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbPoolGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get shared buffer pool instances."]
pub struct PushOpSbPoolGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPoolGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPoolGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(15u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 17u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbPoolGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer pool instances."]
#[derive(Clone)]
pub enum OpSbPoolGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    SbIndex(u32),
    SbPoolIndex(u16),
}
impl<'a> IterableOpSbPoolGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDoRequest::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDoRequest",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDoRequest::SbPoolIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDoRequest",
            "SbPoolIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbPoolGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPoolGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPoolGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPoolGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPoolGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPoolGetDoRequest<'a> {
    type Item = Result<OpSbPoolGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbPoolGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbPoolGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbPoolGetDoRequest::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpSbPoolGetDoRequest::SbPoolIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPoolGetDoRequest",
            r#type.and_then(|t| OpSbPoolGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbPoolGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPoolGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbPoolGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbPoolGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpSbPoolGetDoRequest::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbPoolGetDoRequest::SbPoolIndex(val) => fmt.field("SbPoolIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbPoolGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPoolGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPoolGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbPoolGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbPoolGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbPoolGetDoRequest::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbPoolGetDoRequest::SbPoolIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbPoolGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get shared buffer pool instances."]
pub struct PushOpSbPoolGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPoolGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPoolGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(17u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 17u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbPoolGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer pool instances."]
#[derive(Clone)]
pub enum OpSbPoolGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    SbIndex(u32),
    SbPoolIndex(u16),
}
impl<'a> IterableOpSbPoolGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDoReply::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDoReply",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolGetDoReply::SbPoolIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolGetDoReply",
            "SbPoolIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbPoolGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPoolGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPoolGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPoolGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPoolGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPoolGetDoReply<'a> {
    type Item = Result<OpSbPoolGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbPoolGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbPoolGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbPoolGetDoReply::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpSbPoolGetDoReply::SbPoolIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPoolGetDoReply",
            r#type.and_then(|t| OpSbPoolGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbPoolGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPoolGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbPoolGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpSbPoolGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpSbPoolGetDoReply::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbPoolGetDoReply::SbPoolIndex(val) => fmt.field("SbPoolIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbPoolGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPoolGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPoolGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbPoolGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbPoolGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbPoolGetDoReply::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbPoolGetDoReply::SbPoolIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbPoolGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbPoolGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbPoolGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbPoolGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpSbPoolGetDoRequest<&mut Vec<u8>> {
        PushOpSbPoolGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbPoolGetDoRequest<RequestBuf<'r>> {
        PushOpSbPoolGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbPoolGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpSbPoolGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbPoolGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbPoolGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set shared buffer pool instances."]
pub struct PushOpSbPoolSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPoolSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPoolSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(16u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 17u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_size(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 19u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"SbThresholdType\" (enum)"]
    pub fn push_sb_pool_threshold_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 20u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbPoolSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set shared buffer pool instances."]
#[derive(Clone)]
pub enum OpSbPoolSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    SbIndex(u32),
    SbPoolIndex(u16),
    SbPoolSize(u32),
    #[doc = "Associated type: \"SbThresholdType\" (enum)"]
    SbPoolThresholdType(u8),
}
impl<'a> IterableOpSbPoolSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolSetDoRequest::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolSetDoRequest",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolSetDoRequest::SbPoolIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolSetDoRequest",
            "SbPoolIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_size(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolSetDoRequest::SbPoolSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolSetDoRequest",
            "SbPoolSize",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"SbThresholdType\" (enum)"]
    pub fn get_sb_pool_threshold_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPoolSetDoRequest::SbPoolThresholdType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPoolSetDoRequest",
            "SbPoolThresholdType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbPoolSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPoolSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPoolSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPoolSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPoolSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPoolSetDoRequest<'a> {
    type Item = Result<OpSbPoolSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbPoolSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbPoolSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbPoolSetDoRequest::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpSbPoolSetDoRequest::SbPoolIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                19u16 => OpSbPoolSetDoRequest::SbPoolSize({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                20u16 => OpSbPoolSetDoRequest::SbPoolThresholdType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPoolSetDoRequest",
            r#type.and_then(|t| OpSbPoolSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbPoolSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPoolSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbPoolSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbPoolSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpSbPoolSetDoRequest::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbPoolSetDoRequest::SbPoolIndex(val) => fmt.field("SbPoolIndex", &val),
                OpSbPoolSetDoRequest::SbPoolSize(val) => fmt.field("SbPoolSize", &val),
                OpSbPoolSetDoRequest::SbPoolThresholdType(val) => fmt.field(
                    "SbPoolThresholdType",
                    &FormatEnum(val.into(), SbThresholdType::from_value),
                ),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbPoolSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPoolSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPoolSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbPoolSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbPoolSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbPoolSetDoRequest::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbPoolSetDoRequest::SbPoolIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolIndex", last_off));
                        break;
                    }
                }
                OpSbPoolSetDoRequest::SbPoolSize(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolSize", last_off));
                        break;
                    }
                }
                OpSbPoolSetDoRequest::SbPoolThresholdType(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolThresholdType", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbPoolSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set shared buffer pool instances."]
pub struct PushOpSbPoolSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPoolSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPoolSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(16u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpSbPoolSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set shared buffer pool instances."]
#[derive(Clone)]
pub enum OpSbPoolSetDoReply {}
impl<'a> IterableOpSbPoolSetDoReply<'a> {}
impl OpSbPoolSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPoolSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPoolSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPoolSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPoolSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPoolSetDoReply<'a> {
    type Item = Result<OpSbPoolSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPoolSetDoReply",
            r#type.and_then(|t| OpSbPoolSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpSbPoolSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPoolSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpSbPoolSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPoolSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPoolSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbPoolSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbPoolSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbPoolSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpSbPoolSetDoRequest<&mut Vec<u8>> {
        PushOpSbPoolSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbPoolSetDoRequest<RequestBuf<'r>> {
        PushOpSbPoolSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbPoolSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpSbPoolSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbPoolSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbPoolSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get shared buffer port-pool combinations and threshold."]
pub struct PushOpSbPortPoolGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPortPoolGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPortPoolGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(19u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbPortPoolGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer port-pool combinations and threshold."]
#[derive(Clone)]
pub enum OpSbPortPoolGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpSbPortPoolGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbPortPoolGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPortPoolGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPortPoolGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPortPoolGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPortPoolGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPortPoolGetDumpRequest<'a> {
    type Item = Result<OpSbPortPoolGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbPortPoolGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbPortPoolGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPortPoolGetDumpRequest",
            r#type.and_then(|t| OpSbPortPoolGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbPortPoolGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPortPoolGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbPortPoolGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbPortPoolGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbPortPoolGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPortPoolGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPortPoolGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbPortPoolGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbPortPoolGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get shared buffer port-pool combinations and threshold."]
pub struct PushOpSbPortPoolGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPortPoolGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPortPoolGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(21u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 17u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbPortPoolGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer port-pool combinations and threshold."]
#[derive(Clone)]
pub enum OpSbPortPoolGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    SbIndex(u32),
    SbPoolIndex(u16),
}
impl<'a> IterableOpSbPortPoolGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDumpReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDumpReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDumpReply::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDumpReply",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDumpReply::SbPoolIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDumpReply",
            "SbPoolIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbPortPoolGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPortPoolGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPortPoolGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPortPoolGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPortPoolGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPortPoolGetDumpReply<'a> {
    type Item = Result<OpSbPortPoolGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbPortPoolGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbPortPoolGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpSbPortPoolGetDumpReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbPortPoolGetDumpReply::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpSbPortPoolGetDumpReply::SbPoolIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPortPoolGetDumpReply",
            r#type.and_then(|t| OpSbPortPoolGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbPortPoolGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPortPoolGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbPortPoolGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpSbPortPoolGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpSbPortPoolGetDumpReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpSbPortPoolGetDumpReply::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbPortPoolGetDumpReply::SbPoolIndex(val) => fmt.field("SbPoolIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbPortPoolGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPortPoolGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPortPoolGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbPortPoolGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDumpReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDumpReply::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDumpReply::SbPoolIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbPortPoolGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbPortPoolGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbPortPoolGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbPortPoolGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpSbPortPoolGetDumpRequest<&mut Vec<u8>> {
        PushOpSbPortPoolGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbPortPoolGetDumpRequest<RequestBuf<'r>> {
        PushOpSbPortPoolGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbPortPoolGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpSbPortPoolGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbPortPoolGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbPortPoolGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get shared buffer port-pool combinations and threshold."]
pub struct PushOpSbPortPoolGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPortPoolGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPortPoolGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(19u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 17u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbPortPoolGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer port-pool combinations and threshold."]
#[derive(Clone)]
pub enum OpSbPortPoolGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    SbIndex(u32),
    SbPoolIndex(u16),
}
impl<'a> IterableOpSbPortPoolGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDoRequest::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDoRequest",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDoRequest::SbPoolIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDoRequest",
            "SbPoolIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbPortPoolGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPortPoolGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPortPoolGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPortPoolGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPortPoolGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPortPoolGetDoRequest<'a> {
    type Item = Result<OpSbPortPoolGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbPortPoolGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbPortPoolGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpSbPortPoolGetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbPortPoolGetDoRequest::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpSbPortPoolGetDoRequest::SbPoolIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPortPoolGetDoRequest",
            r#type.and_then(|t| OpSbPortPoolGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbPortPoolGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPortPoolGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbPortPoolGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbPortPoolGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpSbPortPoolGetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpSbPortPoolGetDoRequest::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbPortPoolGetDoRequest::SbPoolIndex(val) => fmt.field("SbPoolIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbPortPoolGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPortPoolGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPortPoolGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbPortPoolGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDoRequest::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDoRequest::SbPoolIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbPortPoolGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get shared buffer port-pool combinations and threshold."]
pub struct PushOpSbPortPoolGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPortPoolGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPortPoolGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(21u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 17u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbPortPoolGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer port-pool combinations and threshold."]
#[derive(Clone)]
pub enum OpSbPortPoolGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    SbIndex(u32),
    SbPoolIndex(u16),
}
impl<'a> IterableOpSbPortPoolGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDoReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDoReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDoReply::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDoReply",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolGetDoReply::SbPoolIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolGetDoReply",
            "SbPoolIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbPortPoolGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPortPoolGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPortPoolGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPortPoolGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPortPoolGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPortPoolGetDoReply<'a> {
    type Item = Result<OpSbPortPoolGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbPortPoolGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbPortPoolGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpSbPortPoolGetDoReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbPortPoolGetDoReply::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpSbPortPoolGetDoReply::SbPoolIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPortPoolGetDoReply",
            r#type.and_then(|t| OpSbPortPoolGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbPortPoolGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPortPoolGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbPortPoolGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpSbPortPoolGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpSbPortPoolGetDoReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpSbPortPoolGetDoReply::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbPortPoolGetDoReply::SbPoolIndex(val) => fmt.field("SbPoolIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbPortPoolGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPortPoolGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPortPoolGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbPortPoolGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDoReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDoReply::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbPortPoolGetDoReply::SbPoolIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbPortPoolGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbPortPoolGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbPortPoolGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbPortPoolGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpSbPortPoolGetDoRequest<&mut Vec<u8>> {
        PushOpSbPortPoolGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbPortPoolGetDoRequest<RequestBuf<'r>> {
        PushOpSbPortPoolGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbPortPoolGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpSbPortPoolGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbPortPoolGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbPortPoolGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set shared buffer port-pool combinations and threshold."]
pub struct PushOpSbPortPoolSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPortPoolSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPortPoolSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(20u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 17u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_threshold(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 21u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbPortPoolSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set shared buffer port-pool combinations and threshold."]
#[derive(Clone)]
pub enum OpSbPortPoolSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    SbIndex(u32),
    SbPoolIndex(u16),
    SbThreshold(u32),
}
impl<'a> IterableOpSbPortPoolSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolSetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolSetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolSetDoRequest::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolSetDoRequest",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolSetDoRequest::SbPoolIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolSetDoRequest",
            "SbPoolIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_threshold(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbPortPoolSetDoRequest::SbThreshold(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbPortPoolSetDoRequest",
            "SbThreshold",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbPortPoolSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPortPoolSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPortPoolSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPortPoolSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPortPoolSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPortPoolSetDoRequest<'a> {
    type Item = Result<OpSbPortPoolSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbPortPoolSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbPortPoolSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpSbPortPoolSetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbPortPoolSetDoRequest::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpSbPortPoolSetDoRequest::SbPoolIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                21u16 => OpSbPortPoolSetDoRequest::SbThreshold({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPortPoolSetDoRequest",
            r#type.and_then(|t| OpSbPortPoolSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbPortPoolSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPortPoolSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbPortPoolSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbPortPoolSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpSbPortPoolSetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpSbPortPoolSetDoRequest::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbPortPoolSetDoRequest::SbPoolIndex(val) => fmt.field("SbPoolIndex", &val),
                OpSbPortPoolSetDoRequest::SbThreshold(val) => fmt.field("SbThreshold", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbPortPoolSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPortPoolSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPortPoolSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbPortPoolSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbPortPoolSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbPortPoolSetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpSbPortPoolSetDoRequest::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbPortPoolSetDoRequest::SbPoolIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolIndex", last_off));
                        break;
                    }
                }
                OpSbPortPoolSetDoRequest::SbThreshold(val) => {
                    if last_off == offset {
                        stack.push(("SbThreshold", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbPortPoolSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set shared buffer port-pool combinations and threshold."]
pub struct PushOpSbPortPoolSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbPortPoolSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbPortPoolSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(20u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpSbPortPoolSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set shared buffer port-pool combinations and threshold."]
#[derive(Clone)]
pub enum OpSbPortPoolSetDoReply {}
impl<'a> IterableOpSbPortPoolSetDoReply<'a> {}
impl OpSbPortPoolSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbPortPoolSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbPortPoolSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbPortPoolSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbPortPoolSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbPortPoolSetDoReply<'a> {
    type Item = Result<OpSbPortPoolSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbPortPoolSetDoReply",
            r#type.and_then(|t| OpSbPortPoolSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpSbPortPoolSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbPortPoolSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpSbPortPoolSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbPortPoolSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbPortPoolSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbPortPoolSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbPortPoolSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbPortPoolSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpSbPortPoolSetDoRequest<&mut Vec<u8>> {
        PushOpSbPortPoolSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbPortPoolSetDoRequest<RequestBuf<'r>> {
        PushOpSbPortPoolSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbPortPoolSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpSbPortPoolSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbPortPoolSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbPortPoolSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get shared buffer port-TC to pool bindings and threshold."]
pub struct PushOpSbTcPoolBindGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbTcPoolBindGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbTcPoolBindGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(23u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbTcPoolBindGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer port-TC to pool bindings and threshold."]
#[derive(Clone)]
pub enum OpSbTcPoolBindGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpSbTcPoolBindGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbTcPoolBindGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbTcPoolBindGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbTcPoolBindGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbTcPoolBindGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbTcPoolBindGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbTcPoolBindGetDumpRequest<'a> {
    type Item = Result<OpSbTcPoolBindGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbTcPoolBindGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbTcPoolBindGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbTcPoolBindGetDumpRequest",
            r#type.and_then(|t| OpSbTcPoolBindGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbTcPoolBindGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbTcPoolBindGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbTcPoolBindGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbTcPoolBindGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbTcPoolBindGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbTcPoolBindGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbTcPoolBindGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbTcPoolBindGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbTcPoolBindGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get shared buffer port-TC to pool bindings and threshold."]
pub struct PushOpSbTcPoolBindGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbTcPoolBindGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbTcPoolBindGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(25u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    pub fn push_sb_pool_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 18u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_tc_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 22u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbTcPoolBindGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer port-TC to pool bindings and threshold."]
#[derive(Clone)]
pub enum OpSbTcPoolBindGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    SbIndex(u32),
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    SbPoolType(u8),
    SbTcIndex(u16),
}
impl<'a> IterableOpSbTcPoolBindGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDumpReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDumpReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDumpReply::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDumpReply",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    pub fn get_sb_pool_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDumpReply::SbPoolType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDumpReply",
            "SbPoolType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_tc_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDumpReply::SbTcIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDumpReply",
            "SbTcIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbTcPoolBindGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbTcPoolBindGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbTcPoolBindGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbTcPoolBindGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbTcPoolBindGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbTcPoolBindGetDumpReply<'a> {
    type Item = Result<OpSbTcPoolBindGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbTcPoolBindGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbTcPoolBindGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpSbTcPoolBindGetDumpReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbTcPoolBindGetDumpReply::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpSbTcPoolBindGetDumpReply::SbPoolType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                22u16 => OpSbTcPoolBindGetDumpReply::SbTcIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbTcPoolBindGetDumpReply",
            r#type.and_then(|t| OpSbTcPoolBindGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbTcPoolBindGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbTcPoolBindGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbTcPoolBindGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpSbTcPoolBindGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpSbTcPoolBindGetDumpReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpSbTcPoolBindGetDumpReply::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbTcPoolBindGetDumpReply::SbPoolType(val) => fmt.field(
                    "SbPoolType",
                    &FormatEnum(val.into(), SbPoolType::from_value),
                ),
                OpSbTcPoolBindGetDumpReply::SbTcIndex(val) => fmt.field("SbTcIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbTcPoolBindGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbTcPoolBindGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbTcPoolBindGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbTcPoolBindGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDumpReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDumpReply::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDumpReply::SbPoolType(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolType", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDumpReply::SbTcIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbTcIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbTcPoolBindGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbTcPoolBindGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbTcPoolBindGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbTcPoolBindGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpSbTcPoolBindGetDumpRequest<&mut Vec<u8>> {
        PushOpSbTcPoolBindGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbTcPoolBindGetDumpRequest<RequestBuf<'r>> {
        PushOpSbTcPoolBindGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbTcPoolBindGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpSbTcPoolBindGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbTcPoolBindGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbTcPoolBindGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get shared buffer port-TC to pool bindings and threshold."]
pub struct PushOpSbTcPoolBindGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbTcPoolBindGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbTcPoolBindGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(23u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    pub fn push_sb_pool_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 18u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_tc_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 22u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbTcPoolBindGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer port-TC to pool bindings and threshold."]
#[derive(Clone)]
pub enum OpSbTcPoolBindGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    SbIndex(u32),
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    SbPoolType(u8),
    SbTcIndex(u16),
}
impl<'a> IterableOpSbTcPoolBindGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoRequest::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoRequest",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    pub fn get_sb_pool_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoRequest::SbPoolType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoRequest",
            "SbPoolType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_tc_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoRequest::SbTcIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoRequest",
            "SbTcIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbTcPoolBindGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbTcPoolBindGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbTcPoolBindGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbTcPoolBindGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbTcPoolBindGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbTcPoolBindGetDoRequest<'a> {
    type Item = Result<OpSbTcPoolBindGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbTcPoolBindGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbTcPoolBindGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpSbTcPoolBindGetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbTcPoolBindGetDoRequest::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpSbTcPoolBindGetDoRequest::SbPoolType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                22u16 => OpSbTcPoolBindGetDoRequest::SbTcIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbTcPoolBindGetDoRequest",
            r#type.and_then(|t| OpSbTcPoolBindGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbTcPoolBindGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbTcPoolBindGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbTcPoolBindGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbTcPoolBindGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpSbTcPoolBindGetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpSbTcPoolBindGetDoRequest::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbTcPoolBindGetDoRequest::SbPoolType(val) => fmt.field(
                    "SbPoolType",
                    &FormatEnum(val.into(), SbPoolType::from_value),
                ),
                OpSbTcPoolBindGetDoRequest::SbTcIndex(val) => fmt.field("SbTcIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbTcPoolBindGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbTcPoolBindGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbTcPoolBindGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbTcPoolBindGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDoRequest::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDoRequest::SbPoolType(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolType", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDoRequest::SbTcIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbTcIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbTcPoolBindGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get shared buffer port-TC to pool bindings and threshold."]
pub struct PushOpSbTcPoolBindGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbTcPoolBindGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbTcPoolBindGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(25u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    pub fn push_sb_pool_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 18u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_tc_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 22u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbTcPoolBindGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get shared buffer port-TC to pool bindings and threshold."]
#[derive(Clone)]
pub enum OpSbTcPoolBindGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    SbIndex(u32),
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    SbPoolType(u8),
    SbTcIndex(u16),
}
impl<'a> IterableOpSbTcPoolBindGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoReply::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoReply",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    pub fn get_sb_pool_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoReply::SbPoolType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoReply",
            "SbPoolType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_tc_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindGetDoReply::SbTcIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindGetDoReply",
            "SbTcIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbTcPoolBindGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbTcPoolBindGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbTcPoolBindGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbTcPoolBindGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbTcPoolBindGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbTcPoolBindGetDoReply<'a> {
    type Item = Result<OpSbTcPoolBindGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbTcPoolBindGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbTcPoolBindGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpSbTcPoolBindGetDoReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbTcPoolBindGetDoReply::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpSbTcPoolBindGetDoReply::SbPoolType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                22u16 => OpSbTcPoolBindGetDoReply::SbTcIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbTcPoolBindGetDoReply",
            r#type.and_then(|t| OpSbTcPoolBindGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbTcPoolBindGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbTcPoolBindGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbTcPoolBindGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpSbTcPoolBindGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpSbTcPoolBindGetDoReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpSbTcPoolBindGetDoReply::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbTcPoolBindGetDoReply::SbPoolType(val) => fmt.field(
                    "SbPoolType",
                    &FormatEnum(val.into(), SbPoolType::from_value),
                ),
                OpSbTcPoolBindGetDoReply::SbTcIndex(val) => fmt.field("SbTcIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbTcPoolBindGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbTcPoolBindGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbTcPoolBindGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbTcPoolBindGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDoReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDoReply::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDoReply::SbPoolType(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolType", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindGetDoReply::SbTcIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbTcIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbTcPoolBindGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbTcPoolBindGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbTcPoolBindGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbTcPoolBindGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpSbTcPoolBindGetDoRequest<&mut Vec<u8>> {
        PushOpSbTcPoolBindGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbTcPoolBindGetDoRequest<RequestBuf<'r>> {
        PushOpSbTcPoolBindGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbTcPoolBindGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpSbTcPoolBindGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbTcPoolBindGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbTcPoolBindGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set shared buffer port-TC to pool bindings and threshold."]
pub struct PushOpSbTcPoolBindSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbTcPoolBindSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbTcPoolBindSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(24u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_pool_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 17u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    pub fn push_sb_pool_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 18u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_threshold(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 21u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_sb_tc_index(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 22u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbTcPoolBindSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set shared buffer port-TC to pool bindings and threshold."]
#[derive(Clone)]
pub enum OpSbTcPoolBindSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    SbIndex(u32),
    SbPoolIndex(u16),
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    SbPoolType(u8),
    SbThreshold(u32),
    SbTcIndex(u16),
}
impl<'a> IterableOpSbTcPoolBindSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindSetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindSetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindSetDoRequest::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindSetDoRequest",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_pool_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindSetDoRequest::SbPoolIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindSetDoRequest",
            "SbPoolIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"SbPoolType\" (enum)"]
    pub fn get_sb_pool_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindSetDoRequest::SbPoolType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindSetDoRequest",
            "SbPoolType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_threshold(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindSetDoRequest::SbThreshold(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindSetDoRequest",
            "SbThreshold",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_tc_index(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbTcPoolBindSetDoRequest::SbTcIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbTcPoolBindSetDoRequest",
            "SbTcIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbTcPoolBindSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbTcPoolBindSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbTcPoolBindSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbTcPoolBindSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbTcPoolBindSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbTcPoolBindSetDoRequest<'a> {
    type Item = Result<OpSbTcPoolBindSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbTcPoolBindSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbTcPoolBindSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpSbTcPoolBindSetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbTcPoolBindSetDoRequest::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                17u16 => OpSbTcPoolBindSetDoRequest::SbPoolIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                18u16 => OpSbTcPoolBindSetDoRequest::SbPoolType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                21u16 => OpSbTcPoolBindSetDoRequest::SbThreshold({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                22u16 => OpSbTcPoolBindSetDoRequest::SbTcIndex({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbTcPoolBindSetDoRequest",
            r#type.and_then(|t| OpSbTcPoolBindSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbTcPoolBindSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbTcPoolBindSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbTcPoolBindSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbTcPoolBindSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpSbTcPoolBindSetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpSbTcPoolBindSetDoRequest::SbIndex(val) => fmt.field("SbIndex", &val),
                OpSbTcPoolBindSetDoRequest::SbPoolIndex(val) => fmt.field("SbPoolIndex", &val),
                OpSbTcPoolBindSetDoRequest::SbPoolType(val) => fmt.field(
                    "SbPoolType",
                    &FormatEnum(val.into(), SbPoolType::from_value),
                ),
                OpSbTcPoolBindSetDoRequest::SbThreshold(val) => fmt.field("SbThreshold", &val),
                OpSbTcPoolBindSetDoRequest::SbTcIndex(val) => fmt.field("SbTcIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbTcPoolBindSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbTcPoolBindSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbTcPoolBindSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbTcPoolBindSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindSetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindSetDoRequest::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindSetDoRequest::SbPoolIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolIndex", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindSetDoRequest::SbPoolType(val) => {
                    if last_off == offset {
                        stack.push(("SbPoolType", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindSetDoRequest::SbThreshold(val) => {
                    if last_off == offset {
                        stack.push(("SbThreshold", last_off));
                        break;
                    }
                }
                OpSbTcPoolBindSetDoRequest::SbTcIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbTcIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbTcPoolBindSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set shared buffer port-TC to pool bindings and threshold."]
pub struct PushOpSbTcPoolBindSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbTcPoolBindSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbTcPoolBindSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(24u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpSbTcPoolBindSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set shared buffer port-TC to pool bindings and threshold."]
#[derive(Clone)]
pub enum OpSbTcPoolBindSetDoReply {}
impl<'a> IterableOpSbTcPoolBindSetDoReply<'a> {}
impl OpSbTcPoolBindSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbTcPoolBindSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbTcPoolBindSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbTcPoolBindSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbTcPoolBindSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbTcPoolBindSetDoReply<'a> {
    type Item = Result<OpSbTcPoolBindSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbTcPoolBindSetDoReply",
            r#type.and_then(|t| OpSbTcPoolBindSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpSbTcPoolBindSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbTcPoolBindSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpSbTcPoolBindSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbTcPoolBindSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbTcPoolBindSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbTcPoolBindSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbTcPoolBindSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbTcPoolBindSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpSbTcPoolBindSetDoRequest<&mut Vec<u8>> {
        PushOpSbTcPoolBindSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbTcPoolBindSetDoRequest<RequestBuf<'r>> {
        PushOpSbTcPoolBindSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbTcPoolBindSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpSbTcPoolBindSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbTcPoolBindSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbTcPoolBindSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Take occupancy snapshot of shared buffer."]
pub struct PushOpSbOccSnapshotDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbOccSnapshotDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbOccSnapshotDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(27u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbOccSnapshotDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Take occupancy snapshot of shared buffer."]
#[derive(Clone)]
pub enum OpSbOccSnapshotDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    SbIndex(u32),
}
impl<'a> IterableOpSbOccSnapshotDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbOccSnapshotDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbOccSnapshotDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbOccSnapshotDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbOccSnapshotDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbOccSnapshotDoRequest::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbOccSnapshotDoRequest",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbOccSnapshotDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbOccSnapshotDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbOccSnapshotDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbOccSnapshotDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbOccSnapshotDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbOccSnapshotDoRequest<'a> {
    type Item = Result<OpSbOccSnapshotDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbOccSnapshotDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbOccSnapshotDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbOccSnapshotDoRequest::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbOccSnapshotDoRequest",
            r#type.and_then(|t| OpSbOccSnapshotDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbOccSnapshotDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbOccSnapshotDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbOccSnapshotDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbOccSnapshotDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpSbOccSnapshotDoRequest::SbIndex(val) => fmt.field("SbIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbOccSnapshotDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbOccSnapshotDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbOccSnapshotDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbOccSnapshotDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbOccSnapshotDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbOccSnapshotDoRequest::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbOccSnapshotDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Take occupancy snapshot of shared buffer."]
pub struct PushOpSbOccSnapshotDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbOccSnapshotDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbOccSnapshotDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(27u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpSbOccSnapshotDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Take occupancy snapshot of shared buffer."]
#[derive(Clone)]
pub enum OpSbOccSnapshotDoReply {}
impl<'a> IterableOpSbOccSnapshotDoReply<'a> {}
impl OpSbOccSnapshotDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbOccSnapshotDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbOccSnapshotDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbOccSnapshotDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbOccSnapshotDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbOccSnapshotDoReply<'a> {
    type Item = Result<OpSbOccSnapshotDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbOccSnapshotDoReply",
            r#type.and_then(|t| OpSbOccSnapshotDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpSbOccSnapshotDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbOccSnapshotDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpSbOccSnapshotDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbOccSnapshotDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbOccSnapshotDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbOccSnapshotDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbOccSnapshotDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbOccSnapshotDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpSbOccSnapshotDoRequest<&mut Vec<u8>> {
        PushOpSbOccSnapshotDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbOccSnapshotDoRequest<RequestBuf<'r>> {
        PushOpSbOccSnapshotDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbOccSnapshotDoRequest<'_> {
    type ReplyType<'buf> = IterableOpSbOccSnapshotDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbOccSnapshotDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbOccSnapshotDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Clear occupancy watermarks of shared buffer."]
pub struct PushOpSbOccMaxClearDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbOccMaxClearDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbOccMaxClearDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(28u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_sb_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 11u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpSbOccMaxClearDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Clear occupancy watermarks of shared buffer."]
#[derive(Clone)]
pub enum OpSbOccMaxClearDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    SbIndex(u32),
}
impl<'a> IterableOpSbOccMaxClearDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbOccMaxClearDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbOccMaxClearDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbOccMaxClearDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbOccMaxClearDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_sb_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSbOccMaxClearDoRequest::SbIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSbOccMaxClearDoRequest",
            "SbIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSbOccMaxClearDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbOccMaxClearDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbOccMaxClearDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbOccMaxClearDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbOccMaxClearDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbOccMaxClearDoRequest<'a> {
    type Item = Result<OpSbOccMaxClearDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSbOccMaxClearDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSbOccMaxClearDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                11u16 => OpSbOccMaxClearDoRequest::SbIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbOccMaxClearDoRequest",
            r#type.and_then(|t| OpSbOccMaxClearDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSbOccMaxClearDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbOccMaxClearDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSbOccMaxClearDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpSbOccMaxClearDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpSbOccMaxClearDoRequest::SbIndex(val) => fmt.field("SbIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSbOccMaxClearDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbOccMaxClearDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbOccMaxClearDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSbOccMaxClearDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSbOccMaxClearDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSbOccMaxClearDoRequest::SbIndex(val) => {
                    if last_off == offset {
                        stack.push(("SbIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSbOccMaxClearDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Clear occupancy watermarks of shared buffer."]
pub struct PushOpSbOccMaxClearDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSbOccMaxClearDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSbOccMaxClearDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(28u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpSbOccMaxClearDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Clear occupancy watermarks of shared buffer."]
#[derive(Clone)]
pub enum OpSbOccMaxClearDoReply {}
impl<'a> IterableOpSbOccMaxClearDoReply<'a> {}
impl OpSbOccMaxClearDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSbOccMaxClearDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSbOccMaxClearDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSbOccMaxClearDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSbOccMaxClearDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSbOccMaxClearDoReply<'a> {
    type Item = Result<OpSbOccMaxClearDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSbOccMaxClearDoReply",
            r#type.and_then(|t| OpSbOccMaxClearDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpSbOccMaxClearDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSbOccMaxClearDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpSbOccMaxClearDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSbOccMaxClearDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSbOccMaxClearDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSbOccMaxClearDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSbOccMaxClearDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSbOccMaxClearDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpSbOccMaxClearDoRequest<&mut Vec<u8>> {
        PushOpSbOccMaxClearDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSbOccMaxClearDoRequest<RequestBuf<'r>> {
        PushOpSbOccMaxClearDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSbOccMaxClearDoRequest<'_> {
    type ReplyType<'buf> = IterableOpSbOccMaxClearDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSbOccMaxClearDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSbOccMaxClearDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get eswitch attributes."]
pub struct PushOpEswitchGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpEswitchGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpEswitchGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(29u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpEswitchGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get eswitch attributes."]
#[derive(Clone)]
pub enum OpEswitchGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpEswitchGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpEswitchGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpEswitchGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpEswitchGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpEswitchGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpEswitchGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpEswitchGetDoRequest<'a> {
    type Item = Result<OpEswitchGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpEswitchGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpEswitchGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpEswitchGetDoRequest",
            r#type.and_then(|t| OpEswitchGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpEswitchGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpEswitchGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpEswitchGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpEswitchGetDoRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpEswitchGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpEswitchGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpEswitchGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpEswitchGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpEswitchGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpEswitchGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get eswitch attributes."]
pub struct PushOpEswitchGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpEswitchGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpEswitchGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(29u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Associated type: \"EswitchMode\" (enum)"]
    pub fn push_eswitch_mode(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 25u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"EswitchInlineMode\" (enum)"]
    pub fn push_eswitch_inline_mode(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 26u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"EswitchEncapMode\" (enum)"]
    pub fn push_eswitch_encap_mode(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 62u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpEswitchGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get eswitch attributes."]
#[derive(Clone)]
pub enum OpEswitchGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    #[doc = "Associated type: \"EswitchMode\" (enum)"]
    EswitchMode(u16),
    #[doc = "Associated type: \"EswitchInlineMode\" (enum)"]
    EswitchInlineMode(u8),
    #[doc = "Associated type: \"EswitchEncapMode\" (enum)"]
    EswitchEncapMode(u8),
}
impl<'a> IterableOpEswitchGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"EswitchMode\" (enum)"]
    pub fn get_eswitch_mode(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchGetDoReply::EswitchMode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchGetDoReply",
            "EswitchMode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"EswitchInlineMode\" (enum)"]
    pub fn get_eswitch_inline_mode(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchGetDoReply::EswitchInlineMode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchGetDoReply",
            "EswitchInlineMode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"EswitchEncapMode\" (enum)"]
    pub fn get_eswitch_encap_mode(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchGetDoReply::EswitchEncapMode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchGetDoReply",
            "EswitchEncapMode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpEswitchGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpEswitchGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpEswitchGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpEswitchGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpEswitchGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpEswitchGetDoReply<'a> {
    type Item = Result<OpEswitchGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpEswitchGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpEswitchGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                25u16 => OpEswitchGetDoReply::EswitchMode({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                26u16 => OpEswitchGetDoReply::EswitchInlineMode({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                62u16 => OpEswitchGetDoReply::EswitchEncapMode({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpEswitchGetDoReply",
            r#type.and_then(|t| OpEswitchGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpEswitchGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpEswitchGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpEswitchGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpEswitchGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpEswitchGetDoReply::EswitchMode(val) => fmt.field(
                    "EswitchMode",
                    &FormatEnum(val.into(), EswitchMode::from_value),
                ),
                OpEswitchGetDoReply::EswitchInlineMode(val) => fmt.field(
                    "EswitchInlineMode",
                    &FormatEnum(val.into(), EswitchInlineMode::from_value),
                ),
                OpEswitchGetDoReply::EswitchEncapMode(val) => fmt.field(
                    "EswitchEncapMode",
                    &FormatEnum(val.into(), EswitchEncapMode::from_value),
                ),
            };
        }
        fmt.finish()
    }
}
impl IterableOpEswitchGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpEswitchGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpEswitchGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpEswitchGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpEswitchGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpEswitchGetDoReply::EswitchMode(val) => {
                    if last_off == offset {
                        stack.push(("EswitchMode", last_off));
                        break;
                    }
                }
                OpEswitchGetDoReply::EswitchInlineMode(val) => {
                    if last_off == offset {
                        stack.push(("EswitchInlineMode", last_off));
                        break;
                    }
                }
                OpEswitchGetDoReply::EswitchEncapMode(val) => {
                    if last_off == offset {
                        stack.push(("EswitchEncapMode", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpEswitchGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpEswitchGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpEswitchGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpEswitchGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpEswitchGetDoRequest<&mut Vec<u8>> {
        PushOpEswitchGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpEswitchGetDoRequest<RequestBuf<'r>> {
        PushOpEswitchGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpEswitchGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpEswitchGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpEswitchGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpEswitchGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set eswitch attributes."]
pub struct PushOpEswitchSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpEswitchSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpEswitchSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(30u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Associated type: \"EswitchMode\" (enum)"]
    pub fn push_eswitch_mode(mut self, value: u16) -> Self {
        push_header(self.as_rec_mut(), 25u16, 2 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"EswitchInlineMode\" (enum)"]
    pub fn push_eswitch_inline_mode(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 26u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"EswitchEncapMode\" (enum)"]
    pub fn push_eswitch_encap_mode(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 62u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpEswitchSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set eswitch attributes."]
#[derive(Clone)]
pub enum OpEswitchSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    #[doc = "Associated type: \"EswitchMode\" (enum)"]
    EswitchMode(u16),
    #[doc = "Associated type: \"EswitchInlineMode\" (enum)"]
    EswitchInlineMode(u8),
    #[doc = "Associated type: \"EswitchEncapMode\" (enum)"]
    EswitchEncapMode(u8),
}
impl<'a> IterableOpEswitchSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"EswitchMode\" (enum)"]
    pub fn get_eswitch_mode(&self) -> Result<u16, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchSetDoRequest::EswitchMode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchSetDoRequest",
            "EswitchMode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"EswitchInlineMode\" (enum)"]
    pub fn get_eswitch_inline_mode(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchSetDoRequest::EswitchInlineMode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchSetDoRequest",
            "EswitchInlineMode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"EswitchEncapMode\" (enum)"]
    pub fn get_eswitch_encap_mode(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpEswitchSetDoRequest::EswitchEncapMode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpEswitchSetDoRequest",
            "EswitchEncapMode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpEswitchSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpEswitchSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpEswitchSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpEswitchSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpEswitchSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpEswitchSetDoRequest<'a> {
    type Item = Result<OpEswitchSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpEswitchSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpEswitchSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                25u16 => OpEswitchSetDoRequest::EswitchMode({
                    let res = parse_u16(next);
                    let Some(val) = res else { break };
                    val
                }),
                26u16 => OpEswitchSetDoRequest::EswitchInlineMode({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                62u16 => OpEswitchSetDoRequest::EswitchEncapMode({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpEswitchSetDoRequest",
            r#type.and_then(|t| OpEswitchSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpEswitchSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpEswitchSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpEswitchSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpEswitchSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpEswitchSetDoRequest::EswitchMode(val) => fmt.field(
                    "EswitchMode",
                    &FormatEnum(val.into(), EswitchMode::from_value),
                ),
                OpEswitchSetDoRequest::EswitchInlineMode(val) => fmt.field(
                    "EswitchInlineMode",
                    &FormatEnum(val.into(), EswitchInlineMode::from_value),
                ),
                OpEswitchSetDoRequest::EswitchEncapMode(val) => fmt.field(
                    "EswitchEncapMode",
                    &FormatEnum(val.into(), EswitchEncapMode::from_value),
                ),
            };
        }
        fmt.finish()
    }
}
impl IterableOpEswitchSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpEswitchSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpEswitchSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpEswitchSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpEswitchSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpEswitchSetDoRequest::EswitchMode(val) => {
                    if last_off == offset {
                        stack.push(("EswitchMode", last_off));
                        break;
                    }
                }
                OpEswitchSetDoRequest::EswitchInlineMode(val) => {
                    if last_off == offset {
                        stack.push(("EswitchInlineMode", last_off));
                        break;
                    }
                }
                OpEswitchSetDoRequest::EswitchEncapMode(val) => {
                    if last_off == offset {
                        stack.push(("EswitchEncapMode", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpEswitchSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set eswitch attributes."]
pub struct PushOpEswitchSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpEswitchSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpEswitchSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(30u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpEswitchSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set eswitch attributes."]
#[derive(Clone)]
pub enum OpEswitchSetDoReply {}
impl<'a> IterableOpEswitchSetDoReply<'a> {}
impl OpEswitchSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpEswitchSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpEswitchSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpEswitchSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpEswitchSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpEswitchSetDoReply<'a> {
    type Item = Result<OpEswitchSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpEswitchSetDoReply",
            r#type.and_then(|t| OpEswitchSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpEswitchSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpEswitchSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpEswitchSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpEswitchSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpEswitchSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpEswitchSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpEswitchSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpEswitchSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpEswitchSetDoRequest<&mut Vec<u8>> {
        PushOpEswitchSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpEswitchSetDoRequest<RequestBuf<'r>> {
        PushOpEswitchSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpEswitchSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpEswitchSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpEswitchSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpEswitchSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get dpipe table attributes."]
pub struct PushOpDpipeTableGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDpipeTableGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDpipeTableGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(31u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dpipe_table_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            29u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dpipe_table_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 29u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDpipeTableGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get dpipe table attributes."]
#[derive(Clone)]
pub enum OpDpipeTableGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    DpipeTableName(&'a CStr),
}
impl<'a> IterableOpDpipeTableGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeTableGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeTableGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeTableGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeTableGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeTableGetDoRequest::DpipeTableName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeTableGetDoRequest",
            "DpipeTableName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpDpipeTableGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpDpipeTableGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpDpipeTableGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDpipeTableGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDpipeTableGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDpipeTableGetDoRequest<'a> {
    type Item = Result<OpDpipeTableGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDpipeTableGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDpipeTableGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                29u16 => OpDpipeTableGetDoRequest::DpipeTableName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDpipeTableGetDoRequest",
            r#type.and_then(|t| OpDpipeTableGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDpipeTableGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDpipeTableGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDpipeTableGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpDpipeTableGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpDpipeTableGetDoRequest::DpipeTableName(val) => fmt.field("DpipeTableName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDpipeTableGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpDpipeTableGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDpipeTableGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDpipeTableGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpDpipeTableGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpDpipeTableGetDoRequest::DpipeTableName(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDpipeTableGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get dpipe table attributes."]
pub struct PushOpDpipeTableGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDpipeTableGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDpipeTableGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(31u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_dpipe_tables(mut self) -> PushDlDpipeTables<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 27u16);
        PushDlDpipeTables {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpDpipeTableGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get dpipe table attributes."]
#[derive(Clone)]
pub enum OpDpipeTableGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    DpipeTables(IterableDlDpipeTables<'a>),
}
impl<'a> IterableOpDpipeTableGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeTableGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeTableGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeTableGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeTableGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_tables(&self) -> Result<IterableDlDpipeTables<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeTableGetDoReply::DpipeTables(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeTableGetDoReply",
            "DpipeTables",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpDpipeTableGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpDpipeTableGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpDpipeTableGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDpipeTableGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDpipeTableGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDpipeTableGetDoReply<'a> {
    type Item = Result<OpDpipeTableGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDpipeTableGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDpipeTableGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                27u16 => OpDpipeTableGetDoReply::DpipeTables({
                    let res = Some(IterableDlDpipeTables::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDpipeTableGetDoReply",
            r#type.and_then(|t| OpDpipeTableGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDpipeTableGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDpipeTableGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDpipeTableGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpDpipeTableGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpDpipeTableGetDoReply::DpipeTables(val) => fmt.field("DpipeTables", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDpipeTableGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpDpipeTableGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDpipeTableGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDpipeTableGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpDpipeTableGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpDpipeTableGetDoReply::DpipeTables(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDpipeTableGetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDpipeTableGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDpipeTableGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpDpipeTableGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDpipeTableGetDoRequest<&mut Vec<u8>> {
        PushOpDpipeTableGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDpipeTableGetDoRequest<RequestBuf<'r>> {
        PushOpDpipeTableGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDpipeTableGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpDpipeTableGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDpipeTableGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDpipeTableGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get dpipe entries attributes."]
pub struct PushOpDpipeEntriesGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDpipeEntriesGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDpipeEntriesGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(32u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dpipe_table_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            29u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dpipe_table_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 29u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDpipeEntriesGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get dpipe entries attributes."]
#[derive(Clone)]
pub enum OpDpipeEntriesGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    DpipeTableName(&'a CStr),
}
impl<'a> IterableOpDpipeEntriesGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeEntriesGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeEntriesGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeEntriesGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeEntriesGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeEntriesGetDoRequest::DpipeTableName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeEntriesGetDoRequest",
            "DpipeTableName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpDpipeEntriesGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpDpipeEntriesGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpDpipeEntriesGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDpipeEntriesGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDpipeEntriesGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDpipeEntriesGetDoRequest<'a> {
    type Item = Result<OpDpipeEntriesGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDpipeEntriesGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDpipeEntriesGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                29u16 => OpDpipeEntriesGetDoRequest::DpipeTableName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDpipeEntriesGetDoRequest",
            r#type.and_then(|t| OpDpipeEntriesGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDpipeEntriesGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDpipeEntriesGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDpipeEntriesGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpDpipeEntriesGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpDpipeEntriesGetDoRequest::DpipeTableName(val) => {
                    fmt.field("DpipeTableName", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpDpipeEntriesGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpDpipeEntriesGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDpipeEntriesGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDpipeEntriesGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpDpipeEntriesGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpDpipeEntriesGetDoRequest::DpipeTableName(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDpipeEntriesGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get dpipe entries attributes."]
pub struct PushOpDpipeEntriesGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDpipeEntriesGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDpipeEntriesGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(32u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_dpipe_entries(mut self) -> PushDlDpipeEntries<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 34u16);
        PushDlDpipeEntries {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpDpipeEntriesGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get dpipe entries attributes."]
#[derive(Clone)]
pub enum OpDpipeEntriesGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    DpipeEntries(IterableDlDpipeEntries<'a>),
}
impl<'a> IterableOpDpipeEntriesGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeEntriesGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeEntriesGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeEntriesGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeEntriesGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_entries(&self) -> Result<IterableDlDpipeEntries<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeEntriesGetDoReply::DpipeEntries(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeEntriesGetDoReply",
            "DpipeEntries",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpDpipeEntriesGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpDpipeEntriesGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpDpipeEntriesGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDpipeEntriesGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDpipeEntriesGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDpipeEntriesGetDoReply<'a> {
    type Item = Result<OpDpipeEntriesGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDpipeEntriesGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDpipeEntriesGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                34u16 => OpDpipeEntriesGetDoReply::DpipeEntries({
                    let res = Some(IterableDlDpipeEntries::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDpipeEntriesGetDoReply",
            r#type.and_then(|t| OpDpipeEntriesGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDpipeEntriesGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDpipeEntriesGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDpipeEntriesGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpDpipeEntriesGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpDpipeEntriesGetDoReply::DpipeEntries(val) => fmt.field("DpipeEntries", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDpipeEntriesGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpDpipeEntriesGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDpipeEntriesGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDpipeEntriesGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpDpipeEntriesGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpDpipeEntriesGetDoReply::DpipeEntries(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDpipeEntriesGetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDpipeEntriesGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDpipeEntriesGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpDpipeEntriesGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDpipeEntriesGetDoRequest<&mut Vec<u8>> {
        PushOpDpipeEntriesGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDpipeEntriesGetDoRequest<RequestBuf<'r>> {
        PushOpDpipeEntriesGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDpipeEntriesGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpDpipeEntriesGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDpipeEntriesGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDpipeEntriesGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get dpipe headers attributes."]
pub struct PushOpDpipeHeadersGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDpipeHeadersGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDpipeHeadersGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(33u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpDpipeHeadersGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get dpipe headers attributes."]
#[derive(Clone)]
pub enum OpDpipeHeadersGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpDpipeHeadersGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeHeadersGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeHeadersGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeHeadersGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeHeadersGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpDpipeHeadersGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpDpipeHeadersGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpDpipeHeadersGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDpipeHeadersGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDpipeHeadersGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDpipeHeadersGetDoRequest<'a> {
    type Item = Result<OpDpipeHeadersGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDpipeHeadersGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDpipeHeadersGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDpipeHeadersGetDoRequest",
            r#type.and_then(|t| OpDpipeHeadersGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDpipeHeadersGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDpipeHeadersGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDpipeHeadersGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpDpipeHeadersGetDoRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDpipeHeadersGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpDpipeHeadersGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDpipeHeadersGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDpipeHeadersGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpDpipeHeadersGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDpipeHeadersGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get dpipe headers attributes."]
pub struct PushOpDpipeHeadersGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDpipeHeadersGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDpipeHeadersGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(33u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_dpipe_headers(mut self) -> PushDlDpipeHeaders<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 49u16);
        PushDlDpipeHeaders {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpDpipeHeadersGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get dpipe headers attributes."]
#[derive(Clone)]
pub enum OpDpipeHeadersGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    DpipeHeaders(IterableDlDpipeHeaders<'a>),
}
impl<'a> IterableOpDpipeHeadersGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeHeadersGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeHeadersGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeHeadersGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeHeadersGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_headers(&self) -> Result<IterableDlDpipeHeaders<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeHeadersGetDoReply::DpipeHeaders(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeHeadersGetDoReply",
            "DpipeHeaders",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpDpipeHeadersGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpDpipeHeadersGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpDpipeHeadersGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDpipeHeadersGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDpipeHeadersGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDpipeHeadersGetDoReply<'a> {
    type Item = Result<OpDpipeHeadersGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDpipeHeadersGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDpipeHeadersGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                49u16 => OpDpipeHeadersGetDoReply::DpipeHeaders({
                    let res = Some(IterableDlDpipeHeaders::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDpipeHeadersGetDoReply",
            r#type.and_then(|t| OpDpipeHeadersGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDpipeHeadersGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDpipeHeadersGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDpipeHeadersGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpDpipeHeadersGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpDpipeHeadersGetDoReply::DpipeHeaders(val) => fmt.field("DpipeHeaders", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpDpipeHeadersGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpDpipeHeadersGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDpipeHeadersGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDpipeHeadersGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpDpipeHeadersGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpDpipeHeadersGetDoReply::DpipeHeaders(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDpipeHeadersGetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpDpipeHeadersGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDpipeHeadersGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpDpipeHeadersGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDpipeHeadersGetDoRequest<&mut Vec<u8>> {
        PushOpDpipeHeadersGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDpipeHeadersGetDoRequest<RequestBuf<'r>> {
        PushOpDpipeHeadersGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDpipeHeadersGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpDpipeHeadersGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDpipeHeadersGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDpipeHeadersGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set dpipe counter attributes."]
pub struct PushOpDpipeTableCountersSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDpipeTableCountersSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDpipeTableCountersSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(34u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dpipe_table_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            29u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dpipe_table_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 29u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dpipe_table_counters_enabled(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 33u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpDpipeTableCountersSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set dpipe counter attributes."]
#[derive(Clone)]
pub enum OpDpipeTableCountersSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    DpipeTableName(&'a CStr),
    DpipeTableCountersEnabled(u8),
}
impl<'a> IterableOpDpipeTableCountersSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeTableCountersSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeTableCountersSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeTableCountersSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeTableCountersSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeTableCountersSetDoRequest::DpipeTableName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeTableCountersSetDoRequest",
            "DpipeTableName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dpipe_table_counters_enabled(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpDpipeTableCountersSetDoRequest::DpipeTableCountersEnabled(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpDpipeTableCountersSetDoRequest",
            "DpipeTableCountersEnabled",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpDpipeTableCountersSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpDpipeTableCountersSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpDpipeTableCountersSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDpipeTableCountersSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDpipeTableCountersSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDpipeTableCountersSetDoRequest<'a> {
    type Item = Result<OpDpipeTableCountersSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpDpipeTableCountersSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpDpipeTableCountersSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                29u16 => OpDpipeTableCountersSetDoRequest::DpipeTableName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                33u16 => OpDpipeTableCountersSetDoRequest::DpipeTableCountersEnabled({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDpipeTableCountersSetDoRequest",
            r#type.and_then(|t| OpDpipeTableCountersSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpDpipeTableCountersSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDpipeTableCountersSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpDpipeTableCountersSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpDpipeTableCountersSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpDpipeTableCountersSetDoRequest::DpipeTableName(val) => {
                    fmt.field("DpipeTableName", &val)
                }
                OpDpipeTableCountersSetDoRequest::DpipeTableCountersEnabled(val) => {
                    fmt.field("DpipeTableCountersEnabled", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpDpipeTableCountersSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpDpipeTableCountersSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDpipeTableCountersSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpDpipeTableCountersSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpDpipeTableCountersSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpDpipeTableCountersSetDoRequest::DpipeTableName(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableName", last_off));
                        break;
                    }
                }
                OpDpipeTableCountersSetDoRequest::DpipeTableCountersEnabled(val) => {
                    if last_off == offset {
                        stack.push(("DpipeTableCountersEnabled", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpDpipeTableCountersSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set dpipe counter attributes."]
pub struct PushOpDpipeTableCountersSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpDpipeTableCountersSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpDpipeTableCountersSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(34u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpDpipeTableCountersSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set dpipe counter attributes."]
#[derive(Clone)]
pub enum OpDpipeTableCountersSetDoReply {}
impl<'a> IterableOpDpipeTableCountersSetDoReply<'a> {}
impl OpDpipeTableCountersSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpDpipeTableCountersSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpDpipeTableCountersSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpDpipeTableCountersSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpDpipeTableCountersSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpDpipeTableCountersSetDoReply<'a> {
    type Item = Result<OpDpipeTableCountersSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpDpipeTableCountersSetDoReply",
            r#type.and_then(|t| OpDpipeTableCountersSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpDpipeTableCountersSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpDpipeTableCountersSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpDpipeTableCountersSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpDpipeTableCountersSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpDpipeTableCountersSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpDpipeTableCountersSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpDpipeTableCountersSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpDpipeTableCountersSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpDpipeTableCountersSetDoRequest<&mut Vec<u8>> {
        PushOpDpipeTableCountersSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpDpipeTableCountersSetDoRequest<RequestBuf<'r>> {
        PushOpDpipeTableCountersSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpDpipeTableCountersSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpDpipeTableCountersSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpDpipeTableCountersSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpDpipeTableCountersSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set resource attributes."]
pub struct PushOpResourceSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpResourceSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpResourceSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(35u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_resource_id(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 66u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_resource_size(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 67u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpResourceSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set resource attributes."]
#[derive(Clone)]
pub enum OpResourceSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    ResourceId(u64),
    ResourceSize(u64),
}
impl<'a> IterableOpResourceSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpResourceSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpResourceSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpResourceSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpResourceSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_id(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpResourceSetDoRequest::ResourceId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpResourceSetDoRequest",
            "ResourceId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_size(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpResourceSetDoRequest::ResourceSize(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpResourceSetDoRequest",
            "ResourceSize",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpResourceSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpResourceSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpResourceSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpResourceSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpResourceSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpResourceSetDoRequest<'a> {
    type Item = Result<OpResourceSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpResourceSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpResourceSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                66u16 => OpResourceSetDoRequest::ResourceId({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                67u16 => OpResourceSetDoRequest::ResourceSize({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpResourceSetDoRequest",
            r#type.and_then(|t| OpResourceSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpResourceSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpResourceSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpResourceSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpResourceSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpResourceSetDoRequest::ResourceId(val) => fmt.field("ResourceId", &val),
                OpResourceSetDoRequest::ResourceSize(val) => fmt.field("ResourceSize", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpResourceSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpResourceSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpResourceSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpResourceSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpResourceSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpResourceSetDoRequest::ResourceId(val) => {
                    if last_off == offset {
                        stack.push(("ResourceId", last_off));
                        break;
                    }
                }
                OpResourceSetDoRequest::ResourceSize(val) => {
                    if last_off == offset {
                        stack.push(("ResourceSize", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpResourceSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set resource attributes."]
pub struct PushOpResourceSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpResourceSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpResourceSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(35u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpResourceSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set resource attributes."]
#[derive(Clone)]
pub enum OpResourceSetDoReply {}
impl<'a> IterableOpResourceSetDoReply<'a> {}
impl OpResourceSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpResourceSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpResourceSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpResourceSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpResourceSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpResourceSetDoReply<'a> {
    type Item = Result<OpResourceSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpResourceSetDoReply",
            r#type.and_then(|t| OpResourceSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpResourceSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpResourceSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpResourceSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpResourceSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpResourceSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpResourceSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpResourceSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpResourceSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpResourceSetDoRequest<&mut Vec<u8>> {
        PushOpResourceSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpResourceSetDoRequest<RequestBuf<'r>> {
        PushOpResourceSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpResourceSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpResourceSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpResourceSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpResourceSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get resource attributes."]
pub struct PushOpResourceDumpDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpResourceDumpDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpResourceDumpDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(36u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpResourceDumpDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get resource attributes."]
#[derive(Clone)]
pub enum OpResourceDumpDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpResourceDumpDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpResourceDumpDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpResourceDumpDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpResourceDumpDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpResourceDumpDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpResourceDumpDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpResourceDumpDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpResourceDumpDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpResourceDumpDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpResourceDumpDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpResourceDumpDoRequest<'a> {
    type Item = Result<OpResourceDumpDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpResourceDumpDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpResourceDumpDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpResourceDumpDoRequest",
            r#type.and_then(|t| OpResourceDumpDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpResourceDumpDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpResourceDumpDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpResourceDumpDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpResourceDumpDoRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpResourceDumpDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpResourceDumpDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpResourceDumpDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpResourceDumpDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpResourceDumpDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpResourceDumpDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get resource attributes."]
pub struct PushOpResourceDumpDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpResourceDumpDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpResourceDumpDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(36u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_resource_list(mut self) -> PushDlResourceList<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 63u16);
        PushDlResourceList {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpResourceDumpDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get resource attributes."]
#[derive(Clone)]
pub enum OpResourceDumpDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    ResourceList(IterableDlResourceList<'a>),
}
impl<'a> IterableOpResourceDumpDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpResourceDumpDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpResourceDumpDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpResourceDumpDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpResourceDumpDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_resource_list(&self) -> Result<IterableDlResourceList<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpResourceDumpDoReply::ResourceList(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpResourceDumpDoReply",
            "ResourceList",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpResourceDumpDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpResourceDumpDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpResourceDumpDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpResourceDumpDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpResourceDumpDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpResourceDumpDoReply<'a> {
    type Item = Result<OpResourceDumpDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpResourceDumpDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpResourceDumpDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                63u16 => OpResourceDumpDoReply::ResourceList({
                    let res = Some(IterableDlResourceList::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpResourceDumpDoReply",
            r#type.and_then(|t| OpResourceDumpDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpResourceDumpDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpResourceDumpDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpResourceDumpDoReply::BusName(val) => fmt.field("BusName", &val),
                OpResourceDumpDoReply::DevName(val) => fmt.field("DevName", &val),
                OpResourceDumpDoReply::ResourceList(val) => fmt.field("ResourceList", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpResourceDumpDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpResourceDumpDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpResourceDumpDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpResourceDumpDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpResourceDumpDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpResourceDumpDoReply::ResourceList(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpResourceDumpDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpResourceDumpDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpResourceDumpDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpResourceDumpDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpResourceDumpDoRequest<&mut Vec<u8>> {
        PushOpResourceDumpDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpResourceDumpDoRequest<RequestBuf<'r>> {
        PushOpResourceDumpDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpResourceDumpDoRequest<'_> {
    type ReplyType<'buf> = IterableOpResourceDumpDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpResourceDumpDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpResourceDumpDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Reload devlink."]
pub struct PushOpReloadDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpReloadDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpReloadDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(37u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_netns_fd(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 138u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_netns_pid(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 139u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_netns_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 140u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"ReloadAction\" (enum)"]
    pub fn push_reload_action(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 153u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    pub fn push_reload_limits(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 155u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
}
impl<Prev: Rec> Drop for PushOpReloadDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Reload devlink."]
#[derive(Clone)]
pub enum OpReloadDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    NetnsFd(u32),
    NetnsPid(u32),
    NetnsId(u32),
    #[doc = "Associated type: \"ReloadAction\" (enum)"]
    ReloadAction(u8),
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    ReloadLimits(PushBuiltinBitfield32),
}
impl<'a> IterableOpReloadDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpReloadDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpReloadDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpReloadDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpReloadDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_netns_fd(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpReloadDoRequest::NetnsFd(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpReloadDoRequest",
            "NetnsFd",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_netns_pid(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpReloadDoRequest::NetnsPid(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpReloadDoRequest",
            "NetnsPid",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_netns_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpReloadDoRequest::NetnsId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpReloadDoRequest",
            "NetnsId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"ReloadAction\" (enum)"]
    pub fn get_reload_action(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpReloadDoRequest::ReloadAction(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpReloadDoRequest",
            "ReloadAction",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    pub fn get_reload_limits(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpReloadDoRequest::ReloadLimits(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpReloadDoRequest",
            "ReloadLimits",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpReloadDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpReloadDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpReloadDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpReloadDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpReloadDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpReloadDoRequest<'a> {
    type Item = Result<OpReloadDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpReloadDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpReloadDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                138u16 => OpReloadDoRequest::NetnsFd({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                139u16 => OpReloadDoRequest::NetnsPid({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                140u16 => OpReloadDoRequest::NetnsId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                153u16 => OpReloadDoRequest::ReloadAction({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                155u16 => OpReloadDoRequest::ReloadLimits({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpReloadDoRequest",
            r#type.and_then(|t| OpReloadDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpReloadDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpReloadDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpReloadDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpReloadDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpReloadDoRequest::NetnsFd(val) => fmt.field("NetnsFd", &val),
                OpReloadDoRequest::NetnsPid(val) => fmt.field("NetnsPid", &val),
                OpReloadDoRequest::NetnsId(val) => fmt.field("NetnsId", &val),
                OpReloadDoRequest::ReloadAction(val) => fmt.field(
                    "ReloadAction",
                    &FormatEnum(val.into(), ReloadAction::from_value),
                ),
                OpReloadDoRequest::ReloadLimits(val) => fmt.field(
                    "ReloadLimits",
                    &FormatFlags(val.value().into(), |val| {
                        ReloadAction::from_value(val.trailing_zeros().into())
                    }),
                ),
            };
        }
        fmt.finish()
    }
}
impl IterableOpReloadDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpReloadDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpReloadDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpReloadDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpReloadDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpReloadDoRequest::NetnsFd(val) => {
                    if last_off == offset {
                        stack.push(("NetnsFd", last_off));
                        break;
                    }
                }
                OpReloadDoRequest::NetnsPid(val) => {
                    if last_off == offset {
                        stack.push(("NetnsPid", last_off));
                        break;
                    }
                }
                OpReloadDoRequest::NetnsId(val) => {
                    if last_off == offset {
                        stack.push(("NetnsId", last_off));
                        break;
                    }
                }
                OpReloadDoRequest::ReloadAction(val) => {
                    if last_off == offset {
                        stack.push(("ReloadAction", last_off));
                        break;
                    }
                }
                OpReloadDoRequest::ReloadLimits(val) => {
                    if last_off == offset {
                        stack.push(("ReloadLimits", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpReloadDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Reload devlink."]
pub struct PushOpReloadDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpReloadDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpReloadDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(37u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    pub fn push_reload_actions_performed(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 154u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
}
impl<Prev: Rec> Drop for PushOpReloadDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Reload devlink."]
#[derive(Clone)]
pub enum OpReloadDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    ReloadActionsPerformed(PushBuiltinBitfield32),
}
impl<'a> IterableOpReloadDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpReloadDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpReloadDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpReloadDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpReloadDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"ReloadAction\" (1 bit per enumeration)"]
    pub fn get_reload_actions_performed(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpReloadDoReply::ReloadActionsPerformed(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpReloadDoReply",
            "ReloadActionsPerformed",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpReloadDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpReloadDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpReloadDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpReloadDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpReloadDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpReloadDoReply<'a> {
    type Item = Result<OpReloadDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpReloadDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpReloadDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                154u16 => OpReloadDoReply::ReloadActionsPerformed({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpReloadDoReply",
            r#type.and_then(|t| OpReloadDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpReloadDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpReloadDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpReloadDoReply::BusName(val) => fmt.field("BusName", &val),
                OpReloadDoReply::DevName(val) => fmt.field("DevName", &val),
                OpReloadDoReply::ReloadActionsPerformed(val) => fmt.field(
                    "ReloadActionsPerformed",
                    &FormatFlags(val.value().into(), |val| {
                        ReloadAction::from_value(val.trailing_zeros().into())
                    }),
                ),
            };
        }
        fmt.finish()
    }
}
impl IterableOpReloadDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpReloadDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpReloadDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpReloadDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpReloadDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpReloadDoReply::ReloadActionsPerformed(val) => {
                    if last_off == offset {
                        stack.push(("ReloadActionsPerformed", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpReloadDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpReloadDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpReloadDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpReloadDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpReloadDoRequest<&mut Vec<u8>> {
        PushOpReloadDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpReloadDoRequest<RequestBuf<'r>> {
        PushOpReloadDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpReloadDoRequest<'_> {
    type ReplyType<'buf> = IterableOpReloadDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpReloadDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpReloadDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get param instances."]
pub struct PushOpParamGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpParamGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpParamGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(38u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpParamGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get param instances."]
#[derive(Clone)]
pub enum OpParamGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpParamGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpParamGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpParamGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpParamGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpParamGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpParamGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpParamGetDumpRequest<'a> {
    type Item = Result<OpParamGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpParamGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpParamGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpParamGetDumpRequest",
            r#type.and_then(|t| OpParamGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpParamGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpParamGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpParamGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpParamGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpParamGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpParamGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpParamGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpParamGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpParamGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpParamGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get param instances."]
pub struct PushOpParamGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpParamGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpParamGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(38u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_param_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            81u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_param_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 81u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpParamGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get param instances."]
#[derive(Clone)]
pub enum OpParamGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    ParamName(&'a CStr),
}
impl<'a> IterableOpParamGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_param_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamGetDumpReply::ParamName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamGetDumpReply",
            "ParamName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpParamGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpParamGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpParamGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpParamGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpParamGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpParamGetDumpReply<'a> {
    type Item = Result<OpParamGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpParamGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpParamGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                81u16 => OpParamGetDumpReply::ParamName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpParamGetDumpReply",
            r#type.and_then(|t| OpParamGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpParamGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpParamGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpParamGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpParamGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpParamGetDumpReply::ParamName(val) => fmt.field("ParamName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpParamGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpParamGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpParamGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpParamGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpParamGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpParamGetDumpReply::ParamName(val) => {
                    if last_off == offset {
                        stack.push(("ParamName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpParamGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpParamGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpParamGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpParamGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpParamGetDumpRequest<&mut Vec<u8>> {
        PushOpParamGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpParamGetDumpRequest<RequestBuf<'r>> {
        PushOpParamGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpParamGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpParamGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpParamGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpParamGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get param instances."]
pub struct PushOpParamGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpParamGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpParamGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(38u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_param_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            81u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_param_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 81u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpParamGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get param instances."]
#[derive(Clone)]
pub enum OpParamGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    ParamName(&'a CStr),
}
impl<'a> IterableOpParamGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_param_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamGetDoRequest::ParamName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamGetDoRequest",
            "ParamName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpParamGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpParamGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpParamGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpParamGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpParamGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpParamGetDoRequest<'a> {
    type Item = Result<OpParamGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpParamGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpParamGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                81u16 => OpParamGetDoRequest::ParamName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpParamGetDoRequest",
            r#type.and_then(|t| OpParamGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpParamGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpParamGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpParamGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpParamGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpParamGetDoRequest::ParamName(val) => fmt.field("ParamName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpParamGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpParamGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpParamGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpParamGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpParamGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpParamGetDoRequest::ParamName(val) => {
                    if last_off == offset {
                        stack.push(("ParamName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpParamGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get param instances."]
pub struct PushOpParamGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpParamGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpParamGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(38u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_param_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            81u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_param_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 81u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpParamGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get param instances."]
#[derive(Clone)]
pub enum OpParamGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    ParamName(&'a CStr),
}
impl<'a> IterableOpParamGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_param_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamGetDoReply::ParamName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamGetDoReply",
            "ParamName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpParamGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpParamGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpParamGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpParamGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpParamGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpParamGetDoReply<'a> {
    type Item = Result<OpParamGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpParamGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpParamGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                81u16 => OpParamGetDoReply::ParamName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpParamGetDoReply",
            r#type.and_then(|t| OpParamGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpParamGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpParamGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpParamGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpParamGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpParamGetDoReply::ParamName(val) => fmt.field("ParamName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpParamGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpParamGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpParamGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpParamGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpParamGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpParamGetDoReply::ParamName(val) => {
                    if last_off == offset {
                        stack.push(("ParamName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpParamGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpParamGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpParamGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpParamGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpParamGetDoRequest<&mut Vec<u8>> {
        PushOpParamGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpParamGetDoRequest<RequestBuf<'r>> {
        PushOpParamGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpParamGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpParamGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpParamGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpParamGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set param instances."]
pub struct PushOpParamSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpParamSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpParamSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(39u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_param_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            81u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_param_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 81u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    pub fn push_param_type(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 83u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Associated type: \"ParamCmode\" (enum)"]
    pub fn push_param_value_cmode(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 87u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpParamSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set param instances."]
#[derive(Clone)]
pub enum OpParamSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    ParamName(&'a CStr),
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    ParamType(u8),
    #[doc = "Associated type: \"ParamCmode\" (enum)"]
    ParamValueCmode(u8),
}
impl<'a> IterableOpParamSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_param_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamSetDoRequest::ParamName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamSetDoRequest",
            "ParamName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"VarAttrType\" (enum)"]
    pub fn get_param_type(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamSetDoRequest::ParamType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamSetDoRequest",
            "ParamType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"ParamCmode\" (enum)"]
    pub fn get_param_value_cmode(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpParamSetDoRequest::ParamValueCmode(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpParamSetDoRequest",
            "ParamValueCmode",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpParamSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpParamSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpParamSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpParamSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpParamSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpParamSetDoRequest<'a> {
    type Item = Result<OpParamSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpParamSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpParamSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                81u16 => OpParamSetDoRequest::ParamName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                83u16 => OpParamSetDoRequest::ParamType({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                87u16 => OpParamSetDoRequest::ParamValueCmode({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpParamSetDoRequest",
            r#type.and_then(|t| OpParamSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpParamSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpParamSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpParamSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpParamSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpParamSetDoRequest::ParamName(val) => fmt.field("ParamName", &val),
                OpParamSetDoRequest::ParamType(val) => fmt.field(
                    "ParamType",
                    &FormatEnum(val.into(), VarAttrType::from_value),
                ),
                OpParamSetDoRequest::ParamValueCmode(val) => fmt.field(
                    "ParamValueCmode",
                    &FormatEnum(val.into(), ParamCmode::from_value),
                ),
            };
        }
        fmt.finish()
    }
}
impl IterableOpParamSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpParamSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpParamSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpParamSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpParamSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpParamSetDoRequest::ParamName(val) => {
                    if last_off == offset {
                        stack.push(("ParamName", last_off));
                        break;
                    }
                }
                OpParamSetDoRequest::ParamType(val) => {
                    if last_off == offset {
                        stack.push(("ParamType", last_off));
                        break;
                    }
                }
                OpParamSetDoRequest::ParamValueCmode(val) => {
                    if last_off == offset {
                        stack.push(("ParamValueCmode", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpParamSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set param instances."]
pub struct PushOpParamSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpParamSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpParamSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(39u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpParamSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set param instances."]
#[derive(Clone)]
pub enum OpParamSetDoReply {}
impl<'a> IterableOpParamSetDoReply<'a> {}
impl OpParamSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpParamSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpParamSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpParamSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpParamSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpParamSetDoReply<'a> {
    type Item = Result<OpParamSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpParamSetDoReply",
            r#type.and_then(|t| OpParamSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpParamSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpParamSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpParamSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpParamSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpParamSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpParamSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpParamSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpParamSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpParamSetDoRequest<&mut Vec<u8>> {
        PushOpParamSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpParamSetDoRequest<RequestBuf<'r>> {
        PushOpParamSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpParamSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpParamSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpParamSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpParamSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get region instances."]
pub struct PushOpRegionGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRegionGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRegionGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(42u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpRegionGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get region instances."]
#[derive(Clone)]
pub enum OpRegionGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpRegionGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRegionGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRegionGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRegionGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRegionGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRegionGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRegionGetDumpRequest<'a> {
    type Item = Result<OpRegionGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRegionGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRegionGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRegionGetDumpRequest",
            r#type.and_then(|t| OpRegionGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRegionGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRegionGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRegionGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpRegionGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRegionGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRegionGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRegionGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRegionGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRegionGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRegionGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get region instances."]
pub struct PushOpRegionGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRegionGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRegionGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(42u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            88u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_region_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 88u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpRegionGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get region instances."]
#[derive(Clone)]
pub enum OpRegionGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    RegionName(&'a CStr),
}
impl<'a> IterableOpRegionGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDumpReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDumpReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDumpReply::RegionName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDumpReply",
            "RegionName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRegionGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRegionGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRegionGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRegionGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRegionGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRegionGetDumpReply<'a> {
    type Item = Result<OpRegionGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRegionGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRegionGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpRegionGetDumpReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                88u16 => OpRegionGetDumpReply::RegionName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRegionGetDumpReply",
            r#type.and_then(|t| OpRegionGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRegionGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRegionGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRegionGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpRegionGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpRegionGetDumpReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpRegionGetDumpReply::RegionName(val) => fmt.field("RegionName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRegionGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRegionGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRegionGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRegionGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRegionGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRegionGetDumpReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpRegionGetDumpReply::RegionName(val) => {
                    if last_off == offset {
                        stack.push(("RegionName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRegionGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpRegionGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpRegionGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpRegionGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpRegionGetDumpRequest<&mut Vec<u8>> {
        PushOpRegionGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpRegionGetDumpRequest<RequestBuf<'r>> {
        PushOpRegionGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpRegionGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpRegionGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpRegionGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpRegionGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get region instances."]
pub struct PushOpRegionGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRegionGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRegionGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(42u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            88u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_region_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 88u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpRegionGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get region instances."]
#[derive(Clone)]
pub enum OpRegionGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    RegionName(&'a CStr),
}
impl<'a> IterableOpRegionGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDoRequest::RegionName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDoRequest",
            "RegionName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRegionGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRegionGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRegionGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRegionGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRegionGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRegionGetDoRequest<'a> {
    type Item = Result<OpRegionGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRegionGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRegionGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpRegionGetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                88u16 => OpRegionGetDoRequest::RegionName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRegionGetDoRequest",
            r#type.and_then(|t| OpRegionGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRegionGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRegionGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRegionGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpRegionGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpRegionGetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpRegionGetDoRequest::RegionName(val) => fmt.field("RegionName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRegionGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRegionGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRegionGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRegionGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRegionGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRegionGetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpRegionGetDoRequest::RegionName(val) => {
                    if last_off == offset {
                        stack.push(("RegionName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRegionGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get region instances."]
pub struct PushOpRegionGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRegionGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRegionGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(42u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            88u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_region_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 88u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpRegionGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get region instances."]
#[derive(Clone)]
pub enum OpRegionGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    RegionName(&'a CStr),
}
impl<'a> IterableOpRegionGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDoReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDoReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionGetDoReply::RegionName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionGetDoReply",
            "RegionName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRegionGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRegionGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRegionGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRegionGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRegionGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRegionGetDoReply<'a> {
    type Item = Result<OpRegionGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRegionGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRegionGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpRegionGetDoReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                88u16 => OpRegionGetDoReply::RegionName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRegionGetDoReply",
            r#type.and_then(|t| OpRegionGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRegionGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRegionGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRegionGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpRegionGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpRegionGetDoReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpRegionGetDoReply::RegionName(val) => fmt.field("RegionName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRegionGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRegionGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRegionGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRegionGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRegionGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRegionGetDoReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpRegionGetDoReply::RegionName(val) => {
                    if last_off == offset {
                        stack.push(("RegionName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRegionGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpRegionGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpRegionGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpRegionGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpRegionGetDoRequest<&mut Vec<u8>> {
        PushOpRegionGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpRegionGetDoRequest<RequestBuf<'r>> {
        PushOpRegionGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpRegionGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpRegionGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpRegionGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpRegionGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Create region snapshot."]
pub struct PushOpRegionNewDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRegionNewDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRegionNewDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(44u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            88u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_region_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 88u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_region_snapshot_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 92u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpRegionNewDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create region snapshot."]
#[derive(Clone)]
pub enum OpRegionNewDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    RegionName(&'a CStr),
    RegionSnapshotId(u32),
}
impl<'a> IterableOpRegionNewDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionNewDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionNewDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionNewDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionNewDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionNewDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionNewDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionNewDoRequest::RegionName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionNewDoRequest",
            "RegionName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_snapshot_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionNewDoRequest::RegionSnapshotId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionNewDoRequest",
            "RegionSnapshotId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRegionNewDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRegionNewDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRegionNewDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRegionNewDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRegionNewDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRegionNewDoRequest<'a> {
    type Item = Result<OpRegionNewDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRegionNewDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRegionNewDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpRegionNewDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                88u16 => OpRegionNewDoRequest::RegionName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                92u16 => OpRegionNewDoRequest::RegionSnapshotId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRegionNewDoRequest",
            r#type.and_then(|t| OpRegionNewDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRegionNewDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRegionNewDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRegionNewDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpRegionNewDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpRegionNewDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpRegionNewDoRequest::RegionName(val) => fmt.field("RegionName", &val),
                OpRegionNewDoRequest::RegionSnapshotId(val) => fmt.field("RegionSnapshotId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRegionNewDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRegionNewDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRegionNewDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRegionNewDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRegionNewDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRegionNewDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpRegionNewDoRequest::RegionName(val) => {
                    if last_off == offset {
                        stack.push(("RegionName", last_off));
                        break;
                    }
                }
                OpRegionNewDoRequest::RegionSnapshotId(val) => {
                    if last_off == offset {
                        stack.push(("RegionSnapshotId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRegionNewDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Create region snapshot."]
pub struct PushOpRegionNewDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRegionNewDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRegionNewDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(44u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            88u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_region_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 88u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_region_snapshot_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 92u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpRegionNewDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create region snapshot."]
#[derive(Clone)]
pub enum OpRegionNewDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    RegionName(&'a CStr),
    RegionSnapshotId(u32),
}
impl<'a> IterableOpRegionNewDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionNewDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionNewDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionNewDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionNewDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionNewDoReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionNewDoReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionNewDoReply::RegionName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionNewDoReply",
            "RegionName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_snapshot_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionNewDoReply::RegionSnapshotId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionNewDoReply",
            "RegionSnapshotId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRegionNewDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRegionNewDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRegionNewDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRegionNewDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRegionNewDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRegionNewDoReply<'a> {
    type Item = Result<OpRegionNewDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRegionNewDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRegionNewDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpRegionNewDoReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                88u16 => OpRegionNewDoReply::RegionName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                92u16 => OpRegionNewDoReply::RegionSnapshotId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRegionNewDoReply",
            r#type.and_then(|t| OpRegionNewDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRegionNewDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRegionNewDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRegionNewDoReply::BusName(val) => fmt.field("BusName", &val),
                OpRegionNewDoReply::DevName(val) => fmt.field("DevName", &val),
                OpRegionNewDoReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpRegionNewDoReply::RegionName(val) => fmt.field("RegionName", &val),
                OpRegionNewDoReply::RegionSnapshotId(val) => fmt.field("RegionSnapshotId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRegionNewDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRegionNewDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRegionNewDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRegionNewDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRegionNewDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRegionNewDoReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpRegionNewDoReply::RegionName(val) => {
                    if last_off == offset {
                        stack.push(("RegionName", last_off));
                        break;
                    }
                }
                OpRegionNewDoReply::RegionSnapshotId(val) => {
                    if last_off == offset {
                        stack.push(("RegionSnapshotId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRegionNewDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpRegionNewDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpRegionNewDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpRegionNewDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpRegionNewDoRequest<&mut Vec<u8>> {
        PushOpRegionNewDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpRegionNewDoRequest<RequestBuf<'r>> {
        PushOpRegionNewDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpRegionNewDoRequest<'_> {
    type ReplyType<'buf> = IterableOpRegionNewDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpRegionNewDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpRegionNewDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete region snapshot."]
pub struct PushOpRegionDelDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRegionDelDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRegionDelDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(45u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            88u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_region_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 88u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_region_snapshot_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 92u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpRegionDelDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete region snapshot."]
#[derive(Clone)]
pub enum OpRegionDelDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    RegionName(&'a CStr),
    RegionSnapshotId(u32),
}
impl<'a> IterableOpRegionDelDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionDelDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionDelDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionDelDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionDelDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionDelDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionDelDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionDelDoRequest::RegionName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionDelDoRequest",
            "RegionName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_snapshot_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionDelDoRequest::RegionSnapshotId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionDelDoRequest",
            "RegionSnapshotId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRegionDelDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRegionDelDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRegionDelDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRegionDelDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRegionDelDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRegionDelDoRequest<'a> {
    type Item = Result<OpRegionDelDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRegionDelDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRegionDelDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpRegionDelDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                88u16 => OpRegionDelDoRequest::RegionName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                92u16 => OpRegionDelDoRequest::RegionSnapshotId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRegionDelDoRequest",
            r#type.and_then(|t| OpRegionDelDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRegionDelDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRegionDelDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRegionDelDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpRegionDelDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpRegionDelDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpRegionDelDoRequest::RegionName(val) => fmt.field("RegionName", &val),
                OpRegionDelDoRequest::RegionSnapshotId(val) => fmt.field("RegionSnapshotId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRegionDelDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRegionDelDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRegionDelDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRegionDelDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRegionDelDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRegionDelDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpRegionDelDoRequest::RegionName(val) => {
                    if last_off == offset {
                        stack.push(("RegionName", last_off));
                        break;
                    }
                }
                OpRegionDelDoRequest::RegionSnapshotId(val) => {
                    if last_off == offset {
                        stack.push(("RegionSnapshotId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRegionDelDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete region snapshot."]
pub struct PushOpRegionDelDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRegionDelDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRegionDelDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(45u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpRegionDelDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete region snapshot."]
#[derive(Clone)]
pub enum OpRegionDelDoReply {}
impl<'a> IterableOpRegionDelDoReply<'a> {}
impl OpRegionDelDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRegionDelDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRegionDelDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRegionDelDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRegionDelDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRegionDelDoReply<'a> {
    type Item = Result<OpRegionDelDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRegionDelDoReply",
            r#type.and_then(|t| OpRegionDelDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpRegionDelDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRegionDelDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpRegionDelDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRegionDelDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRegionDelDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpRegionDelDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpRegionDelDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpRegionDelDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpRegionDelDoRequest<&mut Vec<u8>> {
        PushOpRegionDelDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpRegionDelDoRequest<RequestBuf<'r>> {
        PushOpRegionDelDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpRegionDelDoRequest<'_> {
    type ReplyType<'buf> = IterableOpRegionDelDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpRegionDelDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpRegionDelDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Read region data."]
pub struct PushOpRegionReadDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRegionReadDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRegionReadDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(46u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            88u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_region_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 88u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_region_snapshot_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 92u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_chunk_addr(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 96u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_chunk_len(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 97u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_direct(mut self, value: ()) -> Self {
        push_header(self.as_rec_mut(), 179u16, 0 as u16);
        self
    }
}
impl<Prev: Rec> Drop for PushOpRegionReadDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Read region data."]
#[derive(Clone)]
pub enum OpRegionReadDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    RegionName(&'a CStr),
    RegionSnapshotId(u32),
    RegionChunkAddr(u64),
    RegionChunkLen(u64),
    RegionDirect(()),
}
impl<'a> IterableOpRegionReadDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpRequest::RegionName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpRequest",
            "RegionName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_snapshot_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpRequest::RegionSnapshotId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpRequest",
            "RegionSnapshotId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_chunk_addr(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpRequest::RegionChunkAddr(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpRequest",
            "RegionChunkAddr",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_chunk_len(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpRequest::RegionChunkLen(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpRequest",
            "RegionChunkLen",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_direct(&self) -> Result<(), ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpRequest::RegionDirect(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpRequest",
            "RegionDirect",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRegionReadDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRegionReadDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRegionReadDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRegionReadDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRegionReadDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRegionReadDumpRequest<'a> {
    type Item = Result<OpRegionReadDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRegionReadDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRegionReadDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpRegionReadDumpRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                88u16 => OpRegionReadDumpRequest::RegionName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                92u16 => OpRegionReadDumpRequest::RegionSnapshotId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                96u16 => OpRegionReadDumpRequest::RegionChunkAddr({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                97u16 => OpRegionReadDumpRequest::RegionChunkLen({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                179u16 => OpRegionReadDumpRequest::RegionDirect(()),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRegionReadDumpRequest",
            r#type.and_then(|t| OpRegionReadDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRegionReadDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRegionReadDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRegionReadDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpRegionReadDumpRequest::DevName(val) => fmt.field("DevName", &val),
                OpRegionReadDumpRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpRegionReadDumpRequest::RegionName(val) => fmt.field("RegionName", &val),
                OpRegionReadDumpRequest::RegionSnapshotId(val) => {
                    fmt.field("RegionSnapshotId", &val)
                }
                OpRegionReadDumpRequest::RegionChunkAddr(val) => fmt.field("RegionChunkAddr", &val),
                OpRegionReadDumpRequest::RegionChunkLen(val) => fmt.field("RegionChunkLen", &val),
                OpRegionReadDumpRequest::RegionDirect(val) => fmt.field("RegionDirect", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRegionReadDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRegionReadDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRegionReadDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRegionReadDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRegionReadDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRegionReadDumpRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpRegionReadDumpRequest::RegionName(val) => {
                    if last_off == offset {
                        stack.push(("RegionName", last_off));
                        break;
                    }
                }
                OpRegionReadDumpRequest::RegionSnapshotId(val) => {
                    if last_off == offset {
                        stack.push(("RegionSnapshotId", last_off));
                        break;
                    }
                }
                OpRegionReadDumpRequest::RegionChunkAddr(val) => {
                    if last_off == offset {
                        stack.push(("RegionChunkAddr", last_off));
                        break;
                    }
                }
                OpRegionReadDumpRequest::RegionChunkLen(val) => {
                    if last_off == offset {
                        stack.push(("RegionChunkLen", last_off));
                        break;
                    }
                }
                OpRegionReadDumpRequest::RegionDirect(val) => {
                    if last_off == offset {
                        stack.push(("RegionDirect", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRegionReadDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Read region data."]
pub struct PushOpRegionReadDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRegionReadDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRegionReadDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(46u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_region_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            88u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_region_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 88u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpRegionReadDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Read region data."]
#[derive(Clone)]
pub enum OpRegionReadDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    RegionName(&'a CStr),
}
impl<'a> IterableOpRegionReadDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_region_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRegionReadDumpReply::RegionName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRegionReadDumpReply",
            "RegionName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRegionReadDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRegionReadDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRegionReadDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRegionReadDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRegionReadDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRegionReadDumpReply<'a> {
    type Item = Result<OpRegionReadDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRegionReadDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRegionReadDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpRegionReadDumpReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                88u16 => OpRegionReadDumpReply::RegionName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRegionReadDumpReply",
            r#type.and_then(|t| OpRegionReadDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRegionReadDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRegionReadDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRegionReadDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpRegionReadDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpRegionReadDumpReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpRegionReadDumpReply::RegionName(val) => fmt.field("RegionName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRegionReadDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRegionReadDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRegionReadDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRegionReadDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRegionReadDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRegionReadDumpReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpRegionReadDumpReply::RegionName(val) => {
                    if last_off == offset {
                        stack.push(("RegionName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRegionReadDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpRegionReadDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpRegionReadDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpRegionReadDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpRegionReadDumpRequest<&mut Vec<u8>> {
        PushOpRegionReadDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpRegionReadDumpRequest<RequestBuf<'r>> {
        PushOpRegionReadDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpRegionReadDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpRegionReadDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpRegionReadDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpRegionReadDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get port param instances."]
pub struct PushOpPortParamGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortParamGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortParamGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(47u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpPortParamGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get port param instances."]
#[derive(Clone)]
pub enum OpPortParamGetDumpRequest {}
impl<'a> IterableOpPortParamGetDumpRequest<'a> {}
impl OpPortParamGetDumpRequest {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortParamGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortParamGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortParamGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortParamGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortParamGetDumpRequest<'a> {
    type Item = Result<OpPortParamGetDumpRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortParamGetDumpRequest",
            r#type.and_then(|t| OpPortParamGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpPortParamGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortParamGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpPortParamGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortParamGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortParamGetDumpRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get port param instances."]
pub struct PushOpPortParamGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortParamGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortParamGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(47u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortParamGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get port param instances."]
#[derive(Clone)]
pub enum OpPortParamGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpPortParamGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamGetDumpReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamGetDumpReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortParamGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortParamGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortParamGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortParamGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortParamGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortParamGetDumpReply<'a> {
    type Item = Result<OpPortParamGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortParamGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortParamGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortParamGetDumpReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortParamGetDumpReply",
            r#type.and_then(|t| OpPortParamGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortParamGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortParamGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortParamGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpPortParamGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpPortParamGetDumpReply::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortParamGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortParamGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortParamGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortParamGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortParamGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortParamGetDumpReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortParamGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpPortParamGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpPortParamGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpPortParamGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpPortParamGetDumpRequest<&mut Vec<u8>> {
        PushOpPortParamGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpPortParamGetDumpRequest<RequestBuf<'r>> {
        PushOpPortParamGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpPortParamGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpPortParamGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpPortParamGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpPortParamGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get port param instances."]
pub struct PushOpPortParamGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortParamGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortParamGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(47u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortParamGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get port param instances."]
#[derive(Clone)]
pub enum OpPortParamGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpPortParamGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamGetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamGetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortParamGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortParamGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortParamGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortParamGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortParamGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortParamGetDoRequest<'a> {
    type Item = Result<OpPortParamGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortParamGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortParamGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortParamGetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortParamGetDoRequest",
            r#type.and_then(|t| OpPortParamGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortParamGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortParamGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortParamGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpPortParamGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpPortParamGetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortParamGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortParamGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortParamGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortParamGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortParamGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortParamGetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortParamGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get port param instances."]
pub struct PushOpPortParamGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortParamGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortParamGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(47u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortParamGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get port param instances."]
#[derive(Clone)]
pub enum OpPortParamGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpPortParamGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamGetDoReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamGetDoReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortParamGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortParamGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortParamGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortParamGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortParamGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortParamGetDoReply<'a> {
    type Item = Result<OpPortParamGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortParamGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortParamGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortParamGetDoReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortParamGetDoReply",
            r#type.and_then(|t| OpPortParamGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortParamGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortParamGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortParamGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpPortParamGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpPortParamGetDoReply::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortParamGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortParamGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortParamGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortParamGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortParamGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortParamGetDoReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortParamGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpPortParamGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpPortParamGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpPortParamGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpPortParamGetDoRequest<&mut Vec<u8>> {
        PushOpPortParamGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpPortParamGetDoRequest<RequestBuf<'r>> {
        PushOpPortParamGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpPortParamGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpPortParamGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpPortParamGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpPortParamGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set port param instances."]
pub struct PushOpPortParamSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortParamSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortParamSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(48u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpPortParamSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set port param instances."]
#[derive(Clone)]
pub enum OpPortParamSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpPortParamSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpPortParamSetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpPortParamSetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpPortParamSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortParamSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortParamSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortParamSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortParamSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortParamSetDoRequest<'a> {
    type Item = Result<OpPortParamSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpPortParamSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpPortParamSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpPortParamSetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortParamSetDoRequest",
            r#type.and_then(|t| OpPortParamSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpPortParamSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortParamSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpPortParamSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpPortParamSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpPortParamSetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpPortParamSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortParamSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortParamSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpPortParamSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpPortParamSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpPortParamSetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpPortParamSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set port param instances."]
pub struct PushOpPortParamSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpPortParamSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpPortParamSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(48u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpPortParamSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set port param instances."]
#[derive(Clone)]
pub enum OpPortParamSetDoReply {}
impl<'a> IterableOpPortParamSetDoReply<'a> {}
impl OpPortParamSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpPortParamSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpPortParamSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpPortParamSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpPortParamSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpPortParamSetDoReply<'a> {
    type Item = Result<OpPortParamSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpPortParamSetDoReply",
            r#type.and_then(|t| OpPortParamSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpPortParamSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpPortParamSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpPortParamSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpPortParamSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpPortParamSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpPortParamSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpPortParamSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpPortParamSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpPortParamSetDoRequest<&mut Vec<u8>> {
        PushOpPortParamSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpPortParamSetDoRequest<RequestBuf<'r>> {
        PushOpPortParamSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpPortParamSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpPortParamSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpPortParamSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpPortParamSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get device information, like driver name, hardware and firmware versions\netc.\n"]
pub struct PushOpInfoGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpInfoGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpInfoGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(51u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpInfoGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get device information, like driver name, hardware and firmware versions\netc.\n"]
#[derive(Clone)]
pub enum OpInfoGetDumpRequest {}
impl<'a> IterableOpInfoGetDumpRequest<'a> {}
impl OpInfoGetDumpRequest {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpInfoGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpInfoGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpInfoGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpInfoGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpInfoGetDumpRequest<'a> {
    type Item = Result<OpInfoGetDumpRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpInfoGetDumpRequest",
            r#type.and_then(|t| OpInfoGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpInfoGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpInfoGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpInfoGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpInfoGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpInfoGetDumpRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get device information, like driver name, hardware and firmware versions\netc.\n"]
pub struct PushOpInfoGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpInfoGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpInfoGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(51u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_info_driver_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            98u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_driver_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 98u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_info_serial_number(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            99u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_serial_number_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 99u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_info_version_fixed(mut self) -> PushDlInfoVersion<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 100u16);
        PushDlInfoVersion {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_info_version_running(mut self) -> PushDlInfoVersion<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 101u16);
        PushDlInfoVersion {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_info_version_stored(mut self) -> PushDlInfoVersion<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 102u16);
        PushDlInfoVersion {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_info_board_serial_number(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            146u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_board_serial_number_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 146u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpInfoGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get device information, like driver name, hardware and firmware versions\netc.\n"]
#[derive(Clone)]
pub enum OpInfoGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    InfoDriverName(&'a CStr),
    InfoSerialNumber(&'a CStr),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    InfoVersionFixed(IterableDlInfoVersion<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    InfoVersionRunning(IterableDlInfoVersion<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    InfoVersionStored(IterableDlInfoVersion<'a>),
    InfoBoardSerialNumber(&'a CStr),
}
impl<'a> IterableOpInfoGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info_driver_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDumpReply::InfoDriverName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDumpReply",
            "InfoDriverName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info_serial_number(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDumpReply::InfoSerialNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDumpReply",
            "InfoSerialNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_info_version_fixed(
        &self,
    ) -> MultiAttrIterable<Self, OpInfoGetDumpReply<'a>, IterableDlInfoVersion<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpInfoGetDumpReply::InfoVersionFixed(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_info_version_running(
        &self,
    ) -> MultiAttrIterable<Self, OpInfoGetDumpReply<'a>, IterableDlInfoVersion<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpInfoGetDumpReply::InfoVersionRunning(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_info_version_stored(
        &self,
    ) -> MultiAttrIterable<Self, OpInfoGetDumpReply<'a>, IterableDlInfoVersion<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpInfoGetDumpReply::InfoVersionStored(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_info_board_serial_number(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDumpReply::InfoBoardSerialNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDumpReply",
            "InfoBoardSerialNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpInfoGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpInfoGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpInfoGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpInfoGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpInfoGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpInfoGetDumpReply<'a> {
    type Item = Result<OpInfoGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpInfoGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpInfoGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                98u16 => OpInfoGetDumpReply::InfoDriverName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                99u16 => OpInfoGetDumpReply::InfoSerialNumber({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                100u16 => OpInfoGetDumpReply::InfoVersionFixed({
                    let res = Some(IterableDlInfoVersion::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                101u16 => OpInfoGetDumpReply::InfoVersionRunning({
                    let res = Some(IterableDlInfoVersion::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                102u16 => OpInfoGetDumpReply::InfoVersionStored({
                    let res = Some(IterableDlInfoVersion::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                146u16 => OpInfoGetDumpReply::InfoBoardSerialNumber({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpInfoGetDumpReply",
            r#type.and_then(|t| OpInfoGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpInfoGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpInfoGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpInfoGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpInfoGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpInfoGetDumpReply::InfoDriverName(val) => fmt.field("InfoDriverName", &val),
                OpInfoGetDumpReply::InfoSerialNumber(val) => fmt.field("InfoSerialNumber", &val),
                OpInfoGetDumpReply::InfoVersionFixed(val) => fmt.field("InfoVersionFixed", &val),
                OpInfoGetDumpReply::InfoVersionRunning(val) => {
                    fmt.field("InfoVersionRunning", &val)
                }
                OpInfoGetDumpReply::InfoVersionStored(val) => fmt.field("InfoVersionStored", &val),
                OpInfoGetDumpReply::InfoBoardSerialNumber(val) => {
                    fmt.field("InfoBoardSerialNumber", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpInfoGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpInfoGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpInfoGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpInfoGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpInfoGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpInfoGetDumpReply::InfoDriverName(val) => {
                    if last_off == offset {
                        stack.push(("InfoDriverName", last_off));
                        break;
                    }
                }
                OpInfoGetDumpReply::InfoSerialNumber(val) => {
                    if last_off == offset {
                        stack.push(("InfoSerialNumber", last_off));
                        break;
                    }
                }
                OpInfoGetDumpReply::InfoVersionFixed(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpInfoGetDumpReply::InfoVersionRunning(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpInfoGetDumpReply::InfoVersionStored(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpInfoGetDumpReply::InfoBoardSerialNumber(val) => {
                    if last_off == offset {
                        stack.push(("InfoBoardSerialNumber", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpInfoGetDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpInfoGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpInfoGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpInfoGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpInfoGetDumpRequest<&mut Vec<u8>> {
        PushOpInfoGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpInfoGetDumpRequest<RequestBuf<'r>> {
        PushOpInfoGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpInfoGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpInfoGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpInfoGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpInfoGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get device information, like driver name, hardware and firmware versions\netc.\n"]
pub struct PushOpInfoGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpInfoGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpInfoGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(51u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpInfoGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get device information, like driver name, hardware and firmware versions\netc.\n"]
#[derive(Clone)]
pub enum OpInfoGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpInfoGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpInfoGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpInfoGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpInfoGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpInfoGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpInfoGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpInfoGetDoRequest<'a> {
    type Item = Result<OpInfoGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpInfoGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpInfoGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpInfoGetDoRequest",
            r#type.and_then(|t| OpInfoGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpInfoGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpInfoGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpInfoGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpInfoGetDoRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpInfoGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpInfoGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpInfoGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpInfoGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpInfoGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpInfoGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get device information, like driver name, hardware and firmware versions\netc.\n"]
pub struct PushOpInfoGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpInfoGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpInfoGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(51u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_info_driver_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            98u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_driver_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 98u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_info_serial_number(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            99u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_serial_number_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 99u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_info_version_fixed(mut self) -> PushDlInfoVersion<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 100u16);
        PushDlInfoVersion {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_info_version_running(mut self) -> PushDlInfoVersion<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 101u16);
        PushDlInfoVersion {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_info_version_stored(mut self) -> PushDlInfoVersion<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 102u16);
        PushDlInfoVersion {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
    pub fn push_info_board_serial_number(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            146u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_info_board_serial_number_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 146u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpInfoGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get device information, like driver name, hardware and firmware versions\netc.\n"]
#[derive(Clone)]
pub enum OpInfoGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    InfoDriverName(&'a CStr),
    InfoSerialNumber(&'a CStr),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    InfoVersionFixed(IterableDlInfoVersion<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    InfoVersionRunning(IterableDlInfoVersion<'a>),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    InfoVersionStored(IterableDlInfoVersion<'a>),
    InfoBoardSerialNumber(&'a CStr),
}
impl<'a> IterableOpInfoGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info_driver_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDoReply::InfoDriverName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDoReply",
            "InfoDriverName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_info_serial_number(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDoReply::InfoSerialNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDoReply",
            "InfoSerialNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_info_version_fixed(
        &self,
    ) -> MultiAttrIterable<Self, OpInfoGetDoReply<'a>, IterableDlInfoVersion<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpInfoGetDoReply::InfoVersionFixed(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_info_version_running(
        &self,
    ) -> MultiAttrIterable<Self, OpInfoGetDoReply<'a>, IterableDlInfoVersion<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpInfoGetDoReply::InfoVersionRunning(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_info_version_stored(
        &self,
    ) -> MultiAttrIterable<Self, OpInfoGetDoReply<'a>, IterableDlInfoVersion<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpInfoGetDoReply::InfoVersionStored(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
    pub fn get_info_board_serial_number(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpInfoGetDoReply::InfoBoardSerialNumber(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpInfoGetDoReply",
            "InfoBoardSerialNumber",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpInfoGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpInfoGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpInfoGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpInfoGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpInfoGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpInfoGetDoReply<'a> {
    type Item = Result<OpInfoGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpInfoGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpInfoGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                98u16 => OpInfoGetDoReply::InfoDriverName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                99u16 => OpInfoGetDoReply::InfoSerialNumber({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                100u16 => OpInfoGetDoReply::InfoVersionFixed({
                    let res = Some(IterableDlInfoVersion::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                101u16 => OpInfoGetDoReply::InfoVersionRunning({
                    let res = Some(IterableDlInfoVersion::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                102u16 => OpInfoGetDoReply::InfoVersionStored({
                    let res = Some(IterableDlInfoVersion::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                146u16 => OpInfoGetDoReply::InfoBoardSerialNumber({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpInfoGetDoReply",
            r#type.and_then(|t| OpInfoGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpInfoGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpInfoGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpInfoGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpInfoGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpInfoGetDoReply::InfoDriverName(val) => fmt.field("InfoDriverName", &val),
                OpInfoGetDoReply::InfoSerialNumber(val) => fmt.field("InfoSerialNumber", &val),
                OpInfoGetDoReply::InfoVersionFixed(val) => fmt.field("InfoVersionFixed", &val),
                OpInfoGetDoReply::InfoVersionRunning(val) => fmt.field("InfoVersionRunning", &val),
                OpInfoGetDoReply::InfoVersionStored(val) => fmt.field("InfoVersionStored", &val),
                OpInfoGetDoReply::InfoBoardSerialNumber(val) => {
                    fmt.field("InfoBoardSerialNumber", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpInfoGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpInfoGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpInfoGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpInfoGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpInfoGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpInfoGetDoReply::InfoDriverName(val) => {
                    if last_off == offset {
                        stack.push(("InfoDriverName", last_off));
                        break;
                    }
                }
                OpInfoGetDoReply::InfoSerialNumber(val) => {
                    if last_off == offset {
                        stack.push(("InfoSerialNumber", last_off));
                        break;
                    }
                }
                OpInfoGetDoReply::InfoVersionFixed(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpInfoGetDoReply::InfoVersionRunning(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpInfoGetDoReply::InfoVersionStored(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                OpInfoGetDoReply::InfoBoardSerialNumber(val) => {
                    if last_off == offset {
                        stack.push(("InfoBoardSerialNumber", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpInfoGetDoReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpInfoGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpInfoGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpInfoGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpInfoGetDoRequest<&mut Vec<u8>> {
        PushOpInfoGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpInfoGetDoRequest<RequestBuf<'r>> {
        PushOpInfoGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpInfoGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpInfoGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpInfoGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpInfoGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get health reporter instances."]
pub struct PushOpHealthReporterGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(52u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpHealthReporterGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDumpRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDumpRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpHealthReporterGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterGetDumpRequest<'a> {
    type Item = Result<OpHealthReporterGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpHealthReporterGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpHealthReporterGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpHealthReporterGetDumpRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterGetDumpRequest",
            r#type.and_then(|t| OpHealthReporterGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpHealthReporterGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpHealthReporterGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpHealthReporterGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
                OpHealthReporterGetDumpRequest::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpHealthReporterGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpHealthReporterGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpHealthReporterGetDumpRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpHealthReporterGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get health reporter instances."]
pub struct PushOpHealthReporterGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(52u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            115u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_health_reporter_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 115u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    HealthReporterName(&'a CStr),
}
impl<'a> IterableOpHealthReporterGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDumpReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDumpReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDumpReply::HealthReporterName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDumpReply",
            "HealthReporterName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpHealthReporterGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterGetDumpReply<'a> {
    type Item = Result<OpHealthReporterGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpHealthReporterGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpHealthReporterGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpHealthReporterGetDumpReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                115u16 => OpHealthReporterGetDumpReply::HealthReporterName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterGetDumpReply",
            r#type.and_then(|t| OpHealthReporterGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpHealthReporterGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpHealthReporterGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpHealthReporterGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpHealthReporterGetDumpReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpHealthReporterGetDumpReply::HealthReporterName(val) => {
                    fmt.field("HealthReporterName", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpHealthReporterGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpHealthReporterGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpHealthReporterGetDumpReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpHealthReporterGetDumpReply::HealthReporterName(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpHealthReporterGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpHealthReporterGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpHealthReporterGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpHealthReporterGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpHealthReporterGetDumpRequest<&mut Vec<u8>> {
        PushOpHealthReporterGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpHealthReporterGetDumpRequest<RequestBuf<'r>> {
        PushOpHealthReporterGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpHealthReporterGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpHealthReporterGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpHealthReporterGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpHealthReporterGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get health reporter instances."]
pub struct PushOpHealthReporterGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(52u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            115u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_health_reporter_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 115u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    HealthReporterName(&'a CStr),
}
impl<'a> IterableOpHealthReporterGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDoRequest::HealthReporterName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDoRequest",
            "HealthReporterName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpHealthReporterGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterGetDoRequest<'a> {
    type Item = Result<OpHealthReporterGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpHealthReporterGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpHealthReporterGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpHealthReporterGetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                115u16 => OpHealthReporterGetDoRequest::HealthReporterName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterGetDoRequest",
            r#type.and_then(|t| OpHealthReporterGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpHealthReporterGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpHealthReporterGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpHealthReporterGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpHealthReporterGetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpHealthReporterGetDoRequest::HealthReporterName(val) => {
                    fmt.field("HealthReporterName", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpHealthReporterGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpHealthReporterGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpHealthReporterGetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpHealthReporterGetDoRequest::HealthReporterName(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpHealthReporterGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get health reporter instances."]
pub struct PushOpHealthReporterGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(52u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            115u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_health_reporter_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 115u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    HealthReporterName(&'a CStr),
}
impl<'a> IterableOpHealthReporterGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDoReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDoReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterGetDoReply::HealthReporterName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterGetDoReply",
            "HealthReporterName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpHealthReporterGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterGetDoReply<'a> {
    type Item = Result<OpHealthReporterGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpHealthReporterGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpHealthReporterGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpHealthReporterGetDoReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                115u16 => OpHealthReporterGetDoReply::HealthReporterName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterGetDoReply",
            r#type.and_then(|t| OpHealthReporterGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpHealthReporterGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpHealthReporterGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpHealthReporterGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpHealthReporterGetDoReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpHealthReporterGetDoReply::HealthReporterName(val) => {
                    fmt.field("HealthReporterName", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpHealthReporterGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpHealthReporterGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpHealthReporterGetDoReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpHealthReporterGetDoReply::HealthReporterName(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpHealthReporterGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpHealthReporterGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpHealthReporterGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpHealthReporterGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpHealthReporterGetDoRequest<&mut Vec<u8>> {
        PushOpHealthReporterGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpHealthReporterGetDoRequest<RequestBuf<'r>> {
        PushOpHealthReporterGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpHealthReporterGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpHealthReporterGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpHealthReporterGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpHealthReporterGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set health reporter instances."]
pub struct PushOpHealthReporterSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(53u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            115u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_health_reporter_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 115u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_health_reporter_graceful_period(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 120u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_auto_recover(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 121u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_auto_dump(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 141u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Time (in msec) for recoveries before starting the grace period."]
    pub fn push_health_reporter_burst_period(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 181u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    HealthReporterName(&'a CStr),
    HealthReporterGracefulPeriod(u64),
    HealthReporterAutoRecover(u8),
    HealthReporterAutoDump(u8),
    #[doc = "Time (in msec) for recoveries before starting the grace period."]
    HealthReporterBurstPeriod(u64),
}
impl<'a> IterableOpHealthReporterSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterSetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterSetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterSetDoRequest::HealthReporterName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterSetDoRequest",
            "HealthReporterName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_graceful_period(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterSetDoRequest::HealthReporterGracefulPeriod(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterSetDoRequest",
            "HealthReporterGracefulPeriod",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_auto_recover(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterSetDoRequest::HealthReporterAutoRecover(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterSetDoRequest",
            "HealthReporterAutoRecover",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_auto_dump(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterSetDoRequest::HealthReporterAutoDump(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterSetDoRequest",
            "HealthReporterAutoDump",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Time (in msec) for recoveries before starting the grace period."]
    pub fn get_health_reporter_burst_period(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterSetDoRequest::HealthReporterBurstPeriod(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterSetDoRequest",
            "HealthReporterBurstPeriod",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpHealthReporterSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterSetDoRequest<'a> {
    type Item = Result<OpHealthReporterSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpHealthReporterSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpHealthReporterSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpHealthReporterSetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                115u16 => OpHealthReporterSetDoRequest::HealthReporterName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                120u16 => OpHealthReporterSetDoRequest::HealthReporterGracefulPeriod({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                121u16 => OpHealthReporterSetDoRequest::HealthReporterAutoRecover({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                141u16 => OpHealthReporterSetDoRequest::HealthReporterAutoDump({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                181u16 => OpHealthReporterSetDoRequest::HealthReporterBurstPeriod({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterSetDoRequest",
            r#type.and_then(|t| OpHealthReporterSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpHealthReporterSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpHealthReporterSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpHealthReporterSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpHealthReporterSetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpHealthReporterSetDoRequest::HealthReporterName(val) => {
                    fmt.field("HealthReporterName", &val)
                }
                OpHealthReporterSetDoRequest::HealthReporterGracefulPeriod(val) => {
                    fmt.field("HealthReporterGracefulPeriod", &val)
                }
                OpHealthReporterSetDoRequest::HealthReporterAutoRecover(val) => {
                    fmt.field("HealthReporterAutoRecover", &val)
                }
                OpHealthReporterSetDoRequest::HealthReporterAutoDump(val) => {
                    fmt.field("HealthReporterAutoDump", &val)
                }
                OpHealthReporterSetDoRequest::HealthReporterBurstPeriod(val) => {
                    fmt.field("HealthReporterBurstPeriod", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpHealthReporterSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpHealthReporterSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpHealthReporterSetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpHealthReporterSetDoRequest::HealthReporterName(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterName", last_off));
                        break;
                    }
                }
                OpHealthReporterSetDoRequest::HealthReporterGracefulPeriod(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterGracefulPeriod", last_off));
                        break;
                    }
                }
                OpHealthReporterSetDoRequest::HealthReporterAutoRecover(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterAutoRecover", last_off));
                        break;
                    }
                }
                OpHealthReporterSetDoRequest::HealthReporterAutoDump(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterAutoDump", last_off));
                        break;
                    }
                }
                OpHealthReporterSetDoRequest::HealthReporterBurstPeriod(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterBurstPeriod", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpHealthReporterSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set health reporter instances."]
pub struct PushOpHealthReporterSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(53u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterSetDoReply {}
impl<'a> IterableOpHealthReporterSetDoReply<'a> {}
impl OpHealthReporterSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterSetDoReply<'a> {
    type Item = Result<OpHealthReporterSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterSetDoReply",
            r#type.and_then(|t| OpHealthReporterSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpHealthReporterSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpHealthReporterSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpHealthReporterSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpHealthReporterSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpHealthReporterSetDoRequest<&mut Vec<u8>> {
        PushOpHealthReporterSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpHealthReporterSetDoRequest<RequestBuf<'r>> {
        PushOpHealthReporterSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpHealthReporterSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpHealthReporterSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpHealthReporterSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpHealthReporterSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Recover health reporter instances."]
pub struct PushOpHealthReporterRecoverDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterRecoverDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterRecoverDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(54u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            115u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_health_reporter_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 115u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterRecoverDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Recover health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterRecoverDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    HealthReporterName(&'a CStr),
}
impl<'a> IterableOpHealthReporterRecoverDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterRecoverDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterRecoverDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterRecoverDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterRecoverDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterRecoverDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterRecoverDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterRecoverDoRequest::HealthReporterName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterRecoverDoRequest",
            "HealthReporterName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpHealthReporterRecoverDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterRecoverDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterRecoverDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterRecoverDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterRecoverDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterRecoverDoRequest<'a> {
    type Item = Result<OpHealthReporterRecoverDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpHealthReporterRecoverDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpHealthReporterRecoverDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpHealthReporterRecoverDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                115u16 => OpHealthReporterRecoverDoRequest::HealthReporterName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterRecoverDoRequest",
            r#type.and_then(|t| OpHealthReporterRecoverDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpHealthReporterRecoverDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterRecoverDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpHealthReporterRecoverDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpHealthReporterRecoverDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpHealthReporterRecoverDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpHealthReporterRecoverDoRequest::HealthReporterName(val) => {
                    fmt.field("HealthReporterName", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterRecoverDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterRecoverDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterRecoverDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpHealthReporterRecoverDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpHealthReporterRecoverDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpHealthReporterRecoverDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpHealthReporterRecoverDoRequest::HealthReporterName(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpHealthReporterRecoverDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Recover health reporter instances."]
pub struct PushOpHealthReporterRecoverDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterRecoverDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterRecoverDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(54u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterRecoverDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Recover health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterRecoverDoReply {}
impl<'a> IterableOpHealthReporterRecoverDoReply<'a> {}
impl OpHealthReporterRecoverDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterRecoverDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterRecoverDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterRecoverDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterRecoverDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterRecoverDoReply<'a> {
    type Item = Result<OpHealthReporterRecoverDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterRecoverDoReply",
            r#type.and_then(|t| OpHealthReporterRecoverDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpHealthReporterRecoverDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterRecoverDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterRecoverDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterRecoverDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterRecoverDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpHealthReporterRecoverDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpHealthReporterRecoverDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpHealthReporterRecoverDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpHealthReporterRecoverDoRequest<&mut Vec<u8>> {
        PushOpHealthReporterRecoverDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpHealthReporterRecoverDoRequest<RequestBuf<'r>> {
        PushOpHealthReporterRecoverDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpHealthReporterRecoverDoRequest<'_> {
    type ReplyType<'buf> = IterableOpHealthReporterRecoverDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpHealthReporterRecoverDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpHealthReporterRecoverDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Diagnose health reporter instances."]
pub struct PushOpHealthReporterDiagnoseDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterDiagnoseDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterDiagnoseDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(55u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            115u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_health_reporter_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 115u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterDiagnoseDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Diagnose health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterDiagnoseDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    HealthReporterName(&'a CStr),
}
impl<'a> IterableOpHealthReporterDiagnoseDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDiagnoseDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDiagnoseDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDiagnoseDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDiagnoseDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDiagnoseDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDiagnoseDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDiagnoseDoRequest::HealthReporterName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDiagnoseDoRequest",
            "HealthReporterName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpHealthReporterDiagnoseDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterDiagnoseDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterDiagnoseDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterDiagnoseDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterDiagnoseDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterDiagnoseDoRequest<'a> {
    type Item = Result<OpHealthReporterDiagnoseDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpHealthReporterDiagnoseDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpHealthReporterDiagnoseDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpHealthReporterDiagnoseDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                115u16 => OpHealthReporterDiagnoseDoRequest::HealthReporterName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterDiagnoseDoRequest",
            r#type.and_then(|t| OpHealthReporterDiagnoseDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpHealthReporterDiagnoseDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterDiagnoseDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpHealthReporterDiagnoseDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpHealthReporterDiagnoseDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpHealthReporterDiagnoseDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpHealthReporterDiagnoseDoRequest::HealthReporterName(val) => {
                    fmt.field("HealthReporterName", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterDiagnoseDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterDiagnoseDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterDiagnoseDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpHealthReporterDiagnoseDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpHealthReporterDiagnoseDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpHealthReporterDiagnoseDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpHealthReporterDiagnoseDoRequest::HealthReporterName(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpHealthReporterDiagnoseDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Diagnose health reporter instances."]
pub struct PushOpHealthReporterDiagnoseDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterDiagnoseDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterDiagnoseDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(55u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterDiagnoseDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Diagnose health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterDiagnoseDoReply {}
impl<'a> IterableOpHealthReporterDiagnoseDoReply<'a> {}
impl OpHealthReporterDiagnoseDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterDiagnoseDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterDiagnoseDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterDiagnoseDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterDiagnoseDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterDiagnoseDoReply<'a> {
    type Item = Result<OpHealthReporterDiagnoseDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterDiagnoseDoReply",
            r#type.and_then(|t| OpHealthReporterDiagnoseDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpHealthReporterDiagnoseDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterDiagnoseDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterDiagnoseDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterDiagnoseDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterDiagnoseDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpHealthReporterDiagnoseDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpHealthReporterDiagnoseDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpHealthReporterDiagnoseDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpHealthReporterDiagnoseDoRequest<&mut Vec<u8>> {
        PushOpHealthReporterDiagnoseDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpHealthReporterDiagnoseDoRequest<RequestBuf<'r>> {
        PushOpHealthReporterDiagnoseDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpHealthReporterDiagnoseDoRequest<'_> {
    type ReplyType<'buf> = IterableOpHealthReporterDiagnoseDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpHealthReporterDiagnoseDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpHealthReporterDiagnoseDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Dump health reporter instances."]
pub struct PushOpHealthReporterDumpGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterDumpGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterDumpGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(56u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            115u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_health_reporter_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 115u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterDumpGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Dump health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterDumpGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    HealthReporterName(&'a CStr),
}
impl<'a> IterableOpHealthReporterDumpGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDumpGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDumpGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDumpGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDumpGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDumpGetDumpRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDumpGetDumpRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDumpGetDumpRequest::HealthReporterName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDumpGetDumpRequest",
            "HealthReporterName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpHealthReporterDumpGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterDumpGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterDumpGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterDumpGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterDumpGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterDumpGetDumpRequest<'a> {
    type Item = Result<OpHealthReporterDumpGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpHealthReporterDumpGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpHealthReporterDumpGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpHealthReporterDumpGetDumpRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                115u16 => OpHealthReporterDumpGetDumpRequest::HealthReporterName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterDumpGetDumpRequest",
            r#type.and_then(|t| OpHealthReporterDumpGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpHealthReporterDumpGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterDumpGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpHealthReporterDumpGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpHealthReporterDumpGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
                OpHealthReporterDumpGetDumpRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpHealthReporterDumpGetDumpRequest::HealthReporterName(val) => {
                    fmt.field("HealthReporterName", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterDumpGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterDumpGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterDumpGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpHealthReporterDumpGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpHealthReporterDumpGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpHealthReporterDumpGetDumpRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpHealthReporterDumpGetDumpRequest::HealthReporterName(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpHealthReporterDumpGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Dump health reporter instances."]
pub struct PushOpHealthReporterDumpGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterDumpGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterDumpGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(56u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn nested_fmsg(mut self) -> PushDlFmsg<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 106u16);
        PushDlFmsg {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterDumpGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Dump health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterDumpGetDumpReply<'a> {
    Fmsg(IterableDlFmsg<'a>),
}
impl<'a> IterableOpHealthReporterDumpGetDumpReply<'a> {
    pub fn get_fmsg(&self) -> Result<IterableDlFmsg<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDumpGetDumpReply::Fmsg(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDumpGetDumpReply",
            "Fmsg",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpHealthReporterDumpGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterDumpGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterDumpGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterDumpGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterDumpGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterDumpGetDumpReply<'a> {
    type Item = Result<OpHealthReporterDumpGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                106u16 => OpHealthReporterDumpGetDumpReply::Fmsg({
                    let res = Some(IterableDlFmsg::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterDumpGetDumpReply",
            r#type.and_then(|t| OpHealthReporterDumpGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpHealthReporterDumpGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterDumpGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpHealthReporterDumpGetDumpReply::Fmsg(val) => fmt.field("Fmsg", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterDumpGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterDumpGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterDumpGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpHealthReporterDumpGetDumpReply::Fmsg(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpHealthReporterDumpGetDumpReply", cur));
        }
        (stack, missing)
    }
}
#[derive(Debug)]
pub struct RequestOpHealthReporterDumpGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpHealthReporterDumpGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpHealthReporterDumpGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpHealthReporterDumpGetDumpRequest<&mut Vec<u8>> {
        PushOpHealthReporterDumpGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpHealthReporterDumpGetDumpRequest<RequestBuf<'r>> {
        PushOpHealthReporterDumpGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpHealthReporterDumpGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpHealthReporterDumpGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpHealthReporterDumpGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpHealthReporterDumpGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Clear dump of health reporter instances."]
pub struct PushOpHealthReporterDumpClearDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterDumpClearDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterDumpClearDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(57u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            115u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_health_reporter_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 115u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterDumpClearDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Clear dump of health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterDumpClearDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    HealthReporterName(&'a CStr),
}
impl<'a> IterableOpHealthReporterDumpClearDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDumpClearDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDumpClearDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDumpClearDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDumpClearDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDumpClearDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDumpClearDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterDumpClearDoRequest::HealthReporterName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterDumpClearDoRequest",
            "HealthReporterName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpHealthReporterDumpClearDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterDumpClearDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterDumpClearDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterDumpClearDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterDumpClearDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterDumpClearDoRequest<'a> {
    type Item = Result<OpHealthReporterDumpClearDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpHealthReporterDumpClearDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpHealthReporterDumpClearDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpHealthReporterDumpClearDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                115u16 => OpHealthReporterDumpClearDoRequest::HealthReporterName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterDumpClearDoRequest",
            r#type.and_then(|t| OpHealthReporterDumpClearDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpHealthReporterDumpClearDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterDumpClearDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpHealthReporterDumpClearDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpHealthReporterDumpClearDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpHealthReporterDumpClearDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpHealthReporterDumpClearDoRequest::HealthReporterName(val) => {
                    fmt.field("HealthReporterName", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterDumpClearDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterDumpClearDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterDumpClearDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpHealthReporterDumpClearDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpHealthReporterDumpClearDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpHealthReporterDumpClearDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpHealthReporterDumpClearDoRequest::HealthReporterName(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpHealthReporterDumpClearDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Clear dump of health reporter instances."]
pub struct PushOpHealthReporterDumpClearDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterDumpClearDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterDumpClearDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(57u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterDumpClearDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Clear dump of health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterDumpClearDoReply {}
impl<'a> IterableOpHealthReporterDumpClearDoReply<'a> {}
impl OpHealthReporterDumpClearDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterDumpClearDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterDumpClearDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterDumpClearDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterDumpClearDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterDumpClearDoReply<'a> {
    type Item = Result<OpHealthReporterDumpClearDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterDumpClearDoReply",
            r#type.and_then(|t| OpHealthReporterDumpClearDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpHealthReporterDumpClearDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterDumpClearDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterDumpClearDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterDumpClearDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterDumpClearDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpHealthReporterDumpClearDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpHealthReporterDumpClearDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpHealthReporterDumpClearDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpHealthReporterDumpClearDoRequest<&mut Vec<u8>> {
        PushOpHealthReporterDumpClearDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpHealthReporterDumpClearDoRequest<RequestBuf<'r>> {
        PushOpHealthReporterDumpClearDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpHealthReporterDumpClearDoRequest<'_> {
    type ReplyType<'buf> = IterableOpHealthReporterDumpClearDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpHealthReporterDumpClearDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpHealthReporterDumpClearDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Flash update devlink instances."]
pub struct PushOpFlashUpdateDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpFlashUpdateDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpFlashUpdateDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(58u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_flash_update_file_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            122u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_flash_update_file_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 122u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_flash_update_component(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            123u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_flash_update_component_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 123u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Associated type: \"FlashOverwrite\" (1 bit per enumeration)"]
    pub fn push_flash_update_overwrite_mask(mut self, value: PushBuiltinBitfield32) -> Self {
        push_header(self.as_rec_mut(), 152u16, value.as_slice().len() as u16);
        self.as_rec_mut().extend(value.as_slice());
        self
    }
}
impl<Prev: Rec> Drop for PushOpFlashUpdateDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Flash update devlink instances."]
#[derive(Clone)]
pub enum OpFlashUpdateDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    FlashUpdateFileName(&'a CStr),
    FlashUpdateComponent(&'a CStr),
    #[doc = "Associated type: \"FlashOverwrite\" (1 bit per enumeration)"]
    FlashUpdateOverwriteMask(PushBuiltinBitfield32),
}
impl<'a> IterableOpFlashUpdateDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpFlashUpdateDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpFlashUpdateDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpFlashUpdateDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpFlashUpdateDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flash_update_file_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpFlashUpdateDoRequest::FlashUpdateFileName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpFlashUpdateDoRequest",
            "FlashUpdateFileName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_flash_update_component(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpFlashUpdateDoRequest::FlashUpdateComponent(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpFlashUpdateDoRequest",
            "FlashUpdateComponent",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"FlashOverwrite\" (1 bit per enumeration)"]
    pub fn get_flash_update_overwrite_mask(&self) -> Result<PushBuiltinBitfield32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpFlashUpdateDoRequest::FlashUpdateOverwriteMask(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpFlashUpdateDoRequest",
            "FlashUpdateOverwriteMask",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpFlashUpdateDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpFlashUpdateDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpFlashUpdateDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpFlashUpdateDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpFlashUpdateDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpFlashUpdateDoRequest<'a> {
    type Item = Result<OpFlashUpdateDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpFlashUpdateDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpFlashUpdateDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                122u16 => OpFlashUpdateDoRequest::FlashUpdateFileName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                123u16 => OpFlashUpdateDoRequest::FlashUpdateComponent({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                152u16 => OpFlashUpdateDoRequest::FlashUpdateOverwriteMask({
                    let res = PushBuiltinBitfield32::new_from_slice(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpFlashUpdateDoRequest",
            r#type.and_then(|t| OpFlashUpdateDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpFlashUpdateDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpFlashUpdateDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpFlashUpdateDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpFlashUpdateDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpFlashUpdateDoRequest::FlashUpdateFileName(val) => {
                    fmt.field("FlashUpdateFileName", &val)
                }
                OpFlashUpdateDoRequest::FlashUpdateComponent(val) => {
                    fmt.field("FlashUpdateComponent", &val)
                }
                OpFlashUpdateDoRequest::FlashUpdateOverwriteMask(val) => fmt.field(
                    "FlashUpdateOverwriteMask",
                    &FormatFlags(val.value().into(), |val| {
                        FlashOverwrite::from_value(val.trailing_zeros().into())
                    }),
                ),
            };
        }
        fmt.finish()
    }
}
impl IterableOpFlashUpdateDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpFlashUpdateDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpFlashUpdateDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpFlashUpdateDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpFlashUpdateDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpFlashUpdateDoRequest::FlashUpdateFileName(val) => {
                    if last_off == offset {
                        stack.push(("FlashUpdateFileName", last_off));
                        break;
                    }
                }
                OpFlashUpdateDoRequest::FlashUpdateComponent(val) => {
                    if last_off == offset {
                        stack.push(("FlashUpdateComponent", last_off));
                        break;
                    }
                }
                OpFlashUpdateDoRequest::FlashUpdateOverwriteMask(val) => {
                    if last_off == offset {
                        stack.push(("FlashUpdateOverwriteMask", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpFlashUpdateDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Flash update devlink instances."]
pub struct PushOpFlashUpdateDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpFlashUpdateDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpFlashUpdateDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(58u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpFlashUpdateDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Flash update devlink instances."]
#[derive(Clone)]
pub enum OpFlashUpdateDoReply {}
impl<'a> IterableOpFlashUpdateDoReply<'a> {}
impl OpFlashUpdateDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpFlashUpdateDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpFlashUpdateDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpFlashUpdateDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpFlashUpdateDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpFlashUpdateDoReply<'a> {
    type Item = Result<OpFlashUpdateDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpFlashUpdateDoReply",
            r#type.and_then(|t| OpFlashUpdateDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpFlashUpdateDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpFlashUpdateDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpFlashUpdateDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpFlashUpdateDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpFlashUpdateDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpFlashUpdateDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpFlashUpdateDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpFlashUpdateDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpFlashUpdateDoRequest<&mut Vec<u8>> {
        PushOpFlashUpdateDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpFlashUpdateDoRequest<RequestBuf<'r>> {
        PushOpFlashUpdateDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpFlashUpdateDoRequest<'_> {
    type ReplyType<'buf> = IterableOpFlashUpdateDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpFlashUpdateDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpFlashUpdateDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get trap instances."]
pub struct PushOpTrapGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(61u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap instances."]
#[derive(Clone)]
pub enum OpTrapGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpTrapGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapGetDumpRequest<'a> {
    type Item = Result<OpTrapGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapGetDumpRequest",
            r#type.and_then(|t| OpTrapGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpTrapGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get trap instances."]
pub struct PushOpTrapGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(63u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            130u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_trap_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 130u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap instances."]
#[derive(Clone)]
pub enum OpTrapGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    TrapName(&'a CStr),
}
impl<'a> IterableOpTrapGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGetDumpReply::TrapName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGetDumpReply",
            "TrapName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapGetDumpReply<'a> {
    type Item = Result<OpTrapGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                130u16 => OpTrapGetDumpReply::TrapName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapGetDumpReply",
            r#type.and_then(|t| OpTrapGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpTrapGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpTrapGetDumpReply::TrapName(val) => fmt.field("TrapName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapGetDumpReply::TrapName(val) => {
                    if last_off == offset {
                        stack.push(("TrapName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpTrapGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpTrapGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpTrapGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpTrapGetDumpRequest<&mut Vec<u8>> {
        PushOpTrapGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpTrapGetDumpRequest<RequestBuf<'r>> {
        PushOpTrapGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpTrapGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpTrapGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpTrapGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpTrapGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get trap instances."]
pub struct PushOpTrapGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(61u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            130u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_trap_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 130u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap instances."]
#[derive(Clone)]
pub enum OpTrapGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    TrapName(&'a CStr),
}
impl<'a> IterableOpTrapGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGetDoRequest::TrapName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGetDoRequest",
            "TrapName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapGetDoRequest<'a> {
    type Item = Result<OpTrapGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                130u16 => OpTrapGetDoRequest::TrapName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapGetDoRequest",
            r#type.and_then(|t| OpTrapGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpTrapGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpTrapGetDoRequest::TrapName(val) => fmt.field("TrapName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapGetDoRequest::TrapName(val) => {
                    if last_off == offset {
                        stack.push(("TrapName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get trap instances."]
pub struct PushOpTrapGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(63u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            130u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_trap_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 130u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap instances."]
#[derive(Clone)]
pub enum OpTrapGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    TrapName(&'a CStr),
}
impl<'a> IterableOpTrapGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGetDoReply::TrapName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGetDoReply",
            "TrapName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapGetDoReply<'a> {
    type Item = Result<OpTrapGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                130u16 => OpTrapGetDoReply::TrapName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapGetDoReply",
            r#type.and_then(|t| OpTrapGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpTrapGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpTrapGetDoReply::TrapName(val) => fmt.field("TrapName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapGetDoReply::TrapName(val) => {
                    if last_off == offset {
                        stack.push(("TrapName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpTrapGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpTrapGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpTrapGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpTrapGetDoRequest<&mut Vec<u8>> {
        PushOpTrapGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpTrapGetDoRequest<RequestBuf<'r>> {
        PushOpTrapGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpTrapGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpTrapGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpTrapGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpTrapGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set trap instances."]
pub struct PushOpTrapSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(62u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            130u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_trap_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 130u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Associated type: \"TrapAction\" (enum)"]
    pub fn push_trap_action(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 131u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set trap instances."]
#[derive(Clone)]
pub enum OpTrapSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    TrapName(&'a CStr),
    #[doc = "Associated type: \"TrapAction\" (enum)"]
    TrapAction(u8),
}
impl<'a> IterableOpTrapSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapSetDoRequest::TrapName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapSetDoRequest",
            "TrapName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"TrapAction\" (enum)"]
    pub fn get_trap_action(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapSetDoRequest::TrapAction(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapSetDoRequest",
            "TrapAction",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapSetDoRequest<'a> {
    type Item = Result<OpTrapSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                130u16 => OpTrapSetDoRequest::TrapName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                131u16 => OpTrapSetDoRequest::TrapAction({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapSetDoRequest",
            r#type.and_then(|t| OpTrapSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpTrapSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpTrapSetDoRequest::TrapName(val) => fmt.field("TrapName", &val),
                OpTrapSetDoRequest::TrapAction(val) => fmt.field(
                    "TrapAction",
                    &FormatEnum(val.into(), TrapAction::from_value),
                ),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapSetDoRequest::TrapName(val) => {
                    if last_off == offset {
                        stack.push(("TrapName", last_off));
                        break;
                    }
                }
                OpTrapSetDoRequest::TrapAction(val) => {
                    if last_off == offset {
                        stack.push(("TrapAction", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set trap instances."]
pub struct PushOpTrapSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(62u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpTrapSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set trap instances."]
#[derive(Clone)]
pub enum OpTrapSetDoReply {}
impl<'a> IterableOpTrapSetDoReply<'a> {}
impl OpTrapSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapSetDoReply<'a> {
    type Item = Result<OpTrapSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapSetDoReply",
            r#type.and_then(|t| OpTrapSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpTrapSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpTrapSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpTrapSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpTrapSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpTrapSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpTrapSetDoRequest<&mut Vec<u8>> {
        PushOpTrapSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpTrapSetDoRequest<RequestBuf<'r>> {
        PushOpTrapSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpTrapSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpTrapSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpTrapSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpTrapSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get trap group instances."]
pub struct PushOpTrapGroupGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapGroupGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapGroupGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(65u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapGroupGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap group instances."]
#[derive(Clone)]
pub enum OpTrapGroupGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpTrapGroupGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapGroupGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapGroupGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapGroupGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapGroupGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapGroupGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapGroupGetDumpRequest<'a> {
    type Item = Result<OpTrapGroupGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapGroupGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapGroupGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapGroupGetDumpRequest",
            r#type.and_then(|t| OpTrapGroupGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapGroupGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapGroupGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapGroupGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpTrapGroupGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapGroupGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapGroupGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapGroupGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapGroupGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapGroupGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapGroupGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get trap group instances."]
pub struct PushOpTrapGroupGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapGroupGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapGroupGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(67u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_group_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            135u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_trap_group_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 135u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapGroupGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap group instances."]
#[derive(Clone)]
pub enum OpTrapGroupGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    TrapGroupName(&'a CStr),
}
impl<'a> IterableOpTrapGroupGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_group_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupGetDumpReply::TrapGroupName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupGetDumpReply",
            "TrapGroupName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapGroupGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapGroupGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapGroupGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapGroupGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapGroupGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapGroupGetDumpReply<'a> {
    type Item = Result<OpTrapGroupGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapGroupGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapGroupGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                135u16 => OpTrapGroupGetDumpReply::TrapGroupName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapGroupGetDumpReply",
            r#type.and_then(|t| OpTrapGroupGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapGroupGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapGroupGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapGroupGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpTrapGroupGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpTrapGroupGetDumpReply::TrapGroupName(val) => fmt.field("TrapGroupName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapGroupGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapGroupGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapGroupGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapGroupGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapGroupGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapGroupGetDumpReply::TrapGroupName(val) => {
                    if last_off == offset {
                        stack.push(("TrapGroupName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapGroupGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpTrapGroupGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpTrapGroupGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpTrapGroupGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpTrapGroupGetDumpRequest<&mut Vec<u8>> {
        PushOpTrapGroupGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpTrapGroupGetDumpRequest<RequestBuf<'r>> {
        PushOpTrapGroupGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpTrapGroupGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpTrapGroupGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpTrapGroupGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpTrapGroupGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get trap group instances."]
pub struct PushOpTrapGroupGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapGroupGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapGroupGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(65u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_group_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            135u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_trap_group_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 135u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapGroupGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap group instances."]
#[derive(Clone)]
pub enum OpTrapGroupGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    TrapGroupName(&'a CStr),
}
impl<'a> IterableOpTrapGroupGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_group_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupGetDoRequest::TrapGroupName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupGetDoRequest",
            "TrapGroupName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapGroupGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapGroupGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapGroupGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapGroupGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapGroupGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapGroupGetDoRequest<'a> {
    type Item = Result<OpTrapGroupGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapGroupGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapGroupGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                135u16 => OpTrapGroupGetDoRequest::TrapGroupName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapGroupGetDoRequest",
            r#type.and_then(|t| OpTrapGroupGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapGroupGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapGroupGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapGroupGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpTrapGroupGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpTrapGroupGetDoRequest::TrapGroupName(val) => fmt.field("TrapGroupName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapGroupGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapGroupGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapGroupGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapGroupGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapGroupGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapGroupGetDoRequest::TrapGroupName(val) => {
                    if last_off == offset {
                        stack.push(("TrapGroupName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapGroupGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get trap group instances."]
pub struct PushOpTrapGroupGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapGroupGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapGroupGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(67u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_group_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            135u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_trap_group_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 135u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapGroupGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap group instances."]
#[derive(Clone)]
pub enum OpTrapGroupGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    TrapGroupName(&'a CStr),
}
impl<'a> IterableOpTrapGroupGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_group_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupGetDoReply::TrapGroupName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupGetDoReply",
            "TrapGroupName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapGroupGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapGroupGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapGroupGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapGroupGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapGroupGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapGroupGetDoReply<'a> {
    type Item = Result<OpTrapGroupGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapGroupGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapGroupGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                135u16 => OpTrapGroupGetDoReply::TrapGroupName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapGroupGetDoReply",
            r#type.and_then(|t| OpTrapGroupGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapGroupGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapGroupGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapGroupGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpTrapGroupGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpTrapGroupGetDoReply::TrapGroupName(val) => fmt.field("TrapGroupName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapGroupGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapGroupGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapGroupGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapGroupGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapGroupGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapGroupGetDoReply::TrapGroupName(val) => {
                    if last_off == offset {
                        stack.push(("TrapGroupName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapGroupGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpTrapGroupGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpTrapGroupGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpTrapGroupGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpTrapGroupGetDoRequest<&mut Vec<u8>> {
        PushOpTrapGroupGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpTrapGroupGetDoRequest<RequestBuf<'r>> {
        PushOpTrapGroupGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpTrapGroupGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpTrapGroupGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpTrapGroupGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpTrapGroupGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set trap group instances."]
pub struct PushOpTrapGroupSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapGroupSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapGroupSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(66u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    #[doc = "Associated type: \"TrapAction\" (enum)"]
    pub fn push_trap_action(mut self, value: u8) -> Self {
        push_header(self.as_rec_mut(), 131u16, 1 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_trap_group_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            135u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_trap_group_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 135u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_policer_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 142u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapGroupSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set trap group instances."]
#[derive(Clone)]
pub enum OpTrapGroupSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    #[doc = "Associated type: \"TrapAction\" (enum)"]
    TrapAction(u8),
    TrapGroupName(&'a CStr),
    TrapPolicerId(u32),
}
impl<'a> IterableOpTrapGroupSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Associated type: \"TrapAction\" (enum)"]
    pub fn get_trap_action(&self) -> Result<u8, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupSetDoRequest::TrapAction(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupSetDoRequest",
            "TrapAction",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_group_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupSetDoRequest::TrapGroupName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupSetDoRequest",
            "TrapGroupName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_policer_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapGroupSetDoRequest::TrapPolicerId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapGroupSetDoRequest",
            "TrapPolicerId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapGroupSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapGroupSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapGroupSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapGroupSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapGroupSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapGroupSetDoRequest<'a> {
    type Item = Result<OpTrapGroupSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapGroupSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapGroupSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                131u16 => OpTrapGroupSetDoRequest::TrapAction({
                    let res = parse_u8(next);
                    let Some(val) = res else { break };
                    val
                }),
                135u16 => OpTrapGroupSetDoRequest::TrapGroupName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                142u16 => OpTrapGroupSetDoRequest::TrapPolicerId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapGroupSetDoRequest",
            r#type.and_then(|t| OpTrapGroupSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapGroupSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapGroupSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapGroupSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpTrapGroupSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpTrapGroupSetDoRequest::TrapAction(val) => fmt.field(
                    "TrapAction",
                    &FormatEnum(val.into(), TrapAction::from_value),
                ),
                OpTrapGroupSetDoRequest::TrapGroupName(val) => fmt.field("TrapGroupName", &val),
                OpTrapGroupSetDoRequest::TrapPolicerId(val) => fmt.field("TrapPolicerId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapGroupSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapGroupSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapGroupSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapGroupSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapGroupSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapGroupSetDoRequest::TrapAction(val) => {
                    if last_off == offset {
                        stack.push(("TrapAction", last_off));
                        break;
                    }
                }
                OpTrapGroupSetDoRequest::TrapGroupName(val) => {
                    if last_off == offset {
                        stack.push(("TrapGroupName", last_off));
                        break;
                    }
                }
                OpTrapGroupSetDoRequest::TrapPolicerId(val) => {
                    if last_off == offset {
                        stack.push(("TrapPolicerId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapGroupSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set trap group instances."]
pub struct PushOpTrapGroupSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapGroupSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapGroupSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(66u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpTrapGroupSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set trap group instances."]
#[derive(Clone)]
pub enum OpTrapGroupSetDoReply {}
impl<'a> IterableOpTrapGroupSetDoReply<'a> {}
impl OpTrapGroupSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapGroupSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapGroupSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapGroupSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapGroupSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapGroupSetDoReply<'a> {
    type Item = Result<OpTrapGroupSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapGroupSetDoReply",
            r#type.and_then(|t| OpTrapGroupSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpTrapGroupSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapGroupSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpTrapGroupSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapGroupSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapGroupSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpTrapGroupSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpTrapGroupSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpTrapGroupSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpTrapGroupSetDoRequest<&mut Vec<u8>> {
        PushOpTrapGroupSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpTrapGroupSetDoRequest<RequestBuf<'r>> {
        PushOpTrapGroupSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpTrapGroupSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpTrapGroupSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpTrapGroupSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpTrapGroupSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get trap policer instances."]
pub struct PushOpTrapPolicerGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapPolicerGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapPolicerGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(69u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapPolicerGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap policer instances."]
#[derive(Clone)]
pub enum OpTrapPolicerGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpTrapPolicerGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapPolicerGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapPolicerGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapPolicerGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapPolicerGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapPolicerGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapPolicerGetDumpRequest<'a> {
    type Item = Result<OpTrapPolicerGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapPolicerGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapPolicerGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapPolicerGetDumpRequest",
            r#type.and_then(|t| OpTrapPolicerGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapPolicerGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapPolicerGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapPolicerGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpTrapPolicerGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapPolicerGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapPolicerGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapPolicerGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapPolicerGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapPolicerGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapPolicerGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get trap policer instances."]
pub struct PushOpTrapPolicerGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapPolicerGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapPolicerGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(71u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_policer_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 142u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapPolicerGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap policer instances."]
#[derive(Clone)]
pub enum OpTrapPolicerGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    TrapPolicerId(u32),
}
impl<'a> IterableOpTrapPolicerGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_policer_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerGetDumpReply::TrapPolicerId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerGetDumpReply",
            "TrapPolicerId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapPolicerGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapPolicerGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapPolicerGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapPolicerGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapPolicerGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapPolicerGetDumpReply<'a> {
    type Item = Result<OpTrapPolicerGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapPolicerGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapPolicerGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                142u16 => OpTrapPolicerGetDumpReply::TrapPolicerId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapPolicerGetDumpReply",
            r#type.and_then(|t| OpTrapPolicerGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapPolicerGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapPolicerGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapPolicerGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpTrapPolicerGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpTrapPolicerGetDumpReply::TrapPolicerId(val) => fmt.field("TrapPolicerId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapPolicerGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapPolicerGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapPolicerGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapPolicerGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapPolicerGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapPolicerGetDumpReply::TrapPolicerId(val) => {
                    if last_off == offset {
                        stack.push(("TrapPolicerId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapPolicerGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpTrapPolicerGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpTrapPolicerGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpTrapPolicerGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpTrapPolicerGetDumpRequest<&mut Vec<u8>> {
        PushOpTrapPolicerGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpTrapPolicerGetDumpRequest<RequestBuf<'r>> {
        PushOpTrapPolicerGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpTrapPolicerGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpTrapPolicerGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpTrapPolicerGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpTrapPolicerGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get trap policer instances."]
pub struct PushOpTrapPolicerGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapPolicerGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapPolicerGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(69u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_policer_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 142u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapPolicerGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap policer instances."]
#[derive(Clone)]
pub enum OpTrapPolicerGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    TrapPolicerId(u32),
}
impl<'a> IterableOpTrapPolicerGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_policer_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerGetDoRequest::TrapPolicerId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerGetDoRequest",
            "TrapPolicerId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapPolicerGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapPolicerGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapPolicerGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapPolicerGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapPolicerGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapPolicerGetDoRequest<'a> {
    type Item = Result<OpTrapPolicerGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapPolicerGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapPolicerGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                142u16 => OpTrapPolicerGetDoRequest::TrapPolicerId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapPolicerGetDoRequest",
            r#type.and_then(|t| OpTrapPolicerGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapPolicerGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapPolicerGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapPolicerGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpTrapPolicerGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpTrapPolicerGetDoRequest::TrapPolicerId(val) => fmt.field("TrapPolicerId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapPolicerGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapPolicerGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapPolicerGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapPolicerGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapPolicerGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapPolicerGetDoRequest::TrapPolicerId(val) => {
                    if last_off == offset {
                        stack.push(("TrapPolicerId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapPolicerGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get trap policer instances."]
pub struct PushOpTrapPolicerGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapPolicerGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapPolicerGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(71u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_policer_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 142u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapPolicerGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap policer instances."]
#[derive(Clone)]
pub enum OpTrapPolicerGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    TrapPolicerId(u32),
}
impl<'a> IterableOpTrapPolicerGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_policer_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerGetDoReply::TrapPolicerId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerGetDoReply",
            "TrapPolicerId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapPolicerGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapPolicerGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapPolicerGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapPolicerGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapPolicerGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapPolicerGetDoReply<'a> {
    type Item = Result<OpTrapPolicerGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapPolicerGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapPolicerGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                142u16 => OpTrapPolicerGetDoReply::TrapPolicerId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapPolicerGetDoReply",
            r#type.and_then(|t| OpTrapPolicerGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapPolicerGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapPolicerGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapPolicerGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpTrapPolicerGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpTrapPolicerGetDoReply::TrapPolicerId(val) => fmt.field("TrapPolicerId", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapPolicerGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapPolicerGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapPolicerGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapPolicerGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapPolicerGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapPolicerGetDoReply::TrapPolicerId(val) => {
                    if last_off == offset {
                        stack.push(("TrapPolicerId", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapPolicerGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpTrapPolicerGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpTrapPolicerGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpTrapPolicerGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpTrapPolicerGetDoRequest<&mut Vec<u8>> {
        PushOpTrapPolicerGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpTrapPolicerGetDoRequest<RequestBuf<'r>> {
        PushOpTrapPolicerGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpTrapPolicerGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpTrapPolicerGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpTrapPolicerGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpTrapPolicerGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get trap policer instances."]
pub struct PushOpTrapPolicerSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapPolicerSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapPolicerSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(70u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_trap_policer_id(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 142u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_trap_policer_rate(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 143u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_trap_policer_burst(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 144u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpTrapPolicerSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap policer instances."]
#[derive(Clone)]
pub enum OpTrapPolicerSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    TrapPolicerId(u32),
    TrapPolicerRate(u64),
    TrapPolicerBurst(u64),
}
impl<'a> IterableOpTrapPolicerSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_policer_id(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerSetDoRequest::TrapPolicerId(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerSetDoRequest",
            "TrapPolicerId",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_policer_rate(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerSetDoRequest::TrapPolicerRate(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerSetDoRequest",
            "TrapPolicerRate",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_trap_policer_burst(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpTrapPolicerSetDoRequest::TrapPolicerBurst(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpTrapPolicerSetDoRequest",
            "TrapPolicerBurst",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpTrapPolicerSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapPolicerSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapPolicerSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapPolicerSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapPolicerSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapPolicerSetDoRequest<'a> {
    type Item = Result<OpTrapPolicerSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpTrapPolicerSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpTrapPolicerSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                142u16 => OpTrapPolicerSetDoRequest::TrapPolicerId({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                143u16 => OpTrapPolicerSetDoRequest::TrapPolicerRate({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                144u16 => OpTrapPolicerSetDoRequest::TrapPolicerBurst({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapPolicerSetDoRequest",
            r#type.and_then(|t| OpTrapPolicerSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpTrapPolicerSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapPolicerSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpTrapPolicerSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpTrapPolicerSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpTrapPolicerSetDoRequest::TrapPolicerId(val) => fmt.field("TrapPolicerId", &val),
                OpTrapPolicerSetDoRequest::TrapPolicerRate(val) => {
                    fmt.field("TrapPolicerRate", &val)
                }
                OpTrapPolicerSetDoRequest::TrapPolicerBurst(val) => {
                    fmt.field("TrapPolicerBurst", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpTrapPolicerSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapPolicerSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapPolicerSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpTrapPolicerSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpTrapPolicerSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpTrapPolicerSetDoRequest::TrapPolicerId(val) => {
                    if last_off == offset {
                        stack.push(("TrapPolicerId", last_off));
                        break;
                    }
                }
                OpTrapPolicerSetDoRequest::TrapPolicerRate(val) => {
                    if last_off == offset {
                        stack.push(("TrapPolicerRate", last_off));
                        break;
                    }
                }
                OpTrapPolicerSetDoRequest::TrapPolicerBurst(val) => {
                    if last_off == offset {
                        stack.push(("TrapPolicerBurst", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpTrapPolicerSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get trap policer instances."]
pub struct PushOpTrapPolicerSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpTrapPolicerSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpTrapPolicerSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(70u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpTrapPolicerSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get trap policer instances."]
#[derive(Clone)]
pub enum OpTrapPolicerSetDoReply {}
impl<'a> IterableOpTrapPolicerSetDoReply<'a> {}
impl OpTrapPolicerSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpTrapPolicerSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpTrapPolicerSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpTrapPolicerSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpTrapPolicerSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpTrapPolicerSetDoReply<'a> {
    type Item = Result<OpTrapPolicerSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpTrapPolicerSetDoReply",
            r#type.and_then(|t| OpTrapPolicerSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpTrapPolicerSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpTrapPolicerSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpTrapPolicerSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpTrapPolicerSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpTrapPolicerSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpTrapPolicerSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpTrapPolicerSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpTrapPolicerSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpTrapPolicerSetDoRequest<&mut Vec<u8>> {
        PushOpTrapPolicerSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpTrapPolicerSetDoRequest<RequestBuf<'r>> {
        PushOpTrapPolicerSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpTrapPolicerSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpTrapPolicerSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpTrapPolicerSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpTrapPolicerSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Test health reporter instances."]
pub struct PushOpHealthReporterTestDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterTestDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterTestDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(73u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_health_reporter_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            115u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_health_reporter_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 115u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterTestDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Test health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterTestDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    HealthReporterName(&'a CStr),
}
impl<'a> IterableOpHealthReporterTestDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterTestDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterTestDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterTestDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterTestDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterTestDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterTestDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_health_reporter_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpHealthReporterTestDoRequest::HealthReporterName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpHealthReporterTestDoRequest",
            "HealthReporterName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpHealthReporterTestDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterTestDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterTestDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterTestDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterTestDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterTestDoRequest<'a> {
    type Item = Result<OpHealthReporterTestDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpHealthReporterTestDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpHealthReporterTestDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpHealthReporterTestDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                115u16 => OpHealthReporterTestDoRequest::HealthReporterName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterTestDoRequest",
            r#type.and_then(|t| OpHealthReporterTestDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpHealthReporterTestDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterTestDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpHealthReporterTestDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpHealthReporterTestDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpHealthReporterTestDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpHealthReporterTestDoRequest::HealthReporterName(val) => {
                    fmt.field("HealthReporterName", &val)
                }
            };
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterTestDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterTestDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterTestDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpHealthReporterTestDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpHealthReporterTestDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpHealthReporterTestDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpHealthReporterTestDoRequest::HealthReporterName(val) => {
                    if last_off == offset {
                        stack.push(("HealthReporterName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpHealthReporterTestDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Test health reporter instances."]
pub struct PushOpHealthReporterTestDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpHealthReporterTestDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpHealthReporterTestDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(73u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpHealthReporterTestDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Test health reporter instances."]
#[derive(Clone)]
pub enum OpHealthReporterTestDoReply {}
impl<'a> IterableOpHealthReporterTestDoReply<'a> {}
impl OpHealthReporterTestDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpHealthReporterTestDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpHealthReporterTestDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpHealthReporterTestDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpHealthReporterTestDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpHealthReporterTestDoReply<'a> {
    type Item = Result<OpHealthReporterTestDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpHealthReporterTestDoReply",
            r#type.and_then(|t| OpHealthReporterTestDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpHealthReporterTestDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpHealthReporterTestDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpHealthReporterTestDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpHealthReporterTestDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpHealthReporterTestDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpHealthReporterTestDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpHealthReporterTestDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpHealthReporterTestDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpHealthReporterTestDoRequest<&mut Vec<u8>> {
        PushOpHealthReporterTestDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpHealthReporterTestDoRequest<RequestBuf<'r>> {
        PushOpHealthReporterTestDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpHealthReporterTestDoRequest<'_> {
    type ReplyType<'buf> = IterableOpHealthReporterTestDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpHealthReporterTestDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpHealthReporterTestDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get rate instances."]
pub struct PushOpRateGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRateGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRateGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(74u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpRateGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get rate instances."]
#[derive(Clone)]
pub enum OpRateGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpRateGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRateGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRateGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRateGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRateGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRateGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRateGetDumpRequest<'a> {
    type Item = Result<OpRateGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRateGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRateGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRateGetDumpRequest",
            r#type.and_then(|t| OpRateGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRateGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRateGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRateGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpRateGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRateGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRateGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRateGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRateGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRateGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRateGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get rate instances."]
pub struct PushOpRateGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRateGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRateGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(76u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_node_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            168u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_rate_node_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 168u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpRateGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get rate instances."]
#[derive(Clone)]
pub enum OpRateGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    RateNodeName(&'a CStr),
}
impl<'a> IterableOpRateGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDumpReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDumpReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_node_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDumpReply::RateNodeName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDumpReply",
            "RateNodeName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRateGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRateGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRateGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRateGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRateGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRateGetDumpReply<'a> {
    type Item = Result<OpRateGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRateGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRateGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpRateGetDumpReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                168u16 => OpRateGetDumpReply::RateNodeName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRateGetDumpReply",
            r#type.and_then(|t| OpRateGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRateGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRateGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRateGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpRateGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpRateGetDumpReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpRateGetDumpReply::RateNodeName(val) => fmt.field("RateNodeName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRateGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRateGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRateGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRateGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRateGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRateGetDumpReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpRateGetDumpReply::RateNodeName(val) => {
                    if last_off == offset {
                        stack.push(("RateNodeName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRateGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpRateGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpRateGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpRateGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpRateGetDumpRequest<&mut Vec<u8>> {
        PushOpRateGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpRateGetDumpRequest<RequestBuf<'r>> {
        PushOpRateGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpRateGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpRateGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpRateGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpRateGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get rate instances."]
pub struct PushOpRateGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRateGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRateGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(74u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_node_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            168u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_rate_node_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 168u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpRateGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get rate instances."]
#[derive(Clone)]
pub enum OpRateGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    RateNodeName(&'a CStr),
}
impl<'a> IterableOpRateGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_node_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDoRequest::RateNodeName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDoRequest",
            "RateNodeName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRateGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRateGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRateGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRateGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRateGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRateGetDoRequest<'a> {
    type Item = Result<OpRateGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRateGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRateGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpRateGetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                168u16 => OpRateGetDoRequest::RateNodeName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRateGetDoRequest",
            r#type.and_then(|t| OpRateGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRateGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRateGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRateGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpRateGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpRateGetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
                OpRateGetDoRequest::RateNodeName(val) => fmt.field("RateNodeName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRateGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRateGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRateGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRateGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRateGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRateGetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpRateGetDoRequest::RateNodeName(val) => {
                    if last_off == offset {
                        stack.push(("RateNodeName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRateGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get rate instances."]
pub struct PushOpRateGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRateGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRateGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(76u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_node_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            168u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_rate_node_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 168u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpRateGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get rate instances."]
#[derive(Clone)]
pub enum OpRateGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
    RateNodeName(&'a CStr),
}
impl<'a> IterableOpRateGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDoReply::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDoReply",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_node_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateGetDoReply::RateNodeName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateGetDoReply",
            "RateNodeName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRateGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRateGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRateGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRateGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRateGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRateGetDoReply<'a> {
    type Item = Result<OpRateGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRateGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRateGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpRateGetDoReply::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                168u16 => OpRateGetDoReply::RateNodeName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRateGetDoReply",
            r#type.and_then(|t| OpRateGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRateGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRateGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRateGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpRateGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpRateGetDoReply::PortIndex(val) => fmt.field("PortIndex", &val),
                OpRateGetDoReply::RateNodeName(val) => fmt.field("RateNodeName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRateGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRateGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRateGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRateGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRateGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRateGetDoReply::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                OpRateGetDoReply::RateNodeName(val) => {
                    if last_off == offset {
                        stack.push(("RateNodeName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRateGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpRateGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpRateGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpRateGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpRateGetDoRequest<&mut Vec<u8>> {
        PushOpRateGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpRateGetDoRequest<RequestBuf<'r>> {
        PushOpRateGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpRateGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpRateGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpRateGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpRateGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set rate instances."]
pub struct PushOpRateSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRateSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRateSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(75u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rate_tx_share(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 166u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_tx_max(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 167u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_node_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            168u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_rate_node_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 168u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rate_parent_node_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            169u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_rate_parent_node_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 169u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rate_tx_priority(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 177u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_tx_weight(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 178u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_rate_tc_bws(mut self) -> PushDlRateTcBws<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 180u16);
        PushDlRateTcBws {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpRateSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set rate instances."]
#[derive(Clone)]
pub enum OpRateSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    RateTxShare(u64),
    RateTxMax(u64),
    RateNodeName(&'a CStr),
    RateParentNodeName(&'a CStr),
    RateTxPriority(u32),
    RateTxWeight(u32),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    RateTcBws(IterableDlRateTcBws<'a>),
}
impl<'a> IterableOpRateSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_share(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateSetDoRequest::RateTxShare(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateSetDoRequest",
            "RateTxShare",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_max(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateSetDoRequest::RateTxMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateSetDoRequest",
            "RateTxMax",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_node_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateSetDoRequest::RateNodeName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateSetDoRequest",
            "RateNodeName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_parent_node_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateSetDoRequest::RateParentNodeName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateSetDoRequest",
            "RateParentNodeName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_priority(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateSetDoRequest::RateTxPriority(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateSetDoRequest",
            "RateTxPriority",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_weight(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateSetDoRequest::RateTxWeight(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateSetDoRequest",
            "RateTxWeight",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_rate_tc_bws(
        &self,
    ) -> MultiAttrIterable<Self, OpRateSetDoRequest<'a>, IterableDlRateTcBws<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpRateSetDoRequest::RateTcBws(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl OpRateSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRateSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRateSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRateSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRateSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRateSetDoRequest<'a> {
    type Item = Result<OpRateSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRateSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRateSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                166u16 => OpRateSetDoRequest::RateTxShare({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                167u16 => OpRateSetDoRequest::RateTxMax({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                168u16 => OpRateSetDoRequest::RateNodeName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                169u16 => OpRateSetDoRequest::RateParentNodeName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                177u16 => OpRateSetDoRequest::RateTxPriority({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                178u16 => OpRateSetDoRequest::RateTxWeight({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                180u16 => OpRateSetDoRequest::RateTcBws({
                    let res = Some(IterableDlRateTcBws::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRateSetDoRequest",
            r#type.and_then(|t| OpRateSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRateSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRateSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRateSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpRateSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpRateSetDoRequest::RateTxShare(val) => fmt.field("RateTxShare", &val),
                OpRateSetDoRequest::RateTxMax(val) => fmt.field("RateTxMax", &val),
                OpRateSetDoRequest::RateNodeName(val) => fmt.field("RateNodeName", &val),
                OpRateSetDoRequest::RateParentNodeName(val) => {
                    fmt.field("RateParentNodeName", &val)
                }
                OpRateSetDoRequest::RateTxPriority(val) => fmt.field("RateTxPriority", &val),
                OpRateSetDoRequest::RateTxWeight(val) => fmt.field("RateTxWeight", &val),
                OpRateSetDoRequest::RateTcBws(val) => fmt.field("RateTcBws", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRateSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRateSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRateSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRateSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRateSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRateSetDoRequest::RateTxShare(val) => {
                    if last_off == offset {
                        stack.push(("RateTxShare", last_off));
                        break;
                    }
                }
                OpRateSetDoRequest::RateTxMax(val) => {
                    if last_off == offset {
                        stack.push(("RateTxMax", last_off));
                        break;
                    }
                }
                OpRateSetDoRequest::RateNodeName(val) => {
                    if last_off == offset {
                        stack.push(("RateNodeName", last_off));
                        break;
                    }
                }
                OpRateSetDoRequest::RateParentNodeName(val) => {
                    if last_off == offset {
                        stack.push(("RateParentNodeName", last_off));
                        break;
                    }
                }
                OpRateSetDoRequest::RateTxPriority(val) => {
                    if last_off == offset {
                        stack.push(("RateTxPriority", last_off));
                        break;
                    }
                }
                OpRateSetDoRequest::RateTxWeight(val) => {
                    if last_off == offset {
                        stack.push(("RateTxWeight", last_off));
                        break;
                    }
                }
                OpRateSetDoRequest::RateTcBws(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRateSetDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Set rate instances."]
pub struct PushOpRateSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRateSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRateSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(75u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpRateSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set rate instances."]
#[derive(Clone)]
pub enum OpRateSetDoReply {}
impl<'a> IterableOpRateSetDoReply<'a> {}
impl OpRateSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRateSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRateSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRateSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRateSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRateSetDoReply<'a> {
    type Item = Result<OpRateSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRateSetDoReply",
            r#type.and_then(|t| OpRateSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpRateSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRateSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpRateSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRateSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRateSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpRateSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpRateSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpRateSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpRateSetDoRequest<&mut Vec<u8>> {
        PushOpRateSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpRateSetDoRequest<RequestBuf<'r>> {
        PushOpRateSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpRateSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpRateSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpRateSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpRateSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Create rate instances."]
pub struct PushOpRateNewDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRateNewDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRateNewDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(76u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rate_tx_share(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 166u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_tx_max(mut self, value: u64) -> Self {
        push_header(self.as_rec_mut(), 167u16, 8 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_node_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            168u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_rate_node_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 168u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rate_parent_node_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            169u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_rate_parent_node_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 169u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rate_tx_priority(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 177u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_rate_tx_weight(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 178u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn nested_rate_tc_bws(mut self) -> PushDlRateTcBws<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 180u16);
        PushDlRateTcBws {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpRateNewDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create rate instances."]
#[derive(Clone)]
pub enum OpRateNewDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    RateTxShare(u64),
    RateTxMax(u64),
    RateNodeName(&'a CStr),
    RateParentNodeName(&'a CStr),
    RateTxPriority(u32),
    RateTxWeight(u32),
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    RateTcBws(IterableDlRateTcBws<'a>),
}
impl<'a> IterableOpRateNewDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateNewDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateNewDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateNewDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateNewDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_share(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateNewDoRequest::RateTxShare(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateNewDoRequest",
            "RateTxShare",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_max(&self) -> Result<u64, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateNewDoRequest::RateTxMax(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateNewDoRequest",
            "RateTxMax",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_node_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateNewDoRequest::RateNodeName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateNewDoRequest",
            "RateNodeName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_parent_node_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateNewDoRequest::RateParentNodeName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateNewDoRequest",
            "RateParentNodeName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_priority(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateNewDoRequest::RateTxPriority(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateNewDoRequest",
            "RateTxPriority",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_tx_weight(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateNewDoRequest::RateTxWeight(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateNewDoRequest",
            "RateTxWeight",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    #[doc = "Attribute may repeat multiple times (treat it as array)"]
    pub fn get_rate_tc_bws(
        &self,
    ) -> MultiAttrIterable<Self, OpRateNewDoRequest<'a>, IterableDlRateTcBws<'a>> {
        MultiAttrIterable::new(self.clone(), |variant| {
            if let OpRateNewDoRequest::RateTcBws(val) = variant {
                Some(val)
            } else {
                None
            }
        })
    }
}
impl OpRateNewDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRateNewDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRateNewDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRateNewDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRateNewDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRateNewDoRequest<'a> {
    type Item = Result<OpRateNewDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRateNewDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRateNewDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                166u16 => OpRateNewDoRequest::RateTxShare({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                167u16 => OpRateNewDoRequest::RateTxMax({
                    let res = parse_u64(next);
                    let Some(val) = res else { break };
                    val
                }),
                168u16 => OpRateNewDoRequest::RateNodeName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                169u16 => OpRateNewDoRequest::RateParentNodeName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                177u16 => OpRateNewDoRequest::RateTxPriority({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                178u16 => OpRateNewDoRequest::RateTxWeight({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                180u16 => OpRateNewDoRequest::RateTcBws({
                    let res = Some(IterableDlRateTcBws::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRateNewDoRequest",
            r#type.and_then(|t| OpRateNewDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRateNewDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRateNewDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRateNewDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpRateNewDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpRateNewDoRequest::RateTxShare(val) => fmt.field("RateTxShare", &val),
                OpRateNewDoRequest::RateTxMax(val) => fmt.field("RateTxMax", &val),
                OpRateNewDoRequest::RateNodeName(val) => fmt.field("RateNodeName", &val),
                OpRateNewDoRequest::RateParentNodeName(val) => {
                    fmt.field("RateParentNodeName", &val)
                }
                OpRateNewDoRequest::RateTxPriority(val) => fmt.field("RateTxPriority", &val),
                OpRateNewDoRequest::RateTxWeight(val) => fmt.field("RateTxWeight", &val),
                OpRateNewDoRequest::RateTcBws(val) => fmt.field("RateTcBws", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRateNewDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRateNewDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRateNewDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRateNewDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRateNewDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRateNewDoRequest::RateTxShare(val) => {
                    if last_off == offset {
                        stack.push(("RateTxShare", last_off));
                        break;
                    }
                }
                OpRateNewDoRequest::RateTxMax(val) => {
                    if last_off == offset {
                        stack.push(("RateTxMax", last_off));
                        break;
                    }
                }
                OpRateNewDoRequest::RateNodeName(val) => {
                    if last_off == offset {
                        stack.push(("RateNodeName", last_off));
                        break;
                    }
                }
                OpRateNewDoRequest::RateParentNodeName(val) => {
                    if last_off == offset {
                        stack.push(("RateParentNodeName", last_off));
                        break;
                    }
                }
                OpRateNewDoRequest::RateTxPriority(val) => {
                    if last_off == offset {
                        stack.push(("RateTxPriority", last_off));
                        break;
                    }
                }
                OpRateNewDoRequest::RateTxWeight(val) => {
                    if last_off == offset {
                        stack.push(("RateTxWeight", last_off));
                        break;
                    }
                }
                OpRateNewDoRequest::RateTcBws(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRateNewDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Create rate instances."]
pub struct PushOpRateNewDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRateNewDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRateNewDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(76u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpRateNewDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Create rate instances."]
#[derive(Clone)]
pub enum OpRateNewDoReply {}
impl<'a> IterableOpRateNewDoReply<'a> {}
impl OpRateNewDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRateNewDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRateNewDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRateNewDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRateNewDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRateNewDoReply<'a> {
    type Item = Result<OpRateNewDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRateNewDoReply",
            r#type.and_then(|t| OpRateNewDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpRateNewDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRateNewDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpRateNewDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRateNewDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRateNewDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpRateNewDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpRateNewDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpRateNewDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpRateNewDoRequest<&mut Vec<u8>> {
        PushOpRateNewDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpRateNewDoRequest<RequestBuf<'r>> {
        PushOpRateNewDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpRateNewDoRequest<'_> {
    type ReplyType<'buf> = IterableOpRateNewDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpRateNewDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpRateNewDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Delete rate instances."]
pub struct PushOpRateDelDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRateDelDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRateDelDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(77u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_rate_node_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            168u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_rate_node_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 168u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpRateDelDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete rate instances."]
#[derive(Clone)]
pub enum OpRateDelDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    RateNodeName(&'a CStr),
}
impl<'a> IterableOpRateDelDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateDelDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateDelDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateDelDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateDelDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_rate_node_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpRateDelDoRequest::RateNodeName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpRateDelDoRequest",
            "RateNodeName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpRateDelDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRateDelDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRateDelDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRateDelDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRateDelDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRateDelDoRequest<'a> {
    type Item = Result<OpRateDelDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpRateDelDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpRateDelDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                168u16 => OpRateDelDoRequest::RateNodeName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRateDelDoRequest",
            r#type.and_then(|t| OpRateDelDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpRateDelDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRateDelDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpRateDelDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpRateDelDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpRateDelDoRequest::RateNodeName(val) => fmt.field("RateNodeName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpRateDelDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRateDelDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRateDelDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpRateDelDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpRateDelDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpRateDelDoRequest::RateNodeName(val) => {
                    if last_off == offset {
                        stack.push(("RateNodeName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpRateDelDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Delete rate instances."]
pub struct PushOpRateDelDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpRateDelDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpRateDelDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(77u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpRateDelDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Delete rate instances."]
#[derive(Clone)]
pub enum OpRateDelDoReply {}
impl<'a> IterableOpRateDelDoReply<'a> {}
impl OpRateDelDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpRateDelDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpRateDelDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpRateDelDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpRateDelDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpRateDelDoReply<'a> {
    type Item = Result<OpRateDelDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpRateDelDoReply",
            r#type.and_then(|t| OpRateDelDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpRateDelDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpRateDelDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpRateDelDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpRateDelDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpRateDelDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpRateDelDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpRateDelDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpRateDelDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpRateDelDoRequest<&mut Vec<u8>> {
        PushOpRateDelDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpRateDelDoRequest<RequestBuf<'r>> {
        PushOpRateDelDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpRateDelDoRequest<'_> {
    type ReplyType<'buf> = IterableOpRateDelDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpRateDelDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpRateDelDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get line card instances."]
pub struct PushOpLinecardGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpLinecardGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpLinecardGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(78u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpLinecardGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get line card instances."]
#[derive(Clone)]
pub enum OpLinecardGetDumpRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpLinecardGetDumpRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardGetDumpRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardGetDumpRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardGetDumpRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardGetDumpRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpLinecardGetDumpRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpLinecardGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpLinecardGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpLinecardGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpLinecardGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpLinecardGetDumpRequest<'a> {
    type Item = Result<OpLinecardGetDumpRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpLinecardGetDumpRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpLinecardGetDumpRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpLinecardGetDumpRequest",
            r#type.and_then(|t| OpLinecardGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpLinecardGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpLinecardGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpLinecardGetDumpRequest::BusName(val) => fmt.field("BusName", &val),
                OpLinecardGetDumpRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpLinecardGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpLinecardGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpLinecardGetDumpRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpLinecardGetDumpRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpLinecardGetDumpRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpLinecardGetDumpRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get line card instances."]
pub struct PushOpLinecardGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpLinecardGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpLinecardGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(80u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_linecard_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 171u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpLinecardGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get line card instances."]
#[derive(Clone)]
pub enum OpLinecardGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    LinecardIndex(u32),
}
impl<'a> IterableOpLinecardGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_linecard_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardGetDumpReply::LinecardIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardGetDumpReply",
            "LinecardIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpLinecardGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpLinecardGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpLinecardGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpLinecardGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpLinecardGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpLinecardGetDumpReply<'a> {
    type Item = Result<OpLinecardGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpLinecardGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpLinecardGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                171u16 => OpLinecardGetDumpReply::LinecardIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpLinecardGetDumpReply",
            r#type.and_then(|t| OpLinecardGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpLinecardGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpLinecardGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpLinecardGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpLinecardGetDumpReply::DevName(val) => fmt.field("DevName", &val),
                OpLinecardGetDumpReply::LinecardIndex(val) => fmt.field("LinecardIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpLinecardGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpLinecardGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpLinecardGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpLinecardGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpLinecardGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpLinecardGetDumpReply::LinecardIndex(val) => {
                    if last_off == offset {
                        stack.push(("LinecardIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpLinecardGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpLinecardGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpLinecardGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpLinecardGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpLinecardGetDumpRequest<&mut Vec<u8>> {
        PushOpLinecardGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpLinecardGetDumpRequest<RequestBuf<'r>> {
        PushOpLinecardGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpLinecardGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpLinecardGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpLinecardGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpLinecardGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get line card instances."]
pub struct PushOpLinecardGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpLinecardGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpLinecardGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(78u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_linecard_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 171u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpLinecardGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get line card instances."]
#[derive(Clone)]
pub enum OpLinecardGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    LinecardIndex(u32),
}
impl<'a> IterableOpLinecardGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_linecard_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardGetDoRequest::LinecardIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardGetDoRequest",
            "LinecardIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpLinecardGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpLinecardGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpLinecardGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpLinecardGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpLinecardGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpLinecardGetDoRequest<'a> {
    type Item = Result<OpLinecardGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpLinecardGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpLinecardGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                171u16 => OpLinecardGetDoRequest::LinecardIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpLinecardGetDoRequest",
            r#type.and_then(|t| OpLinecardGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpLinecardGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpLinecardGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpLinecardGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpLinecardGetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpLinecardGetDoRequest::LinecardIndex(val) => fmt.field("LinecardIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpLinecardGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpLinecardGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpLinecardGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpLinecardGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpLinecardGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpLinecardGetDoRequest::LinecardIndex(val) => {
                    if last_off == offset {
                        stack.push(("LinecardIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpLinecardGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get line card instances."]
pub struct PushOpLinecardGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpLinecardGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpLinecardGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(80u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_linecard_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 171u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpLinecardGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get line card instances."]
#[derive(Clone)]
pub enum OpLinecardGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    LinecardIndex(u32),
}
impl<'a> IterableOpLinecardGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_linecard_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardGetDoReply::LinecardIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardGetDoReply",
            "LinecardIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpLinecardGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpLinecardGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpLinecardGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpLinecardGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpLinecardGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpLinecardGetDoReply<'a> {
    type Item = Result<OpLinecardGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpLinecardGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpLinecardGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                171u16 => OpLinecardGetDoReply::LinecardIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpLinecardGetDoReply",
            r#type.and_then(|t| OpLinecardGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpLinecardGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpLinecardGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpLinecardGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpLinecardGetDoReply::DevName(val) => fmt.field("DevName", &val),
                OpLinecardGetDoReply::LinecardIndex(val) => fmt.field("LinecardIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpLinecardGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpLinecardGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpLinecardGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpLinecardGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpLinecardGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpLinecardGetDoReply::LinecardIndex(val) => {
                    if last_off == offset {
                        stack.push(("LinecardIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpLinecardGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpLinecardGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpLinecardGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpLinecardGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpLinecardGetDoRequest<&mut Vec<u8>> {
        PushOpLinecardGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpLinecardGetDoRequest<RequestBuf<'r>> {
        PushOpLinecardGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpLinecardGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpLinecardGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpLinecardGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpLinecardGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set line card instances."]
pub struct PushOpLinecardSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpLinecardSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpLinecardSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(79u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_linecard_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 171u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
    pub fn push_linecard_type(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            173u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_linecard_type_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 173u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpLinecardSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set line card instances."]
#[derive(Clone)]
pub enum OpLinecardSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    LinecardIndex(u32),
    LinecardType(&'a CStr),
}
impl<'a> IterableOpLinecardSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_linecard_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardSetDoRequest::LinecardIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardSetDoRequest",
            "LinecardIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_linecard_type(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpLinecardSetDoRequest::LinecardType(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpLinecardSetDoRequest",
            "LinecardType",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpLinecardSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpLinecardSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpLinecardSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpLinecardSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpLinecardSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpLinecardSetDoRequest<'a> {
    type Item = Result<OpLinecardSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpLinecardSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpLinecardSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                171u16 => OpLinecardSetDoRequest::LinecardIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                173u16 => OpLinecardSetDoRequest::LinecardType({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpLinecardSetDoRequest",
            r#type.and_then(|t| OpLinecardSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpLinecardSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpLinecardSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpLinecardSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpLinecardSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpLinecardSetDoRequest::LinecardIndex(val) => fmt.field("LinecardIndex", &val),
                OpLinecardSetDoRequest::LinecardType(val) => fmt.field("LinecardType", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpLinecardSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpLinecardSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpLinecardSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpLinecardSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpLinecardSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpLinecardSetDoRequest::LinecardIndex(val) => {
                    if last_off == offset {
                        stack.push(("LinecardIndex", last_off));
                        break;
                    }
                }
                OpLinecardSetDoRequest::LinecardType(val) => {
                    if last_off == offset {
                        stack.push(("LinecardType", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpLinecardSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set line card instances."]
pub struct PushOpLinecardSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpLinecardSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpLinecardSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(79u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpLinecardSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set line card instances."]
#[derive(Clone)]
pub enum OpLinecardSetDoReply {}
impl<'a> IterableOpLinecardSetDoReply<'a> {}
impl OpLinecardSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpLinecardSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpLinecardSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpLinecardSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpLinecardSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpLinecardSetDoReply<'a> {
    type Item = Result<OpLinecardSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpLinecardSetDoReply",
            r#type.and_then(|t| OpLinecardSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpLinecardSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpLinecardSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpLinecardSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpLinecardSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpLinecardSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpLinecardSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpLinecardSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpLinecardSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpLinecardSetDoRequest<&mut Vec<u8>> {
        PushOpLinecardSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpLinecardSetDoRequest<RequestBuf<'r>> {
        PushOpLinecardSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpLinecardSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpLinecardSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpLinecardSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpLinecardSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get device selftest instances."]
pub struct PushOpSelftestsGetDumpRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSelftestsGetDumpRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSelftestsGetDumpRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(82u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpSelftestsGetDumpRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get device selftest instances."]
#[derive(Clone)]
pub enum OpSelftestsGetDumpRequest {}
impl<'a> IterableOpSelftestsGetDumpRequest<'a> {}
impl OpSelftestsGetDumpRequest {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSelftestsGetDumpRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSelftestsGetDumpRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSelftestsGetDumpRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSelftestsGetDumpRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSelftestsGetDumpRequest<'a> {
    type Item = Result<OpSelftestsGetDumpRequest, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSelftestsGetDumpRequest",
            r#type.and_then(|t| OpSelftestsGetDumpRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpSelftestsGetDumpRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSelftestsGetDumpRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpSelftestsGetDumpRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSelftestsGetDumpRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSelftestsGetDumpRequest::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[doc = "Get device selftest instances."]
pub struct PushOpSelftestsGetDumpReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSelftestsGetDumpReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSelftestsGetDumpReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(82u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpSelftestsGetDumpReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get device selftest instances."]
#[derive(Clone)]
pub enum OpSelftestsGetDumpReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpSelftestsGetDumpReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSelftestsGetDumpReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSelftestsGetDumpReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSelftestsGetDumpReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSelftestsGetDumpReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSelftestsGetDumpReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSelftestsGetDumpReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSelftestsGetDumpReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSelftestsGetDumpReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSelftestsGetDumpReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSelftestsGetDumpReply<'a> {
    type Item = Result<OpSelftestsGetDumpReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSelftestsGetDumpReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSelftestsGetDumpReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSelftestsGetDumpReply",
            r#type.and_then(|t| OpSelftestsGetDumpReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSelftestsGetDumpReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSelftestsGetDumpReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSelftestsGetDumpReply::BusName(val) => fmt.field("BusName", &val),
                OpSelftestsGetDumpReply::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSelftestsGetDumpReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSelftestsGetDumpReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSelftestsGetDumpReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSelftestsGetDumpReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSelftestsGetDumpReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSelftestsGetDumpReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSelftestsGetDumpRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSelftestsGetDumpRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSelftestsGetDumpRequest::write_header(&mut request.buf_mut());
        Self {
            request: request.set_dump(),
        }
    }
    pub fn encode(&mut self) -> PushOpSelftestsGetDumpRequest<&mut Vec<u8>> {
        PushOpSelftestsGetDumpRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSelftestsGetDumpRequest<RequestBuf<'r>> {
        PushOpSelftestsGetDumpRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSelftestsGetDumpRequest<'_> {
    type ReplyType<'buf> = IterableOpSelftestsGetDumpReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSelftestsGetDumpReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSelftestsGetDumpRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Get device selftest instances."]
pub struct PushOpSelftestsGetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSelftestsGetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSelftestsGetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(82u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpSelftestsGetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get device selftest instances."]
#[derive(Clone)]
pub enum OpSelftestsGetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpSelftestsGetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSelftestsGetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSelftestsGetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSelftestsGetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSelftestsGetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSelftestsGetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSelftestsGetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSelftestsGetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSelftestsGetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSelftestsGetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSelftestsGetDoRequest<'a> {
    type Item = Result<OpSelftestsGetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSelftestsGetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSelftestsGetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSelftestsGetDoRequest",
            r#type.and_then(|t| OpSelftestsGetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSelftestsGetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSelftestsGetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSelftestsGetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpSelftestsGetDoRequest::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSelftestsGetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSelftestsGetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSelftestsGetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSelftestsGetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSelftestsGetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSelftestsGetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Get device selftest instances."]
pub struct PushOpSelftestsGetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSelftestsGetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSelftestsGetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(82u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
}
impl<Prev: Rec> Drop for PushOpSelftestsGetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Get device selftest instances."]
#[derive(Clone)]
pub enum OpSelftestsGetDoReply<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
}
impl<'a> IterableOpSelftestsGetDoReply<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSelftestsGetDoReply::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSelftestsGetDoReply",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSelftestsGetDoReply::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSelftestsGetDoReply",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSelftestsGetDoReply<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSelftestsGetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSelftestsGetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSelftestsGetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSelftestsGetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSelftestsGetDoReply<'a> {
    type Item = Result<OpSelftestsGetDoReply<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSelftestsGetDoReply::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSelftestsGetDoReply::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSelftestsGetDoReply",
            r#type.and_then(|t| OpSelftestsGetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSelftestsGetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSelftestsGetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSelftestsGetDoReply::BusName(val) => fmt.field("BusName", &val),
                OpSelftestsGetDoReply::DevName(val) => fmt.field("DevName", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSelftestsGetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSelftestsGetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSelftestsGetDoReply::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSelftestsGetDoReply::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSelftestsGetDoReply::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSelftestsGetDoReply", cur));
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSelftestsGetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSelftestsGetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSelftestsGetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpSelftestsGetDoRequest<&mut Vec<u8>> {
        PushOpSelftestsGetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSelftestsGetDoRequest<RequestBuf<'r>> {
        PushOpSelftestsGetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSelftestsGetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpSelftestsGetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSelftestsGetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSelftestsGetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Run device selftest instances."]
pub struct PushOpSelftestsRunDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSelftestsRunDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSelftestsRunDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(83u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn nested_selftests(mut self) -> PushDlSelftestId<Self> {
        let header_offset = push_nested_header(self.as_rec_mut(), 176u16);
        PushDlSelftestId {
            prev: Some(self),
            header_offset: Some(header_offset),
        }
    }
}
impl<Prev: Rec> Drop for PushOpSelftestsRunDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Run device selftest instances."]
#[derive(Clone)]
pub enum OpSelftestsRunDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    Selftests(IterableDlSelftestId<'a>),
}
impl<'a> IterableOpSelftestsRunDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSelftestsRunDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSelftestsRunDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSelftestsRunDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSelftestsRunDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_selftests(&self) -> Result<IterableDlSelftestId<'a>, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpSelftestsRunDoRequest::Selftests(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpSelftestsRunDoRequest",
            "Selftests",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpSelftestsRunDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSelftestsRunDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSelftestsRunDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSelftestsRunDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSelftestsRunDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSelftestsRunDoRequest<'a> {
    type Item = Result<OpSelftestsRunDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpSelftestsRunDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpSelftestsRunDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                176u16 => OpSelftestsRunDoRequest::Selftests({
                    let res = Some(IterableDlSelftestId::with_loc(next, self.orig_loc));
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSelftestsRunDoRequest",
            r#type.and_then(|t| OpSelftestsRunDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpSelftestsRunDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSelftestsRunDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpSelftestsRunDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpSelftestsRunDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpSelftestsRunDoRequest::Selftests(val) => fmt.field("Selftests", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpSelftestsRunDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSelftestsRunDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSelftestsRunDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        let mut missing = None;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpSelftestsRunDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpSelftestsRunDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpSelftestsRunDoRequest::Selftests(val) => {
                    (stack, missing) = val.lookup_attr(offset, missing_type);
                    if !stack.is_empty() {
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpSelftestsRunDoRequest", cur));
        }
        (stack, missing)
    }
}
#[doc = "Run device selftest instances."]
pub struct PushOpSelftestsRunDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpSelftestsRunDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpSelftestsRunDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(83u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpSelftestsRunDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Run device selftest instances."]
#[derive(Clone)]
pub enum OpSelftestsRunDoReply {}
impl<'a> IterableOpSelftestsRunDoReply<'a> {}
impl OpSelftestsRunDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpSelftestsRunDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpSelftestsRunDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpSelftestsRunDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpSelftestsRunDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpSelftestsRunDoReply<'a> {
    type Item = Result<OpSelftestsRunDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpSelftestsRunDoReply",
            r#type.and_then(|t| OpSelftestsRunDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpSelftestsRunDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpSelftestsRunDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpSelftestsRunDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpSelftestsRunDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpSelftestsRunDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpSelftestsRunDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpSelftestsRunDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpSelftestsRunDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpSelftestsRunDoRequest<&mut Vec<u8>> {
        PushOpSelftestsRunDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpSelftestsRunDoRequest<RequestBuf<'r>> {
        PushOpSelftestsRunDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpSelftestsRunDoRequest<'_> {
    type ReplyType<'buf> = IterableOpSelftestsRunDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpSelftestsRunDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpSelftestsRunDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
#[doc = "Set notification messages socket filter."]
pub struct PushOpNotifyFilterSetDoRequest<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNotifyFilterSetDoRequest<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNotifyFilterSetDoRequest<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(84u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
    pub fn push_bus_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            1u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_bus_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 1u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_dev_name(mut self, value: &CStr) -> Self {
        push_header(
            self.as_rec_mut(),
            2u16,
            value.to_bytes_with_nul().len() as u16,
        );
        self.as_rec_mut().extend(value.to_bytes_with_nul());
        self
    }
    pub fn push_dev_name_bytes(mut self, value: &[u8]) -> Self {
        push_header(self.as_rec_mut(), 2u16, (value.len() + 1) as u16);
        self.as_rec_mut().extend(value);
        self.as_rec_mut().push(0);
        self
    }
    pub fn push_port_index(mut self, value: u32) -> Self {
        push_header(self.as_rec_mut(), 3u16, 4 as u16);
        self.as_rec_mut().extend(value.to_ne_bytes());
        self
    }
}
impl<Prev: Rec> Drop for PushOpNotifyFilterSetDoRequest<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set notification messages socket filter."]
#[derive(Clone)]
pub enum OpNotifyFilterSetDoRequest<'a> {
    BusName(&'a CStr),
    DevName(&'a CStr),
    PortIndex(u32),
}
impl<'a> IterableOpNotifyFilterSetDoRequest<'a> {
    pub fn get_bus_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNotifyFilterSetDoRequest::BusName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNotifyFilterSetDoRequest",
            "BusName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_dev_name(&self) -> Result<&'a CStr, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNotifyFilterSetDoRequest::DevName(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNotifyFilterSetDoRequest",
            "DevName",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
    pub fn get_port_index(&self) -> Result<u32, ErrorContext> {
        let mut iter = self.clone();
        iter.pos = 0;
        for attr in iter {
            if let OpNotifyFilterSetDoRequest::PortIndex(val) = attr? {
                return Ok(val);
            }
        }
        Err(ErrorContext::new_missing(
            "OpNotifyFilterSetDoRequest",
            "PortIndex",
            self.orig_loc,
            self.buf.as_ptr() as usize,
        ))
    }
}
impl OpNotifyFilterSetDoRequest<'_> {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpNotifyFilterSetDoRequest<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpNotifyFilterSetDoRequest::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNotifyFilterSetDoRequest<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNotifyFilterSetDoRequest<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNotifyFilterSetDoRequest<'a> {
    type Item = Result<OpNotifyFilterSetDoRequest<'a>, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                1u16 => OpNotifyFilterSetDoRequest::BusName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                2u16 => OpNotifyFilterSetDoRequest::DevName({
                    let res = CStr::from_bytes_with_nul(next).ok();
                    let Some(val) = res else { break };
                    val
                }),
                3u16 => OpNotifyFilterSetDoRequest::PortIndex({
                    let res = parse_u32(next);
                    let Some(val) = res else { break };
                    val
                }),
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNotifyFilterSetDoRequest",
            r#type.and_then(|t| OpNotifyFilterSetDoRequest::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl<'a> std::fmt::Debug for IterableOpNotifyFilterSetDoRequest<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNotifyFilterSetDoRequest");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {
                OpNotifyFilterSetDoRequest::BusName(val) => fmt.field("BusName", &val),
                OpNotifyFilterSetDoRequest::DevName(val) => fmt.field("DevName", &val),
                OpNotifyFilterSetDoRequest::PortIndex(val) => fmt.field("PortIndex", &val),
            };
        }
        fmt.finish()
    }
}
impl IterableOpNotifyFilterSetDoRequest<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpNotifyFilterSetDoRequest", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNotifyFilterSetDoRequest::attr_from_type(t)),
            );
        }
        if cur > offset || cur + self.buf.len() < offset {
            return (stack, None);
        }
        let mut attrs = self.clone();
        let mut last_off = cur + attrs.pos;
        while let Some(attr) = attrs.next() {
            let Ok(attr) = attr else { break };
            match attr {
                OpNotifyFilterSetDoRequest::BusName(val) => {
                    if last_off == offset {
                        stack.push(("BusName", last_off));
                        break;
                    }
                }
                OpNotifyFilterSetDoRequest::DevName(val) => {
                    if last_off == offset {
                        stack.push(("DevName", last_off));
                        break;
                    }
                }
                OpNotifyFilterSetDoRequest::PortIndex(val) => {
                    if last_off == offset {
                        stack.push(("PortIndex", last_off));
                        break;
                    }
                }
                _ => {}
            };
            last_off = cur + attrs.pos;
        }
        if !stack.is_empty() {
            stack.push(("OpNotifyFilterSetDoRequest", cur));
        }
        (stack, None)
    }
}
#[doc = "Set notification messages socket filter."]
pub struct PushOpNotifyFilterSetDoReply<Prev: Rec> {
    pub(crate) prev: Option<Prev>,
    pub(crate) header_offset: Option<usize>,
}
impl<Prev: Rec> Rec for PushOpNotifyFilterSetDoReply<Prev> {
    fn as_rec_mut(&mut self) -> &mut Vec<u8> {
        self.prev.as_mut().unwrap().as_rec_mut()
    }
}
impl<Prev: Rec> PushOpNotifyFilterSetDoReply<Prev> {
    pub fn new(mut prev: Prev) -> Self {
        Self::write_header(&mut prev);
        Self::new_without_header(prev)
    }
    fn new_without_header(prev: Prev) -> Self {
        Self {
            prev: Some(prev),
            header_offset: None,
        }
    }
    fn write_header(prev: &mut Prev) {
        let mut header = PushBuiltinNfgenmsg::new();
        header.set_cmd(84u8);
        header.set_version(1u8);
        prev.as_rec_mut().extend(header.as_slice());
    }
    pub fn end_nested(mut self) -> Prev {
        let mut prev = self.prev.take().unwrap();
        if let Some(header_offset) = &self.header_offset {
            finalize_nested_header(prev.as_rec_mut(), *header_offset);
        }
        prev
    }
}
impl<Prev: Rec> Drop for PushOpNotifyFilterSetDoReply<Prev> {
    fn drop(&mut self) {
        if let Some(prev) = &mut self.prev {
            if let Some(header_offset) = &self.header_offset {
                finalize_nested_header(prev.as_rec_mut(), *header_offset);
            }
        }
    }
}
#[doc = "Set notification messages socket filter."]
#[derive(Clone)]
pub enum OpNotifyFilterSetDoReply {}
impl<'a> IterableOpNotifyFilterSetDoReply<'a> {}
impl OpNotifyFilterSetDoReply {
    pub fn new<'a>(buf: &'a [u8]) -> IterableOpNotifyFilterSetDoReply<'a> {
        let (_header, attrs) = buf.split_at(buf.len().min(PushBuiltinNfgenmsg::len()));
        IterableOpNotifyFilterSetDoReply::with_loc(attrs, buf.as_ptr() as usize)
    }
    fn attr_from_type(r#type: u16) -> Option<&'static str> {
        Devlink::attr_from_type(r#type)
    }
}
#[derive(Clone, Copy, Default)]
pub struct IterableOpNotifyFilterSetDoReply<'a> {
    buf: &'a [u8],
    pos: usize,
    orig_loc: usize,
}
impl<'a> IterableOpNotifyFilterSetDoReply<'a> {
    fn with_loc(buf: &'a [u8], orig_loc: usize) -> Self {
        Self {
            buf,
            pos: 0,
            orig_loc,
        }
    }
    pub fn get_buf(&self) -> &'a [u8] {
        self.buf
    }
}
impl<'a> Iterator for IterableOpNotifyFilterSetDoReply<'a> {
    type Item = Result<OpNotifyFilterSetDoReply, ErrorContext>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.buf.len() == self.pos {
            return None;
        }
        let pos = self.pos;
        let mut r#type = None;
        while let Some((header, next)) = chop_header(self.buf, &mut self.pos) {
            r#type = Some(header.r#type);
            let res = match header.r#type {
                n => {
                    if cfg!(any(test, feature = "deny-unknown-attrs")) {
                        break;
                    } else {
                        continue;
                    }
                }
            };
            return Some(Ok(res));
        }
        Some(Err(ErrorContext::new(
            "OpNotifyFilterSetDoReply",
            r#type.and_then(|t| OpNotifyFilterSetDoReply::attr_from_type(t)),
            self.orig_loc,
            self.buf.as_ptr().wrapping_add(pos) as usize,
        )))
    }
}
impl std::fmt::Debug for IterableOpNotifyFilterSetDoReply<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut fmt = f.debug_struct("OpNotifyFilterSetDoReply");
        for attr in self.clone() {
            let attr = match attr {
                Ok(a) => a,
                Err(err) => {
                    fmt.finish()?;
                    f.write_str("Err(")?;
                    err.fmt(f)?;
                    return f.write_str(")");
                }
            };
            match attr {};
        }
        fmt.finish()
    }
}
impl IterableOpNotifyFilterSetDoReply<'_> {
    pub fn lookup_attr(
        &self,
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        let mut stack = Vec::new();
        let cur = ErrorContext::calc_offset(self.orig_loc, self.buf.as_ptr() as usize);
        if cur == offset + PushBuiltinNfgenmsg::len() {
            stack.push(("OpNotifyFilterSetDoReply", offset));
            return (
                stack,
                missing_type.and_then(|t| OpNotifyFilterSetDoReply::attr_from_type(t)),
            );
        }
        (stack, None)
    }
}
#[derive(Debug)]
pub struct RequestOpNotifyFilterSetDoRequest<'r> {
    request: Request<'r>,
}
impl<'r> RequestOpNotifyFilterSetDoRequest<'r> {
    pub fn new(mut request: Request<'r>) -> Self {
        PushOpNotifyFilterSetDoRequest::write_header(&mut request.buf_mut());
        Self { request: request }
    }
    pub fn encode(&mut self) -> PushOpNotifyFilterSetDoRequest<&mut Vec<u8>> {
        PushOpNotifyFilterSetDoRequest::new_without_header(self.request.buf_mut())
    }
    pub fn into_encoder(self) -> PushOpNotifyFilterSetDoRequest<RequestBuf<'r>> {
        PushOpNotifyFilterSetDoRequest::new_without_header(self.request.buf)
    }
}
impl NetlinkRequest for RequestOpNotifyFilterSetDoRequest<'_> {
    type ReplyType<'buf> = IterableOpNotifyFilterSetDoReply<'buf>;
    fn protocol(&self) -> Protocol {
        Protocol::Generic("devlink".as_bytes())
    }
    fn flags(&self) -> u16 {
        self.request.flags
    }
    fn payload(&self) -> &[u8] {
        self.request.buf()
    }
    fn decode_reply<'buf>(buf: &'buf [u8]) -> Self::ReplyType<'buf> {
        OpNotifyFilterSetDoReply::new(buf)
    }
    fn lookup(
        buf: &[u8],
        offset: usize,
        missing_type: Option<u16>,
    ) -> (Vec<(&'static str, usize)>, Option<&'static str>) {
        OpNotifyFilterSetDoRequest::new(buf).lookup_attr(offset, missing_type)
    }
}
use crate::traits::LookupFn;
use crate::utils::RequestBuf;
#[derive(Debug)]
pub struct Request<'buf> {
    buf: RequestBuf<'buf>,
    flags: u16,
    writeback: Option<&'buf mut Option<RequestInfo>>,
}
#[allow(unused)]
#[derive(Debug, Clone)]
pub struct RequestInfo {
    protocol: Protocol,
    flags: u16,
    name: &'static str,
    lookup: LookupFn,
}
impl Request<'static> {
    pub fn new() -> Self {
        Self::new_from_buf(Vec::new())
    }
    pub fn new_from_buf(buf: Vec<u8>) -> Self {
        Self {
            flags: 0,
            buf: RequestBuf::Own(buf),
            writeback: None,
        }
    }
    pub fn into_buf(self) -> Vec<u8> {
        match self.buf {
            RequestBuf::Own(buf) => buf,
            _ => unreachable!(),
        }
    }
}
impl<'buf> Request<'buf> {
    pub fn new_with_buf(buf: &'buf mut Vec<u8>) -> Self {
        buf.clear();
        Self::new_extend(buf)
    }
    pub fn new_extend(buf: &'buf mut Vec<u8>) -> Self {
        Self {
            flags: 0,
            buf: RequestBuf::Ref(buf),
            writeback: None,
        }
    }
    fn do_writeback(&mut self, protocol: Protocol, name: &'static str, lookup: LookupFn) {
        let Some(writeback) = &mut self.writeback else {
            return;
        };
        **writeback = Some(RequestInfo {
            protocol,
            flags: self.flags,
            name,
            lookup,
        })
    }
    pub fn buf(&self) -> &Vec<u8> {
        self.buf.buf()
    }
    pub fn buf_mut(&mut self) -> &mut Vec<u8> {
        self.buf.buf_mut()
    }
    #[doc = "Set `NLM_F_CREATE` flag"]
    pub fn set_create(mut self) -> Self {
        self.flags |= consts::NLM_F_CREATE as u16;
        self
    }
    #[doc = "Set `NLM_F_EXCL` flag"]
    pub fn set_excl(mut self) -> Self {
        self.flags |= consts::NLM_F_EXCL as u16;
        self
    }
    #[doc = "Set `NLM_F_REPLACE` flag"]
    pub fn set_replace(mut self) -> Self {
        self.flags |= consts::NLM_F_REPLACE as u16;
        self
    }
    #[doc = "Set `NLM_F_CREATE` and `NLM_F_REPLACE` flag"]
    pub fn set_change(self) -> Self {
        self.set_create().set_replace()
    }
    #[doc = "Set `NLM_F_APPEND` flag"]
    pub fn set_append(mut self) -> Self {
        self.flags |= consts::NLM_F_APPEND as u16;
        self
    }
    #[doc = "Set `NLM_F_DUMP` flag"]
    fn set_dump(mut self) -> Self {
        self.flags |= consts::NLM_F_DUMP as u16;
        self
    }
    pub fn op_get_dump_request(self) -> RequestOpGetDumpRequest<'buf> {
        let mut res = RequestOpGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-get-dump-request",
            RequestOpGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_get_do_request(self) -> RequestOpGetDoRequest<'buf> {
        let mut res = RequestOpGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-get-do-request",
            RequestOpGetDoRequest::lookup,
        );
        res
    }
    pub fn op_port_get_dump_request(self) -> RequestOpPortGetDumpRequest<'buf> {
        let mut res = RequestOpPortGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-port-get-dump-request",
            RequestOpPortGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_port_get_do_request(self) -> RequestOpPortGetDoRequest<'buf> {
        let mut res = RequestOpPortGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-port-get-do-request",
            RequestOpPortGetDoRequest::lookup,
        );
        res
    }
    pub fn op_port_set_do_request(self) -> RequestOpPortSetDoRequest<'buf> {
        let mut res = RequestOpPortSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-port-set-do-request",
            RequestOpPortSetDoRequest::lookup,
        );
        res
    }
    pub fn op_port_new_do_request(self) -> RequestOpPortNewDoRequest<'buf> {
        let mut res = RequestOpPortNewDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-port-new-do-request",
            RequestOpPortNewDoRequest::lookup,
        );
        res
    }
    pub fn op_port_del_do_request(self) -> RequestOpPortDelDoRequest<'buf> {
        let mut res = RequestOpPortDelDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-port-del-do-request",
            RequestOpPortDelDoRequest::lookup,
        );
        res
    }
    pub fn op_port_split_do_request(self) -> RequestOpPortSplitDoRequest<'buf> {
        let mut res = RequestOpPortSplitDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-port-split-do-request",
            RequestOpPortSplitDoRequest::lookup,
        );
        res
    }
    pub fn op_port_unsplit_do_request(self) -> RequestOpPortUnsplitDoRequest<'buf> {
        let mut res = RequestOpPortUnsplitDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-port-unsplit-do-request",
            RequestOpPortUnsplitDoRequest::lookup,
        );
        res
    }
    pub fn op_sb_get_dump_request(self) -> RequestOpSbGetDumpRequest<'buf> {
        let mut res = RequestOpSbGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-get-dump-request",
            RequestOpSbGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_sb_get_do_request(self) -> RequestOpSbGetDoRequest<'buf> {
        let mut res = RequestOpSbGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-get-do-request",
            RequestOpSbGetDoRequest::lookup,
        );
        res
    }
    pub fn op_sb_pool_get_dump_request(self) -> RequestOpSbPoolGetDumpRequest<'buf> {
        let mut res = RequestOpSbPoolGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-pool-get-dump-request",
            RequestOpSbPoolGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_sb_pool_get_do_request(self) -> RequestOpSbPoolGetDoRequest<'buf> {
        let mut res = RequestOpSbPoolGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-pool-get-do-request",
            RequestOpSbPoolGetDoRequest::lookup,
        );
        res
    }
    pub fn op_sb_pool_set_do_request(self) -> RequestOpSbPoolSetDoRequest<'buf> {
        let mut res = RequestOpSbPoolSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-pool-set-do-request",
            RequestOpSbPoolSetDoRequest::lookup,
        );
        res
    }
    pub fn op_sb_port_pool_get_dump_request(self) -> RequestOpSbPortPoolGetDumpRequest<'buf> {
        let mut res = RequestOpSbPortPoolGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-port-pool-get-dump-request",
            RequestOpSbPortPoolGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_sb_port_pool_get_do_request(self) -> RequestOpSbPortPoolGetDoRequest<'buf> {
        let mut res = RequestOpSbPortPoolGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-port-pool-get-do-request",
            RequestOpSbPortPoolGetDoRequest::lookup,
        );
        res
    }
    pub fn op_sb_port_pool_set_do_request(self) -> RequestOpSbPortPoolSetDoRequest<'buf> {
        let mut res = RequestOpSbPortPoolSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-port-pool-set-do-request",
            RequestOpSbPortPoolSetDoRequest::lookup,
        );
        res
    }
    pub fn op_sb_tc_pool_bind_get_dump_request(self) -> RequestOpSbTcPoolBindGetDumpRequest<'buf> {
        let mut res = RequestOpSbTcPoolBindGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-tc-pool-bind-get-dump-request",
            RequestOpSbTcPoolBindGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_sb_tc_pool_bind_get_do_request(self) -> RequestOpSbTcPoolBindGetDoRequest<'buf> {
        let mut res = RequestOpSbTcPoolBindGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-tc-pool-bind-get-do-request",
            RequestOpSbTcPoolBindGetDoRequest::lookup,
        );
        res
    }
    pub fn op_sb_tc_pool_bind_set_do_request(self) -> RequestOpSbTcPoolBindSetDoRequest<'buf> {
        let mut res = RequestOpSbTcPoolBindSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-tc-pool-bind-set-do-request",
            RequestOpSbTcPoolBindSetDoRequest::lookup,
        );
        res
    }
    pub fn op_sb_occ_snapshot_do_request(self) -> RequestOpSbOccSnapshotDoRequest<'buf> {
        let mut res = RequestOpSbOccSnapshotDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-occ-snapshot-do-request",
            RequestOpSbOccSnapshotDoRequest::lookup,
        );
        res
    }
    pub fn op_sb_occ_max_clear_do_request(self) -> RequestOpSbOccMaxClearDoRequest<'buf> {
        let mut res = RequestOpSbOccMaxClearDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-sb-occ-max-clear-do-request",
            RequestOpSbOccMaxClearDoRequest::lookup,
        );
        res
    }
    pub fn op_eswitch_get_do_request(self) -> RequestOpEswitchGetDoRequest<'buf> {
        let mut res = RequestOpEswitchGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-eswitch-get-do-request",
            RequestOpEswitchGetDoRequest::lookup,
        );
        res
    }
    pub fn op_eswitch_set_do_request(self) -> RequestOpEswitchSetDoRequest<'buf> {
        let mut res = RequestOpEswitchSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-eswitch-set-do-request",
            RequestOpEswitchSetDoRequest::lookup,
        );
        res
    }
    pub fn op_dpipe_table_get_do_request(self) -> RequestOpDpipeTableGetDoRequest<'buf> {
        let mut res = RequestOpDpipeTableGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-dpipe-table-get-do-request",
            RequestOpDpipeTableGetDoRequest::lookup,
        );
        res
    }
    pub fn op_dpipe_entries_get_do_request(self) -> RequestOpDpipeEntriesGetDoRequest<'buf> {
        let mut res = RequestOpDpipeEntriesGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-dpipe-entries-get-do-request",
            RequestOpDpipeEntriesGetDoRequest::lookup,
        );
        res
    }
    pub fn op_dpipe_headers_get_do_request(self) -> RequestOpDpipeHeadersGetDoRequest<'buf> {
        let mut res = RequestOpDpipeHeadersGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-dpipe-headers-get-do-request",
            RequestOpDpipeHeadersGetDoRequest::lookup,
        );
        res
    }
    pub fn op_dpipe_table_counters_set_do_request(
        self,
    ) -> RequestOpDpipeTableCountersSetDoRequest<'buf> {
        let mut res = RequestOpDpipeTableCountersSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-dpipe-table-counters-set-do-request",
            RequestOpDpipeTableCountersSetDoRequest::lookup,
        );
        res
    }
    pub fn op_resource_set_do_request(self) -> RequestOpResourceSetDoRequest<'buf> {
        let mut res = RequestOpResourceSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-resource-set-do-request",
            RequestOpResourceSetDoRequest::lookup,
        );
        res
    }
    pub fn op_resource_dump_do_request(self) -> RequestOpResourceDumpDoRequest<'buf> {
        let mut res = RequestOpResourceDumpDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-resource-dump-do-request",
            RequestOpResourceDumpDoRequest::lookup,
        );
        res
    }
    pub fn op_reload_do_request(self) -> RequestOpReloadDoRequest<'buf> {
        let mut res = RequestOpReloadDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-reload-do-request",
            RequestOpReloadDoRequest::lookup,
        );
        res
    }
    pub fn op_param_get_dump_request(self) -> RequestOpParamGetDumpRequest<'buf> {
        let mut res = RequestOpParamGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-param-get-dump-request",
            RequestOpParamGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_param_get_do_request(self) -> RequestOpParamGetDoRequest<'buf> {
        let mut res = RequestOpParamGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-param-get-do-request",
            RequestOpParamGetDoRequest::lookup,
        );
        res
    }
    pub fn op_param_set_do_request(self) -> RequestOpParamSetDoRequest<'buf> {
        let mut res = RequestOpParamSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-param-set-do-request",
            RequestOpParamSetDoRequest::lookup,
        );
        res
    }
    pub fn op_region_get_dump_request(self) -> RequestOpRegionGetDumpRequest<'buf> {
        let mut res = RequestOpRegionGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-region-get-dump-request",
            RequestOpRegionGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_region_get_do_request(self) -> RequestOpRegionGetDoRequest<'buf> {
        let mut res = RequestOpRegionGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-region-get-do-request",
            RequestOpRegionGetDoRequest::lookup,
        );
        res
    }
    pub fn op_region_new_do_request(self) -> RequestOpRegionNewDoRequest<'buf> {
        let mut res = RequestOpRegionNewDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-region-new-do-request",
            RequestOpRegionNewDoRequest::lookup,
        );
        res
    }
    pub fn op_region_del_do_request(self) -> RequestOpRegionDelDoRequest<'buf> {
        let mut res = RequestOpRegionDelDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-region-del-do-request",
            RequestOpRegionDelDoRequest::lookup,
        );
        res
    }
    pub fn op_region_read_dump_request(self) -> RequestOpRegionReadDumpRequest<'buf> {
        let mut res = RequestOpRegionReadDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-region-read-dump-request",
            RequestOpRegionReadDumpRequest::lookup,
        );
        res
    }
    pub fn op_port_param_get_dump_request(self) -> RequestOpPortParamGetDumpRequest<'buf> {
        let mut res = RequestOpPortParamGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-port-param-get-dump-request",
            RequestOpPortParamGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_port_param_get_do_request(self) -> RequestOpPortParamGetDoRequest<'buf> {
        let mut res = RequestOpPortParamGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-port-param-get-do-request",
            RequestOpPortParamGetDoRequest::lookup,
        );
        res
    }
    pub fn op_port_param_set_do_request(self) -> RequestOpPortParamSetDoRequest<'buf> {
        let mut res = RequestOpPortParamSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-port-param-set-do-request",
            RequestOpPortParamSetDoRequest::lookup,
        );
        res
    }
    pub fn op_info_get_dump_request(self) -> RequestOpInfoGetDumpRequest<'buf> {
        let mut res = RequestOpInfoGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-info-get-dump-request",
            RequestOpInfoGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_info_get_do_request(self) -> RequestOpInfoGetDoRequest<'buf> {
        let mut res = RequestOpInfoGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-info-get-do-request",
            RequestOpInfoGetDoRequest::lookup,
        );
        res
    }
    pub fn op_health_reporter_get_dump_request(
        self,
    ) -> RequestOpHealthReporterGetDumpRequest<'buf> {
        let mut res = RequestOpHealthReporterGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-health-reporter-get-dump-request",
            RequestOpHealthReporterGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_health_reporter_get_do_request(self) -> RequestOpHealthReporterGetDoRequest<'buf> {
        let mut res = RequestOpHealthReporterGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-health-reporter-get-do-request",
            RequestOpHealthReporterGetDoRequest::lookup,
        );
        res
    }
    pub fn op_health_reporter_set_do_request(self) -> RequestOpHealthReporterSetDoRequest<'buf> {
        let mut res = RequestOpHealthReporterSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-health-reporter-set-do-request",
            RequestOpHealthReporterSetDoRequest::lookup,
        );
        res
    }
    pub fn op_health_reporter_recover_do_request(
        self,
    ) -> RequestOpHealthReporterRecoverDoRequest<'buf> {
        let mut res = RequestOpHealthReporterRecoverDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-health-reporter-recover-do-request",
            RequestOpHealthReporterRecoverDoRequest::lookup,
        );
        res
    }
    pub fn op_health_reporter_diagnose_do_request(
        self,
    ) -> RequestOpHealthReporterDiagnoseDoRequest<'buf> {
        let mut res = RequestOpHealthReporterDiagnoseDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-health-reporter-diagnose-do-request",
            RequestOpHealthReporterDiagnoseDoRequest::lookup,
        );
        res
    }
    pub fn op_health_reporter_dump_get_dump_request(
        self,
    ) -> RequestOpHealthReporterDumpGetDumpRequest<'buf> {
        let mut res = RequestOpHealthReporterDumpGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-health-reporter-dump-get-dump-request",
            RequestOpHealthReporterDumpGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_health_reporter_dump_clear_do_request(
        self,
    ) -> RequestOpHealthReporterDumpClearDoRequest<'buf> {
        let mut res = RequestOpHealthReporterDumpClearDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-health-reporter-dump-clear-do-request",
            RequestOpHealthReporterDumpClearDoRequest::lookup,
        );
        res
    }
    pub fn op_flash_update_do_request(self) -> RequestOpFlashUpdateDoRequest<'buf> {
        let mut res = RequestOpFlashUpdateDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-flash-update-do-request",
            RequestOpFlashUpdateDoRequest::lookup,
        );
        res
    }
    pub fn op_trap_get_dump_request(self) -> RequestOpTrapGetDumpRequest<'buf> {
        let mut res = RequestOpTrapGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-trap-get-dump-request",
            RequestOpTrapGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_trap_get_do_request(self) -> RequestOpTrapGetDoRequest<'buf> {
        let mut res = RequestOpTrapGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-trap-get-do-request",
            RequestOpTrapGetDoRequest::lookup,
        );
        res
    }
    pub fn op_trap_set_do_request(self) -> RequestOpTrapSetDoRequest<'buf> {
        let mut res = RequestOpTrapSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-trap-set-do-request",
            RequestOpTrapSetDoRequest::lookup,
        );
        res
    }
    pub fn op_trap_group_get_dump_request(self) -> RequestOpTrapGroupGetDumpRequest<'buf> {
        let mut res = RequestOpTrapGroupGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-trap-group-get-dump-request",
            RequestOpTrapGroupGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_trap_group_get_do_request(self) -> RequestOpTrapGroupGetDoRequest<'buf> {
        let mut res = RequestOpTrapGroupGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-trap-group-get-do-request",
            RequestOpTrapGroupGetDoRequest::lookup,
        );
        res
    }
    pub fn op_trap_group_set_do_request(self) -> RequestOpTrapGroupSetDoRequest<'buf> {
        let mut res = RequestOpTrapGroupSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-trap-group-set-do-request",
            RequestOpTrapGroupSetDoRequest::lookup,
        );
        res
    }
    pub fn op_trap_policer_get_dump_request(self) -> RequestOpTrapPolicerGetDumpRequest<'buf> {
        let mut res = RequestOpTrapPolicerGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-trap-policer-get-dump-request",
            RequestOpTrapPolicerGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_trap_policer_get_do_request(self) -> RequestOpTrapPolicerGetDoRequest<'buf> {
        let mut res = RequestOpTrapPolicerGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-trap-policer-get-do-request",
            RequestOpTrapPolicerGetDoRequest::lookup,
        );
        res
    }
    pub fn op_trap_policer_set_do_request(self) -> RequestOpTrapPolicerSetDoRequest<'buf> {
        let mut res = RequestOpTrapPolicerSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-trap-policer-set-do-request",
            RequestOpTrapPolicerSetDoRequest::lookup,
        );
        res
    }
    pub fn op_health_reporter_test_do_request(self) -> RequestOpHealthReporterTestDoRequest<'buf> {
        let mut res = RequestOpHealthReporterTestDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-health-reporter-test-do-request",
            RequestOpHealthReporterTestDoRequest::lookup,
        );
        res
    }
    pub fn op_rate_get_dump_request(self) -> RequestOpRateGetDumpRequest<'buf> {
        let mut res = RequestOpRateGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-rate-get-dump-request",
            RequestOpRateGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_rate_get_do_request(self) -> RequestOpRateGetDoRequest<'buf> {
        let mut res = RequestOpRateGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-rate-get-do-request",
            RequestOpRateGetDoRequest::lookup,
        );
        res
    }
    pub fn op_rate_set_do_request(self) -> RequestOpRateSetDoRequest<'buf> {
        let mut res = RequestOpRateSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-rate-set-do-request",
            RequestOpRateSetDoRequest::lookup,
        );
        res
    }
    pub fn op_rate_new_do_request(self) -> RequestOpRateNewDoRequest<'buf> {
        let mut res = RequestOpRateNewDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-rate-new-do-request",
            RequestOpRateNewDoRequest::lookup,
        );
        res
    }
    pub fn op_rate_del_do_request(self) -> RequestOpRateDelDoRequest<'buf> {
        let mut res = RequestOpRateDelDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-rate-del-do-request",
            RequestOpRateDelDoRequest::lookup,
        );
        res
    }
    pub fn op_linecard_get_dump_request(self) -> RequestOpLinecardGetDumpRequest<'buf> {
        let mut res = RequestOpLinecardGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-linecard-get-dump-request",
            RequestOpLinecardGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_linecard_get_do_request(self) -> RequestOpLinecardGetDoRequest<'buf> {
        let mut res = RequestOpLinecardGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-linecard-get-do-request",
            RequestOpLinecardGetDoRequest::lookup,
        );
        res
    }
    pub fn op_linecard_set_do_request(self) -> RequestOpLinecardSetDoRequest<'buf> {
        let mut res = RequestOpLinecardSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-linecard-set-do-request",
            RequestOpLinecardSetDoRequest::lookup,
        );
        res
    }
    pub fn op_selftests_get_dump_request(self) -> RequestOpSelftestsGetDumpRequest<'buf> {
        let mut res = RequestOpSelftestsGetDumpRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-selftests-get-dump-request",
            RequestOpSelftestsGetDumpRequest::lookup,
        );
        res
    }
    pub fn op_selftests_get_do_request(self) -> RequestOpSelftestsGetDoRequest<'buf> {
        let mut res = RequestOpSelftestsGetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-selftests-get-do-request",
            RequestOpSelftestsGetDoRequest::lookup,
        );
        res
    }
    pub fn op_selftests_run_do_request(self) -> RequestOpSelftestsRunDoRequest<'buf> {
        let mut res = RequestOpSelftestsRunDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-selftests-run-do-request",
            RequestOpSelftestsRunDoRequest::lookup,
        );
        res
    }
    pub fn op_notify_filter_set_do_request(self) -> RequestOpNotifyFilterSetDoRequest<'buf> {
        let mut res = RequestOpNotifyFilterSetDoRequest::new(self);
        res.request.do_writeback(
            res.protocol(),
            "op-notify-filter-set-do-request",
            RequestOpNotifyFilterSetDoRequest::lookup,
        );
        res
    }
}
